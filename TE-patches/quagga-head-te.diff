diff --git a/configure.ac b/configure.ac
index f1df482..12c1fef 100755
--- a/configure.ac
+++ b/configure.ac
@@ -243,6 +243,8 @@ AC_ARG_ENABLE(ospfclient,
                           (this is the default if --disable-ospfapi is set)])
 AC_ARG_ENABLE(ospf-te,
   AC_HELP_STRING([--disable-ospf-te],[disable Traffic Engineering Extension to OSPF]))
+AC_ARG_ENABLE(ospf-ri,
+  AC_HELP_STRING([--disable-ospf-ri],[disable Router Information Extension to OSPF]))
 AC_ARG_ENABLE(multipath,
 [  --enable-multipath=ARG  enable multipath function, ARG must be digit])
 AC_ARG_ENABLE(user,
@@ -262,6 +264,8 @@ AC_ARG_ENABLE(irdp,
 [  --enable-irdp                 enable IRDP server support in zebra])
 AC_ARG_ENABLE(isis_topology,
 [  --enable-isis-topology        enable IS-IS topology generator])
+AC_ARG_ENABLE(isis-te,
+[  --enable-isis-te              enable Traffic Engineering Extension (i.e. MPLS-TE) to IS-IS])
 AC_ARG_ENABLE(capabilities,
 [  --disable-capabilities        disable using POSIX capabilities])
 AC_ARG_ENABLE(rusage,
@@ -328,6 +332,11 @@ if test "${enable_ospf_te}" != "no"; then
   AC_DEFINE(HAVE_OSPF_TE,,OSPF TE)
 fi
 
+if test "${enable_ospf_ri}" != "no"; then
+  AC_DEFINE(HAVE_OPAQUE_LSA,,OSPF Opaque LSA)
+  AC_DEFINE(HAVE_OSPF_RI,,OSPF RI)
+fi
+
 if test "${enable_linux24_tcp_md5}" = "yes"; then
   AC_DEFINE(HAVE_TCP_MD5_LINUX24,,Old Linux 2.4 TCP MD5 Signature Patch)
 fi
@@ -351,6 +360,10 @@ if test "${enable_isisd}" = "yes" && test "${enable_isis_topology}" = yes; then
   ISIS_TOPOLOGY_LIB="./topology/libtopology.a"
 fi
 
+if test "${enable_isis_te}" != "no"; then
+  AC_DEFINE(HAVE_ISIS_TE,,ISIS TE)
+fi
+
 AC_SUBST(ISIS_TOPOLOGY_INCLUDES)
 AC_SUBST(ISIS_TOPOLOGY_DIR)
 AC_SUBST(ISIS_TOPOLOGY_LIB)
diff --git a/doc/basic.texi b/doc/basic.texi
index b3b23ca..a091281 100644
--- a/doc/basic.texi
+++ b/doc/basic.texi
@@ -580,7 +580,7 @@ Move up to previous line in the history buffer.
 @kindex @key{TAB}
 Use command line completion by typing @key{TAB}.
 
-@item
+@item ?
 @kindex ?
 You can use command line help by typing @code{help} at the beginning of
 the line.  Typing @kbd{?} at any point in the line will show possible
diff --git a/doc/install.texi b/doc/install.texi
index e958d84..9c0bfbf 100644
--- a/doc/install.texi
+++ b/doc/install.texi
@@ -83,8 +83,17 @@ OSPF-API is enabled if --enable-opaque-lsa is set.
 @item --disable-ospfclient
 Disable building of the example OSPF-API client.
 @item --disable-ospf-te
-Disable support for OSPF Traffic Engineering Extension (internet-draft) this
+Disable support for OSPF Traffic Engineering Extension (RFC3630) this
 requires support for Opaque LSAs.
+@item --disable-ospf-ri
+Disable support for OSPF Router Information (RFC4970 & RFC5088) this
+requires support for Opaque LSAs and Traffic Engineering.
+@item --enable-isisd
+Build isisd.
+@item --enable-isis-topology
+Enable IS-IS topology generator.
+@item --enable-isis-te
+Enable Traffic Engineering Extension for ISIS (RFC5305)
 @item --enable-multipath=@var{ARG}
 Enable support for Equal Cost Multipath. @var{ARG} is the maximum number
 of ECMP paths to allow, set to 0 to allow unlimited number of paths.
diff --git a/doc/isisd.texi b/doc/isisd.texi
new file mode 100644
index 0000000..bbc2896
--- /dev/null
+++ b/doc/isisd.texi
@@ -0,0 +1,432 @@
+@cindex ISIS
+@node ISIS
+@chapter ISIS
+
+@acronym{ISIS,Intermediate System to Intermediate System} is a routing protocol
+which is described in @cite{ISO10589, RFC1195, RFC5308}.  ISIS is an
+@acronym{IGP,Interior Gateway Protocol}.  Compared with @acronym{RIP},
+@acronym{ISIS} can provide scalable network support and faster
+convergence times like @acronym{OSPF}. ISIS is widely used in large networks such as
+@acronym{ISP,Internet Service Provider} and carrier backbone networks.
+
+@menu
+* Configuring isisd::
+* ISIS router::
+* ISIS Timer::
+* ISIS region::
+* ISIS interface::
+* Showing ISIS information::
+* ISIS Traffic Engineering::
+* Debugging ISIS::
+* ISIS Configuration Examples::
+@end menu
+
+@node Configuring isisd
+@section Configuring isisd
+
+There are no @command{isisd} specific options.  Common options can be
+specified (@pxref{Common Invocation Options}) to @command{isisd}.
+@command{isisd} needs to acquire interface information from
+@command{zebra} in order to function. Therefore @command{zebra} must be
+running before invoking @command{isisd}. Also, if @command{zebra} is
+restarted then @command{isisd} must be too.
+
+Like other daemons, @command{isisd} configuration is done in @acronym{ISIS}
+specific configuration file @file{isisd.conf}.
+
+@node ISIS router
+@section ISIS router
+
+To start ISIS process you have to specify the ISIS router. As of this
+writing, @command{isisd} does not support multiple ISIS processes.
+
+@deffn Command {router isis WORD} {}
+@deffnx Command {no router isis WORD} {}
+@anchor{router isis WORD}Enable or disable the ISIS process by specifying the ISIS domain with 'WORD'.
+@command{isisd} does not yet support multiple ISIS processes but you must specify
+the name of ISIS process. The ISIS process name 'WORD' is then used for interface
+(see command @ref{ip router isis WORD}).
+@end deffn
+
+@deffn {ISIS Command} {net XX.XXXX. ... .XXX.XX} {}
+@deffnx {ISIS Command} {no net XX.XXXX. ... .XXX.XX} {}
+Set/Unset network entity title (NET) provided in ISO format.
+@end deffn
+
+@deffn {ISIS Command} {hostname dynamic} {}
+@deffnx {ISIS Command} {no hostname dynamic} {}
+Enable support for dynamic hostname.
+@end deffn
+
+@deffn {ISIS Command} {area-password [clear | md5] <password>} {}
+@deffnx {ISIS Command} {domain-password [clear | md5] <password>} {}
+@deffnx {ISIS Command} {no area-password} {}
+@deffnx {ISIS Command} {no domain-password} {}
+Configure the authentication password for an area, respectively a domain,
+as clear text or md5 one.
+@end deffn
+
+@deffn {ISIS Command} {log-adjacency-changes} {}
+@deffnx {ISIS Command} {no log-adjacency-changes} {}
+Log changes in adjacency state.
+@end deffn
+
+@deffn {ISIS Command} {metric-style [narrow | transition | wide]} {}
+@deffnx {ISIS Command} {no metric-style} {}
+@anchor{metric-style}Set old-style (ISO 10589) or new-style packet formats:
+  - narrow      Use old style of TLVs with narrow metric
+  - transition  Send and accept both styles of TLVs during transition
+  - wide        Use new style of TLVs to carry wider metric
+@end deffn
+
+@deffn {ISIS Command} {set-overload-bit} {}
+@deffnx {ISIS Command} {no set-overload-bit} {}
+Set overload bit to avoid any transit traffic.
+@end deffn
+
+@node ISIS Timer
+@section ISIS Timer
+
+@deffn {ISIS Command} {lsp-gen-interval <1-120>} {}
+@deffnx {ISIS Command} {lsp-gen-interval [level-1 | level-2] <1-120>} {}
+@deffnx {ISIS Command} {no lsp-gen-interval} {}
+@deffnx {ISIS Command} {no lsp-gen-interval [level-1 | level-2]} {}
+Set minimum interval in seconds between regenerating same LSP,
+globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {ISIS Command} {lsp-refresh-interval <1-65235>} {}
+@deffnx {ISIS Command} {lsp-refresh-interval [level-1 | level-2] <1-65235>} {}
+@deffnx {ISIS Command} {no lsp-refresh-interval} {}
+@deffnx {ISIS Command} {no lsp-refresh-interval [level-1 | level-2]} {}
+Set LSP refresh interval in seconds, globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {ISIS Command} {lsp-refresh-interval <1-65235>} {}
+@deffnx {ISIS Command} {lsp-refresh-interval [level-1 | level-2] <1-65235>} {}
+@deffnx {ISIS Command} {no lsp-refresh-interval} {}
+@deffnx {ISIS Command} {no lsp-refresh-interval [level-1 | level-2]} {}
+Set LSP refresh interval in seconds, globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {ISIS Command} {max-lsp-lifetime <360-65535>} {}
+@deffnx {ISIS Command} {max-lsp-lifetime [level-1 | level-2] <360-65535>} {}
+@deffnx {ISIS Command} {no max-lsp-lifetime} {}
+@deffnx {ISIS Command} {no max-lsp-lifetime [level-1 | level-2]} {}
+Set LSP maximum LSP lifetime in seconds, globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {ISIS Command} {spf-interval <1-120>} {}
+@deffnx {ISIS Command} {spf-interval [level-1 | level-2] <1-120>} {}
+@deffnx {ISIS Command} {no spf-interval} {}
+@deffnx {ISIS Command} {no spf-interval [level-1 | level-2]} {}
+Set minimum interval between consecutive SPF calculations in seconds.
+@end deffn
+
+@node ISIS region
+@section ISIS region
+
+@deffn {ISIS Command} {is-type [level-1 | level-1-2 | level-2-only]} {}
+@deffnx {ISIS Command} {no is-type} {}
+Define the ISIS router behavior:
+ - level-1       Act as a station router only
+ - level-1-2     Act as both a station router and an area router
+ - level-2-only  Act as an area router only
+@end deffn
+
+@node ISIS interface
+@section ISIS interface
+
+@deffn {Interface Command} {ip router isis WORD} {}
+@deffnx {Interface Command} {no ip router isis WORD} {}
+@anchor{ip router isis WORD}Activate ISIS adjacency on this interface. Note that the name
+of ISIS instance must be the same as the one used to configure the ISIS process
+(see command @ref{router isis WORD}).
+@end deffn
+
+@deffn {Interface Command} {isis circuit-type [level-1 | level-1-2 | level-2]} {}
+@deffnx {Interface Command} {no isis circuit-type} {}
+Configure circuit type for interface:
+  - level-1       Level-1 only adjacencies are formed
+  - level-1-2     Level-1-2 adjacencies are formed
+  - level-2-only  Level-2 only adjacencies are formed
+@end deffn
+
+@deffn {Interface Command} {isis csnp-interval <1-600>} {}
+@deffnx {Interface Command} {isis csnp-interval <1-600> [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis csnp-interval} {}
+@deffnx {Interface Command} {no isis csnp-interval [level-1 | level-2]} {}
+Set CSNP interval in seconds globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {Interface Command} {isis hello padding} {}
+Add padding to IS-IS hello packets.
+@end deffn
+
+@deffn {Interface Command} {isis hello-interval <1-600>} {}
+@deffnx {Interface Command} {isis hello-interval <1-600> [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis hello-interval} {}
+@deffnx {Interface Command} {no isis hello-interval [level-1 | level-2]} {}
+Set Hello interval in seconds globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {Interface Command} {isis hello-multiplier <2-100>} {}
+@deffnx {Interface Command} {isis hello-multiplier <2-100> [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis hello-multiplier} {}
+@deffnx {Interface Command} {no isis hello-multiplier [level-1 | level-2]} {}
+Set multiplier for Hello holding time globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@deffn {Interface Command} {isis metric [<0-255> | <0-16777215>]} {}
+@deffnx {Interface Command} {isis metric [<0-255> | <0-16777215>] [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis metric} {}
+@deffnx {Interface Command} {no isis metric [level-1 | level-2]} {}
+Set default metric value globally, for an area (level-1) or a domain (level-2).
+Max value depend if metric support narrow or wide value (see command @ref{metric-style}).
+@end deffn
+
+@deffn {Interface Command} {isis network point-to-point} {}
+@deffnx {Interface Command} {no isis network point-to-point} {}
+Set network type to 'Point-to-Point' (broadcast by default).
+@end deffn
+
+@deffn {Interface Command} {isis passive} {}
+@deffnx {Interface Command} {no isis passive} {}
+Configure the passive mode for this interface.
+@end deffn
+
+@deffn {Interface Command} {isis password [clear | md5] <password>} {}
+@deffnx {Interface Command} {no isis password} {}
+Configure the authentication password (clear or encoded text) for the interface.
+@end deffn
+
+@deffn {Interface Command} {isis priority <0-127>} {}
+@deffnx {Interface Command} {isis priority <0-127> [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis priority} {}
+@deffnx {Interface Command} {no isis priority [level-1 | level-2]} {}
+Set priority for Designated Router election, globally, for the area (level-1)
+or the domain (level-2).
+@end deffn
+
+@deffn {Interface Command} {isis psnp-interval <1-120>} {}
+@deffnx {Interface Command} {isis psnp-interval <1-120> [level-1 | level-2]} {}
+@deffnx {Interface Command} {no isis psnp-interval} {}
+@deffnx {Interface Command} {no isis psnp-interval [level-1 | level-2]} {}
+Set PSNP interval in seconds globally, for an area (level-1) or a domain (level-2).
+@end deffn
+
+@node Showing ISIS information
+@section Showing ISIS information
+
+@deffn {Command} {show isis summary} {}
+Show summary information about ISIS.
+@end deffn
+
+@deffn {Command} {show isis hostname} {}
+Show information about ISIS node.
+@end deffn
+
+@deffn {Command} {show isis interface} {}
+@deffnx {Command} {show isis interface detail} {}
+@deffnx {Command} {show isis interface <interface name>} {}
+Show state and configuration of ISIS specified interface, or all
+interfaces if no interface is given with or without details.
+@end deffn
+
+@deffn {Command} {show isis neighbor} {}
+@deffnx {Command} {show isis neighbor <System Id>} {}
+@deffnx {Command} {show isis neighbor detail} {}
+Show state and information of ISIS specified neighbor, or all
+neighbors if no system id is given with or without details.
+@end deffn
+
+@deffn {Command} {show isis database} {}
+@deffnx {Command} {show isis database [detail]} {}
+@deffnx {Command} {show isis database <LSP id> [detail]} {}
+@deffnx {Command} {show isis database detail <LSP id>} {}
+Show the ISIS database globally, for a specific LSP id without or with details.
+@end deffn
+
+@deffn {Command} {show isis topology} {}
+@deffnx {Command} {show isis topology [level-1|level-2]} {}
+Show topology IS-IS paths to Intermediate Systems, globally,
+in area (level-1) or domain (level-2).
+@end deffn
+
+@deffn {Command} {show ip route isis} {}
+Show the ISIS routing table, as determined by the most recent SPF calculation.
+@end deffn
+
+@node ISIS Traffic Engineering
+@section Traffic Engineering
+
+@deffn {ISIS Command} {mpls-te on} {}
+@deffnx {ISIS Command} {no mpls-te} {}
+Enable Traffic Engineering LSP flooding.
+@end deffn
+
+@deffn {ISIS Command} {mpls-te router-address <A.B.C.D>} {}
+@deffnx {ISIS Command} {no mpls-te router-address} {}
+Configure stable IP address for MPLS-TE.
+@end deffn
+
+@deffn {Command} {show isis mpls-te interface} {}
+@deffnx {Command} {show isis mpls-te interface @var{interface}} {}
+Show MPLS Traffic Engineering parameters for all or specified interface.
+@end deffn
+
+@deffn {Command} {show isis mpls-te router} {}
+Show Traffic Engineering router parameters.
+@end deffn
+
+@node Debugging ISIS
+@section Debugging ISIS
+
+@deffn {Command} {debug isis adj-packets} {}
+@deffnx {Command} {no debug isis adj-packets} {}
+IS-IS Adjacency related packets.
+@end deffn
+
+@deffn {Command} {debug isis checksum-errors} {}
+@deffnx {Command} {no debug isis checksum-errors} {}
+IS-IS LSP checksum errors.
+@end deffn
+
+@deffn {Command} {debug isis events} {}
+@deffnx {Command} {no debug isis events} {}
+IS-IS Events.
+@end deffn
+
+@deffn {Command} {debug isis local-updates} {}
+@deffnx {Command} {no debug isis local-updates} {}
+IS-IS local update packets.
+@end deffn
+
+@deffn {Command} {debug isis packet-dump} {}
+@deffnx {Command} {no debug isis packet-dump} {}
+IS-IS packet dump.
+@end deffn
+
+@deffn {Command} {debug isis protocol-errors} {}
+@deffnx {Command} {no debug isis protocol-errors} {}
+IS-IS LSP protocol errors.
+@end deffn
+
+@deffn {Command} {debug isis route-events} {}
+@deffnx {Command} {no debug isis route-events} {}
+IS-IS Route related events.
+@end deffn
+
+@deffn {Command} {debug isis snp-packets} {}
+@deffnx {Command} {no debug isis snp-packets} {}
+IS-IS CSNP/PSNP packets.
+@end deffn
+
+@deffn {Command} {debug isis spf-events} {}
+@deffnx {Command} {debug isis spf-statistics} {}
+@deffnx {Command} {debug isis spf-triggers} {}
+@deffnx {Command} {no debug isis spf-events} {}
+@deffnx {Command} {no debug isis spf-statistics} {}
+@deffnx {Command} {no debug isis spf-triggers} {}
+IS-IS Shortest Path First Events, Timing and Statistic Data
+and triggering events.
+@end deffn
+
+@deffn {Command} {debug isis update-packets} {}
+@deffnx {Command} {no debug isis update-packets} {}
+Update related packets.
+@end deffn
+
+@deffn {Command} {show debugging isis} {}
+Print which ISIS debug level is activate.
+@end deffn
+
+@node ISIS Configuration Examples
+@section ISIS Configuration Examples
+A simple example, with MD5 authentication enabled:
+
+@example
+@group
+!
+interface eth0
+ ip router isis FOO
+ isis network point-to-point
+ isis circuit-type level-2-only
+!
+router isis FOO
+net 47.0023.0000.0000.0000.0000.0000.0000.1900.0004.00
+ metric-style wide
+ is-type level-2-only
+@end group
+@end example
+
+
+A Traffic Engineering configuration, with Inter-ASv2 support.
+
+ - First, the 'zebra.conf' part:
+
+@example
+@group
+hostname HOSTNAME
+password PASSWORD
+log file /var/log/zebra.log
+!
+interface eth0
+ ip address 10.2.2.2/24
+ mpls-te on
+ mpls-te link metric 10
+ mpls-te link max-bw 1.25e+06
+ mpls-te link max-rsv-bw 1.25e+06
+ mpls-te link unrsv-bw 0 1.25e+06
+ mpls-te link unrsv-bw 1 1.25e+06
+ mpls-te link unrsv-bw 2 1.25e+06
+ mpls-te link unrsv-bw 3 1.25e+06
+ mpls-te link unrsv-bw 4 1.25e+06
+ mpls-te link unrsv-bw 5 1.25e+06
+ mpls-te link unrsv-bw 6 1.25e+06
+ mpls-te link unrsv-bw 7 1.25e+06
+ mpls-te link rsc-clsclr 0xab
+!
+interface eth1
+ ip address 10.1.1.1/24
+ mpls-te on
+ mpls-te link metric 10
+ mpls-te link max-bw 1.25e+06
+ mpls-te link max-rsv-bw 1.25e+06
+ mpls-te link unrsv-bw 0 1.25e+06
+ mpls-te link unrsv-bw 1 1.25e+06
+ mpls-te link unrsv-bw 2 1.25e+06
+ mpls-te link unrsv-bw 3 1.25e+06
+ mpls-te link unrsv-bw 4 1.25e+06
+ mpls-te link unrsv-bw 5 1.25e+06
+ mpls-te link unrsv-bw 6 1.25e+06
+ mpls-te link unrsv-bw 7 1.25e+06
+ mpls-te link rsc-clsclr 0xab
+ mpls-te neighbor 10.1.1.2 as 65000
+@end group
+@end example
+
+ - Then the 'isisd.conf' itself:
+
+@example
+@group
+hostname HOSTNAME
+password PASSWORD
+log file /var/log/isisd.log
+!
+!
+interface eth0
+ ip router isis FOO
+!
+interface eth1
+ ip router isis FOO
+!
+!
+router isis FOO
+ isis net 47.0023.0000.0000.0000.0000.0000.0000.1900.0004.00
+  mpls-te on
+  mpls-te router-address 10.1.1.1
+!
+line vty
+@end group
+@end example
diff --git a/doc/main.texi b/doc/main.texi
index a6bf0d1..f39c7ac 100644
--- a/doc/main.texi
+++ b/doc/main.texi
@@ -85,6 +85,49 @@ only Linux and Solaris, and only where network interface drivers support reporti
 link-state via the IFF_RUNNING flag.
 @end deffn
 
+@subsection Traffic Engineering Parameters
+
+@deffn {Interface Command} {mpls-te on} {}
+@deffnx {Interface Command} {no mpls-te} {}
+Enable Traffic Engineering on this interface. MPLS-TE must be enable at the OSPF (@ref{OSPF Traffic Engineering})
+or ISIS (@ref{ISIS Traffic Engineering}) router level prior to this.
+@end deffn
+
+@deffn {Interface Command} {mpls-te link metric <0-4294967295>} {}
+@deffnx {Interface Command} {mpls-te link max-bw @var{bandwidth}} {}
+@deffnx {Interface Command} {mpls-te link max-rsv-bw @var{bandwidth}} {}
+@deffnx {Interface Command} {mpls-te link unrsv-bw <0-7> @var{bandwidth}} {}
+@deffnx {Interface Command} {mpls-te link admin-grp @var{bandwidth}} {}
+These commands specifies the Traffic Engineering parameters of the interface in conformity to RFC3630 (OSPF)
+or RFC5305 (ISIS).
+There are respectively the TE Metric (different from the OSPF or ISIS metric), Maximum Bandwidth (interface speed
+by default), Maximum Reservable Bandwidth, Unreserved Bandwidth for each 0-7 priority and Admin Group (ISIS) or
+Resource Class/Color (OSPF).
+
+Note that @var{bandwidth} are specified in IEEE floating point format and express in Bytes/second.
+@end deffn
+
+@deffn {Interface Command} {mpls-te link delay <0-16777215> [min <0-16777215> | max <0-16777215>]} {}
+@deffnx {Interface Command} {mpls-te link delay-variation <0-16777215>} {}
+@deffnx {Interface Command} {mpls-te link packet-loss @var{percentage}} {}
+@deffnx {Interface Command} {mpls-te link res-bw @var{bandwidth}} {}
+@deffnx {Interface Command} {mpls-te link ava-bw @var{bandwidth}} {}
+@deffnx {Interface Command} {mpls-te link use-bw @var{bandwidth}} {}
+These command specifies additionnal Traffic Engineering parameters of the interface in conformity to
+draft-ietf-ospf-te-metrics-extension-05.txt and draft-ietf-isis-te-metrics-extension-03.txt. There are
+respectively the delay, jitter, loss, available bandwidth, reservable bandwidth and utilized bandwidth. 
+
+Note that @var{bandwidth} are specified in IEEE floating point format and express in Bytes/second.
+Delays and delay variation are express in micro-second (µs). Loss is specified in @var{percentage} ranging
+from 0 to 50.331642% by step of 0.000003.
+@end deffn
+
+@deffn {Interface Command} {mpls-te neighbor <A.B.C.D> as <0-65535>} {}
+@deffnx {Interface Command} {no mpls-te neighbor} {}
+Specifies the remote ASBR IP address and Autonomous System (AS) number for InterASv2 link in OSPF (RFC5392).
+Note that this option is not yet supported for ISIS (RFC5316).
+@end deffn
+
 @node Static Route Commands
 @section Static Route Commands
 
diff --git a/doc/mpls/ChangeLog.opaque.txt b/doc/mpls/ChangeLog.opaque.txt
index 68ddf4c..afcfaa3 100644
--- a/doc/mpls/ChangeLog.opaque.txt
+++ b/doc/mpls/ChangeLog.opaque.txt
@@ -1,4 +1,17 @@
 ----- * ----- * ----- * ----- * ----- * ----- * ----- * ----- * ----- * -----
+Changes 2013.07.01
+
+1. Feature enhancements
+
+  1.1 Update ospf_te.[c,h] in conformance to RFC3630 and clean the code.
+      Add new directive to enable MPLS-TE per interface instead of globally
+
+  1.2 Add support for RFC4970 "Router Information" and RFC5088 "PCE
+      Capabilities announcement".
+
+  1.3 Incorporate the mpls documentation into the main stream doc.
+
+----- * ----- * ----- * ----- * ----- * ----- * ----- * ----- * ----- * -----
 Changes 2001.12.03
 
 1. Bug fixes
diff --git a/doc/mpls/ospfd.conf b/doc/mpls/ospfd.conf
index 6be11f9..2b15fa4 100644
--- a/doc/mpls/ospfd.conf
+++ b/doc/mpls/ospfd.conf
@@ -17,6 +17,7 @@ debug ospf packet all detail
 interface fxp0
  ip ospf hello-interval 60
  ip ospf dead-interval 240
+ mpls-te on
  mpls-te link metric 999
  mpls-te link max-bw 1.25e+06
  mpls-te link max-rsv-bw 1.25e+06
diff --git a/doc/ospfd.texi b/doc/ospfd.texi
index 856a2ba..7854d43 100644
--- a/doc/ospfd.texi
+++ b/doc/ospfd.texi
@@ -1,3 +1,4 @@
+
 @cindex OSPFv2
 @node OSPFv2
 @chapter OSPFv2
@@ -17,6 +18,9 @@ networks.
 * OSPF interface::              
 * Redistribute routes to OSPF::  
 * Showing OSPF information::    
+* Opaque LSA::
+* OSPF Traffic Engineering::
+* Router Information::
 * Debugging OSPF::              
 * OSPF Configuration Examples::
 @end menu
@@ -608,35 +612,137 @@ interfaces if no interface is given.
 Show the OSPF routing table, as determined by the most recent SPF calculation.
 @end deffn
 
+@node Opaque LSA
+@section Opaque LSA
+
+@deffn {OSPF Command} {ospf opaque-lsa} {}
+@deffnx {OSPF Command} {capability opaque} {}
+@deffnx {OSPF Command} {no ospf opaque-lsa} {} 
+@deffnx {OSPF Command} {no capability opaque} {}
+@command{ospfd} support Opaque LSA (RFC2370) as fondment for MPLS Traffic Engineering LSA. Prior to used MPLS TE, opaque-lsa must be enable in the configuration file. Alternate command could be "mpls-te on" (@ref{OSPF Traffic Engineering}).
+@end deffn
+
+@deffn {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external)} {}
+@deffnx {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external) @var{link-state-id}} {}
+@deffnx {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external) @var{link-state-id} adv-router @var{adv-router}} {}
+@deffnx {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external) adv-router @var{adv-router}} {}
+@deffnx {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external) @var{link-state-id} self-originate} {}
+@deffnx {Command} {show ip ospf database (opaque-link|opaque-area|opaque-external) self-originate} {}
+Show Opaque LSA from the database.
+@end deffn
+
+@node OSPF Traffic Engineering
+@section Traffic Engineering
+
+@deffn {OSPF Command} {mpls-te on} {}
+@deffnx {OSPF Command} {no mpls-te} {}
+Enable Traffic Engineering LSA flooding.
+@end deffn
+
+@deffn {OSPF Command} {mpls-te router-address <A.B.C.D>} {}
+@deffnx {OSPF Command} {no mpls-te} {}
+Configure stable IP address for MPLS-TE. This IP address is then advertise in Opaque LSA Type-10 TLV=1 (TE)
+option 1 (Router-Address).
+@end deffn
+
+@deffn {OSPF Command} {mpls-te inter-as area <area-id>|as} {}
+@deffnx {OSPF Command} {no mpls-te inter-as} {}
+Enable RFC5392 suuport - Inter-AS TE v2 - to flood Traffic Engineering parameters of Inter-AS link.
+2 modes are supported: AREA and AS; LSA are flood in AREA <area-id> with Opaque Type-10, 
+respectively in AS with Opaque Type-11. In all case, Opaque-LSA TLV=6.
+@end deffn
+
+@deffn {Command} {show ip ospf mpls-te interface} {}
+@deffnx {Command} {show ip ospf mpls-te interface @var{interface}} {}
+Show MPLS Traffic Engineering parameters for all or specified interface.
+@end deffn
+
+@deffn {Command} {show ip ospf mpls-te router} {}
+Show Traffic Engineering router parameters.
+@end deffn
+
+@node Router Information
+@section Router Information
+
+@deffn {OSPF Command} {router-info [as | area <A.B.C.D>]} {}
+@deffnx {OSPF Command} {no router-info} {}
+Enable Router Information (RFC4970) LSA advertisement with AS scope (default) or Area scope flooding
+when area is specified.
+@end deffn
+
+@deffn {OSPF Command} {pce address <A.B.C.D>} {}
+@deffnx {OSPF Command} {no pce address} {}
+@deffnx {OSPF Command} {pce domain as <0-65535>} {}
+@deffnx {OSPF Command} {no pce domain as <0-65535>} {}
+@deffnx {OSPF Command} {pce neighbor as <0-65535>} {}
+@deffnx {OSPF Command} {no pce neighbor as <0-65535>} {}
+@deffnx {OSPF Command} {pce flag BITPATTERN} {}
+@deffnx {OSPF Command} {no pce flag} {}
+@deffnx {OSPF Command} {pce scope BITPATTERN} {}
+@deffnx {OSPF Command} {no pce scope} {}
+The commands are conform to RFC 5088 and allow OSPF router announce Path Compuatation Elemenent (PCE) capabilities
+through the Router Information (RI) LSA. Router Information must be enable prior to this. The command set/unset
+respectively the PCE IP adress, Autonomous System (AS) numbers of controlled domains, neighbor ASs, flag and scope.
+For flag and scope, please refer to RFC5088 for the BITPATTERN recognition. Multiple 'pce neighbor' command could
+be specified in order to specify all PCE neighbours.
+@end deffn
+
+@deffn {Command} {show ip ospf router-info} {}
+Show Router Capabilities flag.
+@end deffn
+@deffn {Command} {show ip ospf router-info pce} {}
+Show Router Capabilities PCE parameters.
+@end deffn
+
 @node Debugging OSPF
 @section Debugging OSPF
 
 @deffn {Command} {debug ospf packet (hello|dd|ls-request|ls-update|ls-ack|all) (send|recv) [detail]} {}
 @deffnx {Command} {no debug ospf packet (hello|dd|ls-request|ls-update|ls-ack|all) (send|recv) [detail]} {}
+Dump Packet for debugging
 @end deffn
 
 @deffn {Command} {debug ospf ism} {}
 @deffnx {Command} {debug ospf ism (status|events|timers)} {}
 @deffnx {Command} {no debug ospf ism} {}
 @deffnx {Command} {no debug ospf ism (status|events|timers)} {}
+Show debug information of Interface State Machine
 @end deffn
 
 @deffn {Command} {debug ospf nsm} {}
 @deffnx {Command} {debug ospf nsm (status|events|timers)} {}
 @deffnx {Command} {no debug ospf nsm} {}
 @deffnx {Command} {no debug ospf nsm (status|events|timers)} {}
+Show debug information of Network State Machine
+@end deffn
+
+@deffn {Command} {debug ospf event} {}
+@deffnx {Command} {no debug ospf event} {}
+Show debug information of OSPF event
+@end deffn
+
+@deffn {Command} {debug ospf nssa} {}
+@deffnx {Command} {no debug ospf nssa} {}
+Show debug information about Not So Stub Area
 @end deffn
 
 @deffn {Command} {debug ospf lsa} {}
 @deffnx {Command} {debug ospf lsa (generate|flooding|refresh)} {}
 @deffnx {Command} {no debug ospf lsa} {}
 @deffnx {Command} {no debug ospf lsa (generate|flooding|refresh)} {}
+Show debug detail of Link State messages
+@end deffn
+
+@deffn {Command} {debug ospf te} {}
+@deffnx {Command} {no debug ospf te} {}
+Show debug information about Traffic Engineering LSA
 @end deffn
 
 @deffn {Command} {debug ospf zebra} {}
 @deffnx {Command} {debug ospf zebra (interface|redistribute)} {}
 @deffnx {Command} {no debug ospf zebra} {}
 @deffnx {Command} {no debug ospf zebra (interface|redistribute)} {}
+Show debug information of ZEBRA API
 @end deffn
 
 @deffn {Command} {show debugging ospf} {}
@@ -694,3 +800,100 @@ router ospf
 !
 @end group
 @end example
+
+A Traffic Engineering configuration, with Inter-ASv2 support.
+
+ - First, the 'zebra.conf' part:
+
+@example
+@group
+hostname HOSTNAME
+password PASSWORD
+log file /var/log/zebra.log
+!
+interface eth0
+ ip address 198.168.1.1/24
+ mpls-te on
+ mpls-te link metric 10
+ mpls-te link max-bw 1.25e+06
+ mpls-te link max-rsv-bw 1.25e+06
+ mpls-te link unrsv-bw 0 1.25e+06
+ mpls-te link unrsv-bw 1 1.25e+06
+ mpls-te link unrsv-bw 2 1.25e+06
+ mpls-te link unrsv-bw 3 1.25e+06
+ mpls-te link unrsv-bw 4 1.25e+06
+ mpls-te link unrsv-bw 5 1.25e+06
+ mpls-te link unrsv-bw 6 1.25e+06
+ mpls-te link unrsv-bw 7 1.25e+06
+ mpls-te link rsc-clsclr 0xab
+!
+interface eth1
+ ip address 192.168.2.1/24
+ mpls-te on
+ mpls-te link metric 10
+ mpls-te link max-bw 1.25e+06
+ mpls-te link max-rsv-bw 1.25e+06
+ mpls-te link unrsv-bw 0 1.25e+06
+ mpls-te link unrsv-bw 1 1.25e+06
+ mpls-te link unrsv-bw 2 1.25e+06
+ mpls-te link unrsv-bw 3 1.25e+06
+ mpls-te link unrsv-bw 4 1.25e+06
+ mpls-te link unrsv-bw 5 1.25e+06
+ mpls-te link unrsv-bw 6 1.25e+06
+ mpls-te link unrsv-bw 7 1.25e+06
+ mpls-te link rsc-clsclr 0xab
+ mpls-te neighbor 192.168.2.2 as 65000
+@end group
+@end example
+
+ - Then the 'ospfd.conf' itself:
+
+@example
+@group
+hostname HOSTNAME
+password PASSWORD
+log file /var/log/ospfd.log
+!
+!
+interface eth0
+ ip ospf hello-interval 60
+ ip ospf dead-interval 240
+!
+interface eth1
+ ip ospf hello-interval 60
+ ip ospf dead-interval 240
+!
+!
+router ospf
+ ospf router-id 192.168.1.1
+ network 192.168.0.0/16 area 1
+ ospf opaque-lsa
+  mpls-te
+  mpls-te router-address 192.168.1.1
+  mpls-te inter-as area 1
+!
+line vty
+@end group
+@end example
+
+A router information example with PCE advsertisement:
+
+@example
+@group
+!
+router ospf
+ ospf router-id 192.168.1.1
+ network 192.168.0.0/16 area 1
+ capability opaque
+  mpls-te
+  mpls-te router-address 192.168.1.1
+ router-info area 0.0.0.1
+  pce address 192.168.1.1
+  pce flag 0x80
+  pce domain as 65400
+  pce neighbor as 65500
+  pce neighbor as 65200
+  pce scope 0x80
+!
+@end group
+@end example
diff --git a/doc/quagga.texi b/doc/quagga.texi
index b4105ac..7499126 100644
--- a/doc/quagga.texi
+++ b/doc/quagga.texi
@@ -86,6 +86,7 @@ for @value{PACKAGE_STRING}. @uref{http://www.quagga.net,,Quagga} is a fork of
 * RIPng::
 * OSPFv2::
 * OSPFv3::
+* ISIS::
 * Babel::
 * BGP::
 * Configuring Quagga as a Route Server::
@@ -111,6 +112,7 @@ for @value{PACKAGE_STRING}. @uref{http://www.quagga.net,,Quagga} is a fork of
 @include ripngd.texi
 @include ospfd.texi
 @include ospf6d.texi
+@include isisd.texi
 @include babeld.texi
 @include bgpd.texi
 @include routeserver.texi
diff --git a/isisd/AUTHORS b/isisd/AUTHORS
index 05fc0a5..80b3a28 100644
--- a/isisd/AUTHORS
+++ b/isisd/AUTHORS
@@ -2,3 +2,4 @@ Sampo Saaristo   <sambo@cs.tut.fi>
 Ofer Wald        <ofersf@islands.co.il>
 Hannes Gredler   <hannes@gredler.at>
 Subbaiah Venkata <svenkata@google.com>
+Olivier Dugeon   <olivier.dugeon@orange.com>
diff --git a/isisd/Makefile.am b/isisd/Makefile.am
index 4e9b244..668f130 100644
--- a/isisd/Makefile.am
+++ b/isisd/Makefile.am
@@ -17,14 +17,14 @@ libisis_a_SOURCES = \
 	isis_adjacency.c isis_lsp.c dict.c isis_circuit.c isis_pdu.c \
 	isis_tlv.c isisd.c isis_misc.c isis_zebra.c isis_dr.c \
 	isis_flags.c isis_dynhn.c iso_checksum.c isis_csm.c isis_events.c \
-	isis_spf.c isis_route.c isis_routemap.c
+	isis_spf.c isis_te.c isis_route.c isis_routemap.c
 
 
 noinst_HEADERS = \
 	isisd.h isis_pdu.h isis_tlv.h isis_adjacency.h isis_constants.h \
 	isis_lsp.h dict.h isis_circuit.h isis_misc.h isis_network.h \
 	isis_zebra.h isis_dr.h isis_flags.h isis_dynhn.h isis_common.h \
-	iso_checksum.h isis_csm.h isis_events.h isis_spf.h isis_route.h \
+	iso_checksum.h isis_csm.h isis_events.h isis_spf.h isis_te.h isis_route.h \
 	include-netbsd/clnp.h include-netbsd/esis.h include-netbsd/iso.h
 
 isisd_SOURCES = \
diff --git a/isisd/isis_circuit.c b/isisd/isis_circuit.c
index 3d9fb47..b6d1375 100644
--- a/isisd/isis_circuit.c
+++ b/isisd/isis_circuit.c
@@ -36,6 +36,7 @@
 #include "linklist.h"
 #include "command.h"
 #include "thread.h"
+#include "vty.h"
 #include "hash.h"
 #include "prefix.h"
 #include "stream.h"
@@ -57,6 +58,9 @@
 #include "isisd/isisd.h"
 #include "isisd/isis_csm.h"
 #include "isisd/isis_events.h"
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
 
 /*
  * Prototypes.
@@ -98,6 +102,10 @@ isis_circuit_new ()
       circuit->te_metric[i] = DEFAULT_CIRCUIT_METRIC;
     }
 
+#ifdef HAVE_ISIS_TE
+  circuit->mtc = mpls_te_circuit_new();
+#endif /* HAVE_ISIS_TE */
+
   return circuit;
 }
 
@@ -195,8 +203,7 @@ circuit_scan_by_ifp (struct interface *ifp)
   return circuit_lookup_by_ifp (ifp, isis->init_circ_list);
 }
 
-static struct isis_circuit *
-isis_circuit_lookup (struct vty *vty)
+struct isis_circuit * isis_circuit_lookup (struct vty *vty)
 {
   struct interface *ifp;
   struct isis_circuit *circuit;
@@ -249,6 +256,12 @@ isis_circuit_add_addr (struct isis_circuit *circuit,
       ipv4->prefixlen = connected->address->prefixlen;
       ipv4->prefix = connected->address->u.prefix4;
       listnode_add (circuit->ip_addrs, ipv4);
+
+#ifdef HAVE_ISIS_TE
+      /* Update MPLS TE Local IP address parameter */
+      set_circuitparams_local_ipaddr (circuit->mtc, ipv4->prefix);
+#endif /* HAVE_ISIS_TE */
+
       if (circuit->area)
         lsp_regenerate_schedule (circuit->area, circuit->is_type, 0);
 
@@ -1342,7 +1355,6 @@ DEFUN (no_ipv6_router_isis,
 {
   struct interface *ifp;
   struct isis_area *area;
-  struct listnode *node;
   struct isis_circuit *circuit;
 
   ifp = (struct interface *) vty->index;
diff --git a/isisd/isis_circuit.h b/isisd/isis_circuit.h
index 7ed481d..4f1d4ea 100644
--- a/isisd/isis_circuit.h
+++ b/isisd/isis_circuit.h
@@ -106,13 +106,16 @@ struct isis_circuit
    */
   struct isis_passwd passwd;	/* Circuit rx/tx password */
   int is_type;	                /* circuit is type == level of circuit
-				 * diffrenciated from circuit type (media) */
+				 * differentiated from circuit type (media) */
   u_int32_t hello_interval[2];	/* l1HelloInterval in msecs */
   u_int16_t hello_multiplier[2];	/* l1HelloMultiplier */
   u_int16_t csnp_interval[2];	/* level-1 csnp-interval in seconds */
   u_int16_t psnp_interval[2];	/* level-1 psnp-interval in seconds */
   struct metric metrics[2];	/* l1XxxMetric */
   u_int32_t te_metric[2];
+#ifdef HAVE_ISIS_TE
+  struct mpls_te_circuit *mtc; /* Support for MPLS-TE parameters - see isis_te.[c,h] */
+#endif /* HAVE_ISIS_TE */
   int ip_router;		/* Route IP ? */
   int is_passive;		/* Is Passive ? */
   struct list *ip_addrs;	/* our IP addresses */
@@ -141,6 +144,7 @@ void isis_circuit_del (struct isis_circuit *circuit);
 struct isis_circuit *circuit_lookup_by_ifp (struct interface *ifp,
 					    struct list *list);
 struct isis_circuit *circuit_scan_by_ifp (struct interface *ifp);
+struct isis_circuit * isis_circuit_lookup (struct vty *vty);
 void isis_circuit_configure (struct isis_circuit *circuit,
 			     struct isis_area *area);
 void isis_circuit_deconfigure (struct isis_circuit *circuit,
diff --git a/isisd/isis_lsp.c b/isisd/isis_lsp.c
index f2a7923..f62c3c2 100644
--- a/isisd/isis_lsp.c
+++ b/isisd/isis_lsp.c
@@ -51,6 +51,10 @@
 #include "isisd/isis_adjacency.h"
 #include "isisd/isis_spf.h"
 
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
+
 #ifdef TOPOLOGY_GENERATE
 #include "spgrid.h"
 #endif
@@ -969,6 +973,10 @@ lsp_print_detail (struct isis_lsp *lsp, struct vty *vty, char dynhost)
       lspid_print (te_is_neigh->neigh_id, LSPid, dynhost, 0);
       vty_out (vty, "  Metric      : %-8d IS-Extended   : %s%s",
 	       GET_TE_METRIC(te_is_neigh), LSPid, VTY_NEWLINE);
+#ifdef HAVE_ISIS_TE
+      if (IS_MPLS_TE(isisMplsTE))
+        mpls_te_print_detail(vty, te_is_neigh);
+#endif /* HAVE_ISIS_TE */
     }
 
   /* TE IPv4 tlv */
@@ -1079,6 +1087,66 @@ lsp_tlv_fit (struct isis_lsp *lsp, struct list **from, struct list **to,
   return;
 }
 
+#ifdef HAVE_ISIS_TE
+/* Process IS_NEIGHBOURS TLV with TE subTLVs */
+static void
+lsp_te_tlv_fit (struct isis_lsp *lsp, struct list **from, struct list **to, int frag_thold)
+{
+  int count, size = 0;
+  struct listnode *node, *nextnode;
+  struct te_is_neigh *elem;
+
+  /* Start computing real size of TLVs */
+  for (ALL_LIST_ELEMENTS (*from, node, nextnode, elem))
+    size = size + elem->sub_tlvs_length + IS_NEIGHBOURS_LEN;
+
+  /* can we fit all ? */
+  if (!FRAG_NEEDED (lsp->pdu, frag_thold, size))
+    {
+      tlv_add_te_is_neighs (*from, lsp->pdu);
+      if (listcount (*to) != 0)
+        {
+          for (ALL_LIST_ELEMENTS (*from, node, nextnode, elem))
+            {
+              listnode_add (*to, elem);
+              list_delete_node (*from, node);
+            }
+        }
+      else
+        {
+          list_free (*to);
+          *to = *from;
+          *from = NULL;
+        }
+    }
+  else
+    {
+      /* fit all we can */
+      /* Compute remaining place in LSP PDU */
+      count = FRAG_THOLD (lsp->pdu, frag_thold) - 2 -
+        (STREAM_SIZE (lsp->pdu) - STREAM_REMAIN (lsp->pdu));
+      /* Determine size of TE SubTLVs */
+      elem = (struct te_is_neigh *)listgetdata ((struct listnode *)listhead (*from));
+      count = count - elem->sub_tlvs_length - IS_NEIGHBOURS_LEN;
+      if (count > 0)
+        {
+          while (count > 0)
+            {
+              listnode_add (*to, listgetdata ((struct listnode *)listhead (*from)));
+              listnode_delete (*from, listgetdata ((struct listnode *)listhead (*from)));
+
+              elem = (struct te_is_neigh *)listgetdata ((struct listnode *)listhead (*from));
+              count = count - elem->sub_tlvs_length - IS_NEIGHBOURS_LEN;
+            }
+
+          tlv_add_te_is_neighs (*to, lsp->pdu);
+        }
+    }
+  lsp->lsp_header->pdu_len = htons (stream_get_endp (lsp->pdu));
+  return;
+}
+#endif /* HAVE_ISIS_TE */
+
 static u_int16_t
 lsp_rem_lifetime (struct isis_area *area, int level)
 {
@@ -1433,8 +1501,20 @@ lsp_build (struct isis_lsp *lsp, struct isis_area *area)
                                ISIS_SYS_ID_LEN + 1))
                     XFREE (MTYPE_ISIS_TLV, te_is_neigh);
                   else
+#ifdef HAVE_ISIS_TE
+                    {
+                      /* Check if MPLS_TE is activate */
+                      if (IS_MPLS_TE(isisMplsTE) && IS_LINK_TE(circuit->interface))
+                        /* Add SubTLVs & Adjust real size of SubTLVs */
+                        te_is_neigh->sub_tlvs_length = add_te_subtlvs(te_is_neigh->sub_tlvs, circuit->mtc);
+                      else
+                        /* Or keep only TE metric with no SubTLVs if MPLS_TE is off */
+                        te_is_neigh->sub_tlvs_length = 0;
+                    }
+#endif /* HAVE_ISIS_TE */
                     listnode_add (tlv_data.te_is_neighs, te_is_neigh);
 		}
+
 	    }
 	  break;
 	case CIRCUIT_T_P2P:
@@ -1467,6 +1547,20 @@ lsp_build (struct isis_lsp *lsp, struct isis_area *area)
 		  memcpy (te_is_neigh->neigh_id, nei->sysid, ISIS_SYS_ID_LEN);
 		  metric = circuit->te_metric[level - 1];
 		  SET_TE_METRIC(te_is_neigh, metric);
+#ifdef HAVE_ISIS_TE
+		  /* Check if MPLS_TE is activate */
+                  if (IS_MPLS_TE(isisMplsTE) && IS_LINK_TE(circuit->interface))
+                    /* Update Local and Remote IP address for MPLS TE circuit parameters */
+                    /* NOTE sure that it is the pertinent place for that updates */
+                    /* Local IP address could be updated in isis_circuit.c - isis_circuit_add_addr() */
+                    /* But, where update remote IP address ? in isis_pdu.c - process_p2p_hello() ? */
+
+                    /* Add SubTLVs & Adjust real size of SubTLVs */
+                    te_is_neigh->sub_tlvs_length = add_te_subtlvs(te_is_neigh->sub_tlvs, circuit->mtc);
+                  else
+                    /* Or keep only TE metric with no SubTLVs if MPLS_TE is off */
+                    te_is_neigh->sub_tlvs_length = 0;
+#endif /* HAVE_ISIS_TE */
 		  listnode_add (tlv_data.te_is_neighs, te_is_neigh);
 		}
 	    }
@@ -1539,9 +1633,14 @@ lsp_build (struct isis_lsp *lsp, struct isis_area *area)
     {
       if (lsp->tlv_data.te_is_neighs == NULL)
 	lsp->tlv_data.te_is_neighs = list_new ();
+#ifndef HAVE_ISIS_TE
       lsp_tlv_fit (lsp, &tlv_data.te_is_neighs, &lsp->tlv_data.te_is_neighs,
 		   IS_NEIGHBOURS_LEN, area->lsp_frag_threshold,
 		   tlv_add_te_is_neighs);
+#else
+      lsp_te_tlv_fit (lsp, &tlv_data.te_is_neighs, &lsp->tlv_data.te_is_neighs,
+           area->lsp_frag_threshold);
+#endif /* !HAVE_ISIS_TE */
       if (tlv_data.te_is_neighs && listcount (tlv_data.te_is_neighs))
 	lsp = lsp_next_frag (LSP_FRAGMENT (lsp->lsp_header->lsp_id) + 1,
 			     lsp0, area, level);
diff --git a/isisd/isis_main.c b/isisd/isis_main.c
index 283b7ea..3acd55f 100644
--- a/isisd/isis_main.c
+++ b/isisd/isis_main.c
@@ -47,6 +47,10 @@
 #include "isisd/isis_spf.h"
 #include "isisd/isis_route.h"
 #include "isisd/isis_zebra.h"
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_tlv.h"
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
 
 /* Default configuration file name */
 #define ISISD_DEFAULT_CONFIG "isisd.conf"
@@ -334,6 +338,10 @@ main (int argc, char **argv, char **envp)
   isis_circuit_init ();
   isis_spf_cmds_init ();
 
+#ifdef HAVE_ISIS_TE
+  isis_mpls_te_init();
+#endif /* HAVE_ISIS_TE */
+
   /* create the global 'isis' instance */
   isis_new (1);
 
diff --git a/isisd/isis_pdu.c b/isisd/isis_pdu.c
index e0208fa..9312a1d 100644
--- a/isisd/isis_pdu.c
+++ b/isisd/isis_pdu.c
@@ -54,6 +54,10 @@
 #include "isisd/isis_csm.h"
 #include "isisd/isis_events.h"
 
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
+
 #define ISIS_MINIMUM_FIXED_HDR_LEN 15
 #define ISIS_MIN_PDU_LEN           13	/* partial seqnum pdu with id_len=2 */
 
@@ -601,6 +605,17 @@ process_p2p_hello (struct isis_circuit *circuit)
   if (found & TLVFLAG_IPV4_ADDR)
     tlvs_to_adj_ipv4_addrs (&tlvs, adj);
 
+#ifdef HAVE_ISIS_TE
+  /* Update MPLS TE Remote IP address parameter if possible */
+  if (IS_MPLS_TE(isisMplsTE) && circuit->mtc && IS_CIRCUIT_TE(circuit->mtc))
+    if (adj->ipv4_addrs != NULL && listcount(adj->ipv4_addrs) != 0)
+      {
+        struct in_addr *ip_addr;
+        ip_addr = (struct in_addr *)listgetdata ((struct listnode *)listhead (adj->ipv4_addrs));
+        set_circuitparams_rmt_ipaddr (circuit->mtc, *ip_addr);
+      }
+#endif /* HAVE_ISIS_TE */
+
 #ifdef HAVE_IPV6
   if (found & TLVFLAG_IPV6_ADDR)
     tlvs_to_adj_ipv6_addrs (&tlvs, adj);
diff --git a/isisd/isis_te.c b/isisd/isis_te.c
new file mode 100644
index 0000000..e722125
--- /dev/null
+++ b/isisd/isis_te.c
@@ -0,0 +1,1513 @@
+/*
+ * IS-IS Rout(e)ing protocol - isis_te.c
+ *
+ * This is an implementation of RFC5305
+ *
+ *      Copyright (C) 2014 Orange Labs
+ *      http://www.orange.com
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+#include <math.h>
+
+#include "linklist.h"
+#include "thread.h"
+#include "vty.h"
+#include "stream.h"
+#include "memory.h"
+#include "log.h"
+#include "prefix.h"
+#include "command.h"
+#include "hash.h"
+#include "if.h"
+#include "checksum.h"
+#include "md5.h"
+#include "sockunion.h"
+
+#include "isisd/dict.h"
+#include "isisd/isis_constants.h"
+#include "isisd/isis_common.h"
+#include "isisd/isis_flags.h"
+#include "isisd/isis_circuit.h"
+#include "isisd/isisd.h"
+#include "isisd/isis_tlv.h"
+#include "isisd/isis_lsp.h"
+#include "isisd/isis_pdu.h"
+#include "isisd/isis_dynhn.h"
+#include "isisd/isis_misc.h"
+#include "isisd/isis_csm.h"
+#include "isisd/isis_adjacency.h"
+#include "isisd/isis_spf.h"
+#include "isisd/isis_te.h"
+
+/* Global varial for MPLS TE management */
+struct isis_mpls_te isisMplsTE;
+
+const char *mode2text[] = { "Disable", "Area", "AS", "Emulate" };
+
+/* Utilities function to convert float to / from network */
+static float
+htonf (float val)
+{
+  u_int32_t lu1, lu2;
+  float convert;
+
+  memcpy (&lu1, &val, sizeof (u_int32_t));
+  lu2 = htonl (lu1);
+  memcpy (&convert, &lu2, sizeof (u_int32_t));
+  return convert;
+}
+
+static float
+ntohf (float val)
+{
+  u_int32_t lu1, lu2;
+  float convert;
+
+  memcpy (&lu1, &val, sizeof (u_int32_t));
+  lu2 = ntohl (lu1);
+  memcpy (&convert, &lu2, sizeof (u_int32_t));
+  return convert;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are control functions for MPLS-TE parameters management.
+ *------------------------------------------------------------------------*/
+
+/* Search MPLS TE Circuit context from Interface */
+static struct mpls_te_circuit *
+lookup_mpls_params_by_ifp (struct interface *ifp)
+{
+  struct isis_circuit *circuit;
+
+  if ((circuit = circuit_scan_by_ifp (ifp)) == NULL)
+      return NULL;
+
+  return circuit->mtc;
+}
+
+/* Create new MPLS TE Circuit context */
+struct mpls_te_circuit *
+mpls_te_circuit_new()
+{
+  struct mpls_te_circuit *mtc;
+
+  zlog_debug ("ISIS MPLS-TE: Create new MPLS TE Circuit context");
+
+  mtc = XCALLOC(MTYPE_ISIS_MPLS_TE, sizeof (struct mpls_te_circuit));
+
+  if (mtc == NULL)
+    return NULL;
+
+  mtc->status = disable;
+  mtc->type = STD_TE;
+  mtc->length = 0;
+
+  return mtc;
+
+}
+
+/* Build LINK TE SubTLV into a buffer. Pointer is increment by the size of SubTLV */
+static u_char
+build_link_te_subtlv (u_char *buf, u_char type, u_char length, void *value)
+{
+  /* Set Header: Type + Length */
+  buf[0] = type;
+  buf[1] = length;
+  buf += SUBTLV_HDR_SIZE;
+  /* Copy Value */
+  memcpy(buf, value, length);
+  buf = buf + length;
+  return (length + SUBTLV_HDR_SIZE);
+}
+
+/* Copy LINK TE parameters as TLVs into a buffer - No space verification are performed */
+/* Caller must verify before that there is enough free space in the buffer */
+u_char
+build_te_subtlvs(u_char *buf, struct isis_circuit *circuit)
+{
+  u_char size = 0, *tlvs = buf;
+  u_int32_t i, count;
+  struct interface *ifp;
+
+  zlog_debug ("ISIS MPLS-TE: Add TE Sub TLVs to buffer");
+
+  /* Sanity check */
+  if (circuit == NULL)
+    {
+      zlog_debug("ISIS MPLS-TE: Abort! No MPLS TE Circuit has been specified");
+      return 0;
+    }
+
+  ifp = circuit->interface;
+  if (ifp == NULL)
+    {
+      zlog_debug("ISIS MPLS-TE: Abort! No MPLS TE Interface has been specified");
+      return 0;
+    }
+
+  if (buf == NULL)
+    {
+      zlog_debug("ISIS MPLS-TE: Abort! No Buffer has been specified");
+      return 0;
+    }
+
+  /* Start building SubTLVs following IANA order */
+  /* TE_SUBTLV_ADMIN_GRP */
+  if (ifp->link_te.admin_grp != 0)
+      size += build_link_te_subtlv(tlvs, TE_SUBTLV_ADMIN_GRP, SUBTLV_DEF_SIZE, &ifp->link_te.admin_grp);
+
+  /* TE_SUBTLV_LOCAL_IPADDR */
+  if (listcount(circuit->ip_addrs) != 0)
+    {
+      struct prefix_ipv4 *ipv4;
+      ipv4 = listgetdata((struct listnode *)listhead(circuit->ip_addrs));
+      size += build_link_te_subtlv(tlvs, TE_SUBTLV_LOCAL_IPADDR, SUBTLV_DEF_SIZE, &ipv4->prefix);
+    }
+
+  /* TE_SUBTLV_RMTIF_IPADDR */
+  if (circuit->circ_type == CIRCUIT_T_P2P)
+    {
+      struct isis_adjacency *adj = circuit->u.p2p.neighbor;
+      if (adj->ipv4_addrs != NULL && listcount(adj->ipv4_addrs) != 0)
+        {
+          struct in_addr *ip_addr;
+          ip_addr = (struct in_addr *)listgetdata ((struct listnode *)listhead (adj->ipv4_addrs));
+          size += build_link_te_subtlv(tlvs, TE_SUBTLV_RMT_IPADDR, SUBTLV_DEF_SIZE, &ip_addr);
+        }
+    }
+
+  /* TE_SUBTLV_MAX_BW */
+  if (ifp->link_te.max_bw != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_MAX_BW, SUBTLV_DEF_SIZE, &ifp->link_te.max_bw);
+
+  /* TE_SUBTLV_MAX_RSV_BW */
+  if (ifp->link_te.max_rsv_bw != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_MAX_RSV_BW, SUBTLV_DEF_SIZE, &ifp->link_te.max_rsv_bw);
+
+  /* TE_SUBTLV_UNRSV_BW */
+  count = 0;
+  for (i = 0; i < MAX_CLASS_TYPE; i++)
+    if (ifp->link_te.unrsv_bw[i] != 0)
+      count++;
+
+  if (count != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_UNRSV_BW, TE_SUBTLV_UNRSV_SIZE, &ifp->link_te.unrsv_bw);
+
+  /* TE_SUBTLV_TE_METRIC */
+  if (ifp->link_te.te_metric != 0)
+    {
+      tlvs[0] = TE_SUBTLV_TE_METRIC;
+      tlvs[1] = TE_SUBTLV_TE_METRIC_SIZE;
+      tlvs += SUBTLV_HDR_SIZE;
+      /* Be careful, TE Metric is stored in Network Byte Order */
+      tlvs[0] = (ifp->link_te.te_metric >> 16) & 0xFF;
+      tlvs[1] = (ifp->link_te.te_metric  >> 8) & 0xFF;
+      tlvs[2] = ifp->link_te.te_metric & 0xFF;
+      tlvs += TE_SUBTLV_TE_METRIC_SIZE;
+      size += SUBTLV_HDR_SIZE + TE_SUBTLV_TE_METRIC_SIZE;
+    }
+
+  /* TE_SUBTLV_AV_DELAY */
+  if (ifp->link_te.av_delay != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_AV_DELAY, SUBTLV_DEF_SIZE, &ifp->link_te.av_delay);
+
+  /* TE_SUBTLV_MM_DELAY */
+  if ((ifp->link_te.min_delay != 0) || (ifp->link_te.max_delay != 0))
+    {
+      tlvs[0] = TE_SUBTLV_AV_DELAY;
+      tlvs[1] = TE_SUBTLV_MM_DELAY_SIZE;
+      tlvs += SUBTLV_HDR_SIZE;
+      memcpy(tlvs,&ifp->link_te.min_delay, SUBTLV_DEF_SIZE);
+      tlvs += SUBTLV_DEF_SIZE;
+      memcpy(tlvs,&ifp->link_te.max_delay, SUBTLV_DEF_SIZE);
+      tlvs += SUBTLV_DEF_SIZE;
+      size += SUBTLV_HDR_SIZE + TE_SUBTLV_MM_DELAY_SIZE;
+    }
+
+  /* TE_SUBTLV_DELAY_VAR */
+  if (ifp->link_te.delay_var != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_DELAY_VAR, SUBTLV_DEF_SIZE, &ifp->link_te.delay_var);
+
+  /* TE_SUBTLV_PKT_LOSS */
+  if (ifp->link_te.pkt_loss != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_PKT_LOSS, SUBTLV_DEF_SIZE, &ifp->link_te.pkt_loss);
+
+  /* TE_SUBTLV_RES_BW */
+  if (ifp->link_te.res_bw != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_RES_BW, SUBTLV_DEF_SIZE, &ifp->link_te.res_bw);
+
+  /* TE_SUBTLV_AVA_BW */
+  if (ifp->link_te.ava_bw != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_AVA_BW, SUBTLV_DEF_SIZE, &ifp->link_te.ava_bw);
+
+  /* TE_SUBTLV_USE_BW */
+  if (ifp->link_te.use_bw != 0)
+    size += build_link_te_subtlv(tlvs, TE_SUBTLV_USE_BW, SUBTLV_DEF_SIZE, &ifp->link_te.use_bw);
+
+  zlog_debug("ISIS MPLS-TE: Add %d bytes length SubTLVs", size);
+
+  return size;
+}
+
+/* Copy SUB TLVs parameters into a buffer - No space verification are performed */
+/* Caller must verify before that there is enough free space in the buffer */
+u_char
+add_te_subtlvs(u_char *buf, struct mpls_te_circuit *mtc)
+{
+  u_char size, *tlvs = buf;
+
+  zlog_debug ("ISIS MPLS-TE: Add TE Sub TLVs to buffer");
+
+  if (mtc == NULL)
+    {
+      zlog_debug("ISIS MPLS-TE: Abort! No MPLS TE Circuit available has been specified");
+      return 0;
+    }
+
+  /* Create buffer if not provided */
+  if (buf == NULL)
+    {
+      zlog_debug("ISIS MPLS-TE: Abort! No Buffer has been specified");
+      return 0;
+    }
+
+  /* TE_SUBTLV_ADMIN_GRP */
+  if (SUBTLV_TYPE(mtc->admin_grp) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->admin_grp.header));
+      memcpy(tlvs, &(mtc->admin_grp), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_LLRI */
+  if (SUBTLV_TYPE(mtc->llri) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->llri.header));
+      memcpy(tlvs, &(mtc->llri), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_LCLIF_IPADDR */
+  if (SUBTLV_TYPE(mtc->local_ipaddr) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->local_ipaddr.header));
+      memcpy(tlvs, &(mtc->local_ipaddr), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_RMTIF_IPADDR */
+  if (SUBTLV_TYPE(mtc->rmt_ipaddr) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->rmt_ipaddr.header));
+      memcpy(tlvs, &(mtc->rmt_ipaddr), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_MAX_BW */
+  if (SUBTLV_TYPE(mtc->max_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->max_bw.header));
+      memcpy(tlvs, &(mtc->max_bw), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_MAX_RSV_BW */
+  if (SUBTLV_TYPE(mtc->max_rsv_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->max_rsv_bw.header));
+      memcpy(tlvs, &(mtc->max_rsv_bw), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_UNRSV_BW */
+  if (SUBTLV_TYPE(mtc->unrsv_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->unrsv_bw.header));
+      memcpy(tlvs, &(mtc->unrsv_bw), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_TE_METRIC */
+  if (SUBTLV_TYPE(mtc->te_metric) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->te_metric.header));
+      memcpy(tlvs, &(mtc->te_metric), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_AV_DELAY */
+  if (SUBTLV_TYPE(mtc->av_delay) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->av_delay.header));
+      memcpy(tlvs, &(mtc->av_delay), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_MM_DELAY */
+  if (SUBTLV_TYPE(mtc->mm_delay) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->mm_delay.header));
+      memcpy(tlvs, &(mtc->mm_delay), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_DELAY_VAR */
+  if (SUBTLV_TYPE(mtc->delay_var) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->delay_var.header));
+      memcpy(tlvs, &(mtc->delay_var), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_PKT_LOSS */
+  if (SUBTLV_TYPE(mtc->pkt_loss) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->pkt_loss.header));
+      memcpy(tlvs, &(mtc->pkt_loss), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_RES_BW */
+  if (SUBTLV_TYPE(mtc->res_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->res_bw.header));
+      memcpy(tlvs, &(mtc->res_bw), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_AVA_BW */
+  if (SUBTLV_TYPE(mtc->ava_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->ava_bw.header));
+      memcpy(tlvs, &(mtc->ava_bw), size);
+      tlvs += size;
+    }
+
+  /* TE_SUBTLV_USE_BW */
+  if (SUBTLV_TYPE(mtc->use_bw) != 0)
+    {
+      size = SUBTLV_SIZE (&(mtc->use_bw.header));
+      memcpy(tlvs, &(mtc->use_bw), size);
+      tlvs += size;
+    }
+
+  zlog_debug("ISIS MPLS-TE: Add %d bytes length SubTLVs", mtc->length);
+
+  return mtc->length;
+}
+
+/* Compute total Sub-TLVs size */
+u_char
+subtlvs_len (struct mpls_te_circuit *mtc)
+{
+  int length = 0;
+
+  /* TE_SUBTLV_ADMIN_GRP */
+  if (SUBTLV_TYPE(mtc->admin_grp) != 0)
+    length += SUBTLV_SIZE (&(mtc->admin_grp.header));
+
+  /* TE_SUBTLV_LLRI */
+  if (SUBTLV_TYPE(mtc->llri) != 0)
+    length += SUBTLV_SIZE (&mtc->llri.header);
+
+  /* TE_SUBTLV_LCLIF_IPADDR */
+  if (SUBTLV_TYPE(mtc->local_ipaddr) != 0)
+    length += SUBTLV_SIZE (&mtc->local_ipaddr.header);
+
+  /* TE_SUBTLV_RMTIF_IPADDR */
+  if (SUBTLV_TYPE(mtc->rmt_ipaddr) != 0)
+    length += SUBTLV_SIZE (&mtc->rmt_ipaddr.header);
+
+  /* TE_SUBTLV_MAX_BW */
+  if (SUBTLV_TYPE(mtc->max_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->max_bw.header);
+
+  /* TE_SUBTLV_MAX_RSV_BW */
+  if (SUBTLV_TYPE(mtc->max_rsv_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->max_rsv_bw.header);
+
+  /* TE_SUBTLV_UNRSV_BW */
+  if (SUBTLV_TYPE(mtc->unrsv_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->unrsv_bw.header);
+
+  /* TE_SUBTLV_TE_METRIC */
+  if (SUBTLV_TYPE(mtc->te_metric) != 0)
+    length += SUBTLV_SIZE (&mtc->te_metric.header);
+
+  /* TE_SUBTLV_AV_DELAY */
+  if (SUBTLV_TYPE(mtc->av_delay) != 0)
+    length += SUBTLV_SIZE (&mtc->av_delay.header);
+
+  /* TE_SUBTLV_MM_DELAY */
+  if (SUBTLV_TYPE(mtc->mm_delay) != 0)
+    length += SUBTLV_SIZE (&mtc->mm_delay.header);
+
+  /* TE_SUBTLV_DELAY_VAR */
+  if (SUBTLV_TYPE(mtc->delay_var) != 0)
+    length += SUBTLV_SIZE (&mtc->delay_var.header);
+
+  /* TE_SUBTLV_PKT_LOSS */
+  if (SUBTLV_TYPE(mtc->pkt_loss) != 0)
+    length += SUBTLV_SIZE (&mtc->pkt_loss.header);
+
+  /* TE_SUBTLV_RES_BW */
+  if (SUBTLV_TYPE(mtc->res_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->res_bw.header);
+
+  /* TE_SUBTLV_AVA_BW */
+  if (SUBTLV_TYPE(mtc->ava_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->ava_bw.header);
+
+  /* TE_SUBTLV_USE_BW */
+  if (SUBTLV_TYPE(mtc->use_bw) != 0)
+    length += SUBTLV_SIZE (&mtc->use_bw.header);
+
+  /* Check that length is lower than the MAXIMUM SUBTLV size i.e. 256 */
+  if (length > MAX_SUBTLV_SIZE)
+    {
+      mtc->length = 0;
+      return 0;
+    }
+
+  mtc->length = (u_char)length;
+
+  return mtc->length;
+}
+
+/* Following are various functions to set MPLS TE parameters */
+static void
+set_circuitparams_admin_grp (struct mpls_te_circuit *mtc, u_int32_t admingrp)
+{
+  SUBTLV_TYPE(mtc->admin_grp) = TE_SUBTLV_ADMIN_GRP;
+  SUBTLV_LEN(mtc->admin_grp)  = SUBTLV_DEF_SIZE;
+  mtc->admin_grp.value        = htonl(admingrp);
+  return;
+}
+
+static void
+set_circuitparams_llri (struct mpls_te_circuit *mtc, u_int32_t local, u_int32_t remote)
+{
+  SUBTLV_TYPE(mtc->llri) = TE_SUBTLV_LLRI;
+  SUBTLV_LEN(mtc->llri)  = TE_SUBTLV_LLRI_SIZE;
+  mtc->llri.local        = htonl(local);
+  mtc->llri.remote       = htonl(remote);
+}
+
+void
+set_circuitparams_local_ipaddr (struct mpls_te_circuit *mtc, struct in_addr addr)
+{
+
+  SUBTLV_TYPE(mtc->local_ipaddr) = TE_SUBTLV_LOCAL_IPADDR;
+  SUBTLV_LEN(mtc->local_ipaddr)  = SUBTLV_DEF_SIZE;
+  mtc->local_ipaddr.value.s_addr = addr.s_addr;
+  return;
+}
+
+void
+set_circuitparams_rmt_ipaddr (struct mpls_te_circuit *mtc, struct in_addr addr)
+{
+
+  SUBTLV_TYPE(mtc->rmt_ipaddr) = TE_SUBTLV_RMT_IPADDR;
+  SUBTLV_LEN(mtc->rmt_ipaddr)  = SUBTLV_DEF_SIZE;
+  mtc->rmt_ipaddr.value.s_addr = addr.s_addr;
+  return;
+}
+
+static void
+set_circuitparams_max_bw (struct mpls_te_circuit *mtc, float fp)
+{
+  SUBTLV_TYPE(mtc->max_bw) = TE_SUBTLV_MAX_BW;
+  SUBTLV_LEN(mtc->max_bw)  = SUBTLV_DEF_SIZE;
+  mtc->max_bw.value = htonf(fp);
+  return;
+}
+
+static void
+set_circuitparams_max_rsv_bw (struct mpls_te_circuit *mtc, float fp)
+{
+  SUBTLV_TYPE(mtc->max_rsv_bw) = TE_SUBTLV_MAX_RSV_BW;
+  SUBTLV_LEN(mtc->max_rsv_bw)  = SUBTLV_DEF_SIZE;
+  mtc->max_rsv_bw.value = htonf(fp);
+  return;
+}
+
+static void
+set_circuitparams_unrsv_bw (struct mpls_te_circuit *mtc, int priority, float fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->unrsv_bw) = TE_SUBTLV_UNRSV_BW;
+  SUBTLV_LEN(mtc->unrsv_bw)  = TE_SUBTLV_UNRSV_SIZE;
+  mtc->unrsv_bw.value[priority] = htonf(fp);
+  return;
+}
+
+static void
+set_circuitparams_te_metric (struct mpls_te_circuit *mtc, u_int32_t te_metric)
+{
+  SUBTLV_TYPE(mtc->te_metric) = TE_SUBTLV_TE_METRIC;
+  SUBTLV_LEN(mtc->te_metric)  = TE_SUBTLV_TE_METRIC_SIZE;
+  mtc->te_metric.value[0] = (te_metric >> 16) & 0xFF;
+  mtc->te_metric.value[1] = (te_metric  >> 8) & 0xFF;
+  mtc->te_metric.value[2] = te_metric & 0xFF;
+  return;
+}
+
+static void
+set_circuitparams_inter_as (struct mpls_te_circuit *mtc, struct in_addr addr, u_int32_t as)
+{
+
+  /* Set the Remote ASBR IP address and then the associated AS number */
+  SUBTLV_TYPE(mtc->rip) = TE_SUBTLV_RIP;
+  SUBTLV_LEN(mtc->rip)  = SUBTLV_DEF_SIZE;
+  mtc->rip.value.s_addr = addr.s_addr;
+
+  SUBTLV_TYPE(mtc->ras) = TE_SUBTLV_RAS;
+  SUBTLV_LEN(mtc->ras)  = SUBTLV_DEF_SIZE;
+  mtc->ras.value        = htonl(as);
+}
+
+static void
+unset_circuitparams_inter_as (struct mpls_te_circuit *mtc)
+{
+
+  /* Reset the Remote ASBR IP address and then the associated AS number */
+  SUBTLV_TYPE(mtc->rip) = 0;
+  SUBTLV_LEN(mtc->rip)  = 0;
+  mtc->rip.value.s_addr = 0;
+
+  SUBTLV_TYPE(mtc->ras) = 0;
+  SUBTLV_LEN(mtc->ras)  = 0;
+  mtc->ras.value        = 0;
+}
+
+static void
+set_circuitparams_av_delay (struct mpls_te_circuit *mtc, u_int32_t delay, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->av_delay) = TE_SUBTLV_AV_DELAY;
+  SUBTLV_LEN(mtc->av_delay)  = SUBTLV_DEF_SIZE;
+  tmp = delay & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  mtc->av_delay.value = htonl(tmp);
+  return;
+}
+
+static void
+set_circuitparams_mm_delay (struct mpls_te_circuit *mtc, u_int32_t low, u_int32_t high, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->mm_delay) = TE_SUBTLV_MM_DELAY;
+  SUBTLV_LEN(mtc->mm_delay)  = TE_SUBTLV_MM_DELAY_SIZE;
+  tmp = low & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  mtc->mm_delay.low = htonl(tmp);
+  mtc->mm_delay.high = htonl(high);
+  return;
+}
+
+static void
+set_circuitparams_delay_var (struct mpls_te_circuit *mtc, u_int32_t jitter)
+{
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->delay_var) = TE_SUBTLV_DELAY_VAR;
+  SUBTLV_LEN(mtc->delay_var)  = SUBTLV_DEF_SIZE;
+  mtc->delay_var.value        = htonl(jitter & TE_EXT_MASK);
+  return;
+}
+
+static void
+set_circuitparams_pkt_loss (struct mpls_te_circuit *mtc, u_int32_t loss, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->pkt_loss) = TE_SUBTLV_PKT_LOSS;
+  SUBTLV_LEN(mtc->pkt_loss)  = SUBTLV_DEF_SIZE;
+  tmp = loss & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  mtc->pkt_loss.value = htonl(tmp);
+  return;
+}
+
+static void
+set_circuitparams_res_bw (struct mpls_te_circuit *mtc, float fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->res_bw) = TE_SUBTLV_RES_BW;
+  SUBTLV_LEN(mtc->res_bw)  = SUBTLV_DEF_SIZE;
+  mtc->res_bw.value = htonf(fp);
+  return;
+}
+
+static void
+set_circuitparams_ava_bw (struct mpls_te_circuit *mtc, float fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->ava_bw) = TE_SUBTLV_AVA_BW;
+  SUBTLV_LEN(mtc->ava_bw)  = SUBTLV_DEF_SIZE;
+  mtc->ava_bw.value = htonf(fp);
+  return;
+}
+
+static void
+set_circuitparams_use_bw (struct mpls_te_circuit *mtc, float fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  SUBTLV_TYPE(mtc->use_bw) = TE_SUBTLV_USE_BW;
+  SUBTLV_LEN(mtc->use_bw)  = SUBTLV_DEF_SIZE;
+  mtc->use_bw.value = htonf(fp);
+  return;
+}
+
+/* Main initialization / update function of the MPLS TE Circuit context */
+/* Call when interface TE Link parameters are modified */
+void
+isis_mpls_te_update (struct interface *ifp)
+{
+  int i, unset;
+  struct prefix_ipv4 *addr;
+  struct isis_circuit *circuit;
+  struct mpls_te_circuit *mtc;
+
+  zlog_debug ("ISIS MPLS-TE: Initialize circuit parameters");
+
+  /* Get circuit context from interface */
+  if ((circuit = circuit_scan_by_ifp(ifp)) == NULL)
+    return;
+
+  /* Check if MPLS TE Circuit context has not been already created */
+  if (circuit->mtc == NULL)
+    {
+      circuit->mtc = mpls_te_circuit_new();
+
+      /* Set local IP addr from ip_addr list if it exists */
+      if (circuit->ip_addrs != NULL && listcount(circuit->ip_addrs) != 0)
+        {
+          addr = (struct prefix_ipv4 *)listgetdata ((struct listnode *)listhead (circuit->ip_addrs));
+          set_circuitparams_local_ipaddr (mtc, addr->prefix);
+        }
+
+      /* Set Remote IP addr if Circuit is Point2 Point and adjacency known */
+      if (circuit->circ_type == CIRCUIT_T_P2P)
+        {
+          struct isis_adjacency *adj = circuit->u.p2p.neighbor;
+          if (adj->ipv4_addrs != NULL && listcount(adj->ipv4_addrs) != 0)
+            {
+              struct in_addr *ip_addr;
+              ip_addr = (struct in_addr *)listgetdata ((struct listnode *)listhead (adj->ipv4_addrs));
+              set_circuitparams_rmt_ipaddr (mtc, *ip_addr);
+            }
+        }
+    }
+
+  mtc = circuit->mtc;
+
+  /* Fulfil MTC TLV from ifp TE Link parameters */
+  if (IS_LINK_TE(ifp))
+    {
+      mtc->status = enable;
+      /* STD_TE metrics */
+      if (ifp->link_te.admin_grp != 0)
+        set_circuitparams_admin_grp (mtc, ifp->link_te.admin_grp);
+      else
+        SUBTLV_TYPE(mtc->admin_grp) = 0;
+
+      if (ifp->link_te.max_bw != 0)
+        set_circuitparams_max_bw (mtc, ifp->link_te.max_bw);
+      else
+        SUBTLV_TYPE(mtc->max_bw) = 0;
+
+      if (ifp->link_te.max_rsv_bw != 0)
+        set_circuitparams_max_rsv_bw (mtc, ifp->link_te.max_rsv_bw);
+      else
+        SUBTLV_TYPE(mtc->max_rsv_bw) = 0;
+
+      unset = 0;
+      for (i = 0; i < MAX_CLASS_TYPE; i++)
+        {
+          if (ifp->link_te.unrsv_bw[i] != 0)
+            set_circuitparams_unrsv_bw (mtc, i, ifp->link_te.unrsv_bw[i]);
+          else
+            unset++;
+        }
+      /* Reset UNRSV_BW SubTLV if all Class Type value equal 0 */
+      if (unset == MAX_CLASS_TYPE)
+        SUBTLV_TYPE(mtc->unrsv_bw) = 0;
+
+      if (ifp->link_te.te_metric != 0)
+        set_circuitparams_te_metric(mtc, ifp->link_te.te_metric);
+      else
+        SUBTLV_TYPE(mtc->te_metric) = 0;
+
+      /* TE metric Extensions */
+      if (ifp->link_te.av_delay != 0)
+        set_circuitparams_av_delay(mtc, ifp->link_te.av_delay, 0);
+      else
+        SUBTLV_TYPE(mtc->av_delay) = 0;
+
+      if ((ifp->link_te.min_delay != 0) || (ifp->link_te.max_delay != 0))
+        set_circuitparams_mm_delay(mtc, ifp->link_te.min_delay, ifp->link_te.max_delay, 0);
+      else
+        SUBTLV_TYPE(mtc->mm_delay) = 0;
+
+      if (ifp->link_te.delay_var != 0)
+        set_circuitparams_delay_var(mtc, ifp->link_te.delay_var);
+      else
+        SUBTLV_TYPE(mtc->delay_var) = 0;
+
+      if (ifp->link_te.pkt_loss != 0)
+        set_circuitparams_pkt_loss(mtc, ifp->link_te.pkt_loss, 0);
+      else
+        SUBTLV_TYPE(mtc->pkt_loss) = 0;
+
+      if (ifp->link_te.res_bw != 0)
+        set_circuitparams_res_bw(mtc, ifp->link_te.res_bw);
+      else
+        SUBTLV_TYPE(mtc->res_bw) = 0;
+
+      if (ifp->link_te.ava_bw != 0)
+        set_circuitparams_ava_bw(mtc, ifp->link_te.ava_bw);
+      else
+        SUBTLV_TYPE(mtc->ava_bw) = 0;
+
+      if (ifp->link_te.use_bw != 0)
+        set_circuitparams_use_bw(mtc, ifp->link_te.use_bw);
+      else
+        SUBTLV_TYPE(mtc->use_bw) = 0;
+
+      /* INTER_AS */
+      if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+        set_circuitparams_inter_as(mtc, ifp->link_te.rmt_ip, ifp->link_te.rmt_as);
+      else
+        /* reset inter-as TE params */
+        unset_circuitparams_inter_as (mtc);
+
+      /* Compute total length of SUB TLVs */
+      mtc->length = subtlvs_len(mtc);
+
+    }
+  else
+    mtc->status = disable;
+
+  /* Finally Update LSP */
+  if (IS_MPLS_TE(isisMplsTE) && circuit->area)
+       lsp_regenerate_schedule (circuit->area, circuit->is_type, 0);
+
+  return;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are vty session control functions.
+ *------------------------------------------------------------------------*/
+
+static u_char
+show_vty_subtlv_admin_grp (struct vty *vty, struct te_subtlv_admin_grp *tlv)
+{
+
+  if (vty != NULL)
+    vty_out (vty, "    Administrative Group: 0x%x%s",
+             (u_int32_t) ntohl (tlv->value), VTY_NEWLINE);
+  else
+    zlog_debug ("      Administrative Group: 0x%x",
+                (u_int32_t) ntohl (tlv->value));
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_llri (struct vty *vty, struct te_subtlv_llri *tlv)
+{
+  if (vty != NULL)
+    {
+      vty_out (vty, "    Link Local  ID: %d%s", (u_int32_t) ntohl (tlv->local),
+               VTY_NEWLINE);
+      vty_out (vty, "    Link Remote ID: %d%s", (u_int32_t) ntohl (tlv->remote),
+               VTY_NEWLINE);
+    }
+  else
+    {
+      zlog_debug ("      Link Local  ID: %d", (u_int32_t) ntohl (tlv->local));
+      zlog_debug ("      Link Remote ID: %d", (u_int32_t) ntohl (tlv->remote));
+    }
+
+  return (SUBTLV_HDR_SIZE + TE_SUBTLV_LLRI_SIZE);
+}
+
+static u_char
+show_vty_subtlv_local_ipaddr (struct vty *vty, struct te_subtlv_local_ipaddr *tlv)
+{
+  if (vty != NULL)
+    vty_out (vty, "    Local Interface IP Address(es): %s%s", inet_ntoa (tlv->value), VTY_NEWLINE);
+  else
+    zlog_debug ("      Local Interface IP Address(es): %s", inet_ntoa (tlv->value));
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_rmt_ipaddr (struct vty *vty, struct te_subtlv_rmt_ipaddr *tlv)
+{
+  if (vty != NULL)
+    vty_out (vty, "    Remote Interface IP Address(es): %s%s", inet_ntoa (tlv->value), VTY_NEWLINE);
+  else
+    zlog_debug ("      Remote Interface IP Address(es): %s", inet_ntoa (tlv->value));
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_max_bw (struct vty *vty, struct te_subtlv_max_bw *tlv)
+{
+  float fval;
+
+  fval = ntohf (tlv->value);
+
+  if (vty != NULL)
+    vty_out (vty, "    Maximum Bandwidth: %g (Bytes/sec)%s", fval, VTY_NEWLINE);
+  else
+    zlog_debug ("      Maximum Bandwidth: %g (Bytes/sec)", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_max_rsv_bw (struct vty *vty, struct te_subtlv_max_rsv_bw *tlv)
+{
+  float fval;
+
+  fval = ntohf (tlv->value);
+
+  if (vty != NULL)
+    vty_out (vty, "    Maximum Reservable Bandwidth: %g (Bytes/sec)%s", fval,
+             VTY_NEWLINE);
+  else
+    zlog_debug ("      Maximum Reservable Bandwidth: %g (Bytes/sec)", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_unrsv_bw (struct vty *vty, struct te_subtlv_unrsv_bw *tlv)
+{
+  float fval1, fval2;
+  int i;
+
+  if (vty != NULL)
+    vty_out (vty, "    Unreserved Bandwidth:%s",VTY_NEWLINE);
+  else
+    zlog_debug ("      Unreserved Bandwidth:");
+
+  for (i = 0; i < MAX_CLASS_TYPE; i+=2)
+    {
+      fval1 = ntohf (tlv->value[i]);
+      fval2 = ntohf (tlv->value[i+1]);
+      if (vty != NULL)
+        vty_out (vty, "      [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)%s", i, fval1, i+1, fval2, VTY_NEWLINE);
+      else
+        zlog_debug ("        [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)", i, fval1, i+1, fval2);
+    }
+
+  return (SUBTLV_HDR_SIZE + TE_SUBTLV_UNRSV_SIZE);
+}
+
+static u_char
+show_vty_subtlv_te_metric (struct vty *vty, struct te_subtlv_te_metric *tlv)
+{
+  u_int32_t te_metric;
+
+  te_metric = tlv->value[2] | tlv->value[1] << 8 | tlv->value[0] << 16;
+  if (vty != NULL)
+    vty_out (vty, "    Traffic Engineering Metric: %u%s", te_metric, VTY_NEWLINE);
+  else
+    zlog_debug ("      Traffic Engineering Metric: %u", te_metric);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_ras (struct vty *vty, struct te_subtlv_ras *tlv)
+{
+  if (vty != NULL)
+    vty_out (vty, "    Inter-AS TE Remote AS number: %u%s", ntohl (tlv->value), VTY_NEWLINE);
+  else
+    zlog_debug ("      Inter-AS TE Remote AS number: %u", ntohl (tlv->value));
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_rip (struct vty *vty, struct te_subtlv_rip *tlv)
+{
+  if (vty != NULL)
+    vty_out (vty, "    Inter-AS TE Remote ASBR IP address: %s%s", inet_ntoa (tlv->value), VTY_NEWLINE);
+  else
+    zlog_debug ("      Inter-AS TE Remote ASBR IP address: %s", inet_ntoa (tlv->value));
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_av_delay (struct vty *vty, struct te_subtlv_av_delay *tlv)
+{
+  u_int32_t delay;
+  u_int32_t A;
+
+  delay = (u_int32_t) ntohl (tlv->value) & TE_EXT_MASK;
+  A = (u_int32_t) ntohl (tlv->value) & TE_EXT_ANORMAL;
+
+  if (vty != NULL)
+    vty_out (vty, "    %s Average Link Delay: %d (micro-sec)%s", A ? "Anomalous" : "Normal", delay, VTY_NEWLINE);
+  else
+    zlog_debug ("      %s Average Link Delay: %d (micro-sec)", A ? "Anomalous" : "Normal", delay);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_mm_delay (struct vty *vty, struct te_subtlv_mm_delay *tlv)
+{
+  u_int32_t low, high;
+  u_int32_t A;
+
+  low = (u_int32_t) ntohl (tlv->low) & TE_EXT_MASK;
+  A = (u_int32_t) ntohl (tlv->low) & TE_EXT_ANORMAL;
+  high = (u_int32_t) ntohl (tlv->high) & TE_EXT_MASK;
+
+  if (vty != NULL)
+    vty_out (vty, "    %s Min/Max Link Delay: %d / %d (micro-sec)%s", A ? "Anomalous" : "Normal", low, high, VTY_NEWLINE);
+  else
+    zlog_debug ("      %s Min/Max Link Delay: %d / %d (micro-sec)", A ? "Anomalous" : "Normal", low, high);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_delay_var (struct vty *vty, struct te_subtlv_delay_var *tlv)
+{
+  u_int32_t jitter;
+
+  jitter = (u_int32_t) ntohl (tlv->value) & TE_EXT_MASK;
+
+  if (vty != NULL)
+    vty_out (vty, "    Delay Variation: %d (micro-sec)%s", jitter, VTY_NEWLINE);
+  else
+    zlog_debug ("      Delay Variation: %d (micro-sec)", jitter);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_pkt_loss (struct vty *vty, struct te_subtlv_pkt_loss *tlv)
+{
+  u_int32_t loss;
+  u_int32_t A;
+  float fval;
+
+  loss = (u_int32_t) ntohl (tlv->value) & TE_EXT_MASK;
+  fval = (float) (loss * LOSS_PRECISION);
+  A = (u_int32_t) ntohl (tlv->value) & TE_EXT_ANORMAL;
+
+  if (vty != NULL)
+    vty_out (vty, "    %s Link Packet Loss: %g (%%)%s", A ? "Anomalous" : "Normal", fval, VTY_NEWLINE);
+  else
+    zlog_debug ("      %s Link Packet Loss: %g (%%)", A ? "Anomalous" : "Normal", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_res_bw (struct vty *vty, struct te_subtlv_res_bw *tlv)
+{
+  float fval;
+
+  fval = ntohf(tlv->value);
+
+  if (vty != NULL)
+    vty_out (vty, "    Unidirectional Residual Bandwidth: %g (Bytes/sec)%s", fval, VTY_NEWLINE);
+  else
+    zlog_debug ("      Unidirectional Residual Bandwidth: %g (Bytes/sec)", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_ava_bw (struct vty *vty, struct te_subtlv_ava_bw *tlv)
+{
+  float fval;
+
+  fval = ntohf (tlv->value);
+
+  if (vty != NULL)
+    vty_out (vty, "    Unidirectional Available Bandwidth: %g (Bytes/sec)%s", fval, VTY_NEWLINE);
+  else
+    zlog_debug ("      Unidirectional Available Bandwidth: %g (Bytes/sec)", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_subtlv_use_bw (struct vty *vty, struct te_subtlv_use_bw *tlv)
+{
+  float fval;
+
+  fval = ntohf (tlv->value);
+
+  if (vty != NULL)
+    vty_out (vty, "    Unidirectional Utilized Bandwidth: %g (Bytes/sec)%s", fval, VTY_NEWLINE);
+  else
+    zlog_debug ("      Unidirectional Utilized Bandwidth: %g (Bytes/sec)", fval);
+
+  return (SUBTLV_HDR_SIZE + SUBTLV_DEF_SIZE);
+}
+
+static u_char
+show_vty_unknown_tlv (struct vty *vty, struct subtlv_header *tlvh)
+{
+  int i, rtn = 1;
+  u_char *v = (u_char *)tlvh;
+
+  if (vty != NULL)
+    {
+      if (tlvh->length != 0)
+        {
+          vty_out (vty, "    Unknown TLV: [type(%#.2x), length(%#.2x)]%s",
+              tlvh->type, tlvh->length, VTY_NEWLINE);
+          vty_out(vty, "       Dump: [00]");
+          rtn = 1;          /* initialize end of line counter */
+          for (i = 0; i < tlvh->length; i++)
+            {
+              vty_out (vty, " %#.2x", v[i]);
+              if (rtn == 8)
+                {
+                  vty_out (vty, "%s             [%.2x]", VTY_NEWLINE, i + 1);
+                  rtn = 1;
+                }
+              else
+                rtn++;
+            }
+          vty_out (vty, "%s", VTY_NEWLINE);
+        }
+      else
+        vty_out (vty, "    Unknown TLV: [type(%#.2x), length(%#.2x)]%s",
+            tlvh->type, tlvh->length, VTY_NEWLINE);
+    }
+  else
+    {
+      zlog_debug ("      Unknown TLV: [type(%#.2x), length(%#.2x)]",
+          tlvh->type, tlvh->length);
+    }
+
+  return SUBTLV_SIZE(tlvh);
+}
+
+/* Main Show function */
+void
+mpls_te_print_detail(struct vty *vty, struct te_is_neigh *te)
+{
+  struct subtlv_header *tlvh, *next;
+  u_int16_t sum = 0;
+
+  zlog_debug ("ISIS MPLS-TE: Show database TE detail");
+
+  if (te->sub_tlvs == NULL)
+    return;
+
+  tlvh = (struct subtlv_header *)te->sub_tlvs;
+
+  for (; sum < te->sub_tlvs_length; tlvh = (next ? next : SUBTLV_HDR_NEXT (tlvh)))
+    {
+      next = NULL;
+
+      switch (tlvh->type)
+      {
+      case TE_SUBTLV_ADMIN_GRP:
+        sum += show_vty_subtlv_admin_grp (vty, (struct te_subtlv_admin_grp *)tlvh);
+        break;
+      case TE_SUBTLV_LLRI:
+        sum += show_vty_subtlv_llri (vty, (struct te_subtlv_llri *)tlvh);
+        break;
+      case TE_SUBTLV_LOCAL_IPADDR:
+        sum += show_vty_subtlv_local_ipaddr (vty, (struct te_subtlv_local_ipaddr *)tlvh);
+        break;
+      case TE_SUBTLV_RMT_IPADDR:
+        sum += show_vty_subtlv_rmt_ipaddr (vty, (struct te_subtlv_rmt_ipaddr *)tlvh);
+        break;
+      case TE_SUBTLV_MAX_BW:
+        sum += show_vty_subtlv_max_bw (vty, (struct te_subtlv_max_bw *)tlvh);
+        break;
+      case TE_SUBTLV_MAX_RSV_BW:
+        sum += show_vty_subtlv_max_rsv_bw (vty, (struct te_subtlv_max_rsv_bw *)tlvh);
+        break;
+      case TE_SUBTLV_UNRSV_BW:
+        sum += show_vty_subtlv_unrsv_bw (vty, (struct te_subtlv_unrsv_bw *)tlvh);
+        break;
+      case TE_SUBTLV_TE_METRIC:
+        sum += show_vty_subtlv_te_metric (vty, (struct te_subtlv_te_metric *)tlvh);
+        break;
+      case TE_SUBTLV_RAS:
+        sum += show_vty_subtlv_ras (vty, (struct te_subtlv_ras *)tlvh);
+        break;
+      case TE_SUBTLV_RIP:
+        sum += show_vty_subtlv_rip (vty, (struct te_subtlv_rip *)tlvh);
+        break;
+      case TE_SUBTLV_AV_DELAY:
+        sum += show_vty_subtlv_av_delay (vty, (struct te_subtlv_av_delay *)tlvh);
+        break;
+      case TE_SUBTLV_MM_DELAY:
+        sum += show_vty_subtlv_mm_delay (vty, (struct te_subtlv_mm_delay *)tlvh);
+        break;
+      case TE_SUBTLV_DELAY_VAR:
+        sum += show_vty_subtlv_delay_var (vty, (struct te_subtlv_delay_var *)tlvh);
+        break;
+      case TE_SUBTLV_PKT_LOSS:
+        sum += show_vty_subtlv_pkt_loss (vty, (struct te_subtlv_pkt_loss *)tlvh);
+        break;
+      case TE_SUBTLV_RES_BW:
+        sum += show_vty_subtlv_res_bw (vty, (struct te_subtlv_res_bw *)tlvh);
+        break;
+      case TE_SUBTLV_AVA_BW:
+        sum += show_vty_subtlv_ava_bw (vty, (struct te_subtlv_ava_bw *)tlvh);
+        break;
+      case TE_SUBTLV_USE_BW:
+        sum += show_vty_subtlv_use_bw (vty, (struct te_subtlv_use_bw *)tlvh);
+        break;
+      default:
+        sum += show_vty_unknown_tlv (vty, tlvh);
+        break;
+      }
+    }
+  return;
+}
+
+/* Specific MPLS TE router parameters write function */
+void
+isis_mpls_te_config_write_router (struct vty *vty)
+{
+
+  zlog_debug ("ISIS MPLS-TE: Write ISIS router configuration");
+
+  if (IS_MPLS_TE(isisMplsTE))
+    {
+      vty_out (vty, "  mpls-te on%s", VTY_NEWLINE);
+      vty_out (vty, "  mpls-te router-address %s%s",
+               inet_ntoa (isisMplsTE.router_id), VTY_NEWLINE);
+    }
+
+  return;
+}
+
+
+/*------------------------------------------------------------------------*
+ * Followings are vty command functions.
+ *------------------------------------------------------------------------*/
+
+DEFUN (isis_mpls_te_on,
+       isis_mpls_te_on_cmd,
+       "mpls-te on",
+       MPLS_TE_STR
+       "Enable MPLS-TE functionality\n")
+{
+  struct listnode *node;
+  struct isis_circuit *circuit;
+
+  if (IS_MPLS_TE(isisMplsTE))
+    return CMD_SUCCESS;
+
+  if (IS_DEBUG_ISIS(DEBUG_TE))
+    zlog_debug ("ISIS MPLS-TE: OFF -> ON");
+
+  isisMplsTE.status = enable;
+
+  /*
+   * Following code is intended to handle two cases;
+   *
+   * 1) MPLS-TE was disabled at startup time, but now become enabled.
+   * In this case, we must enable MPLS-TE Circuit regarding interface MPLS_TE flag
+   * 2) MPLS-TE was once enabled then disabled, and now enabled again.
+   */
+  for (ALL_LIST_ELEMENTS_RO (isisMplsTE.cir_list, node, circuit))
+    {
+      if (circuit->mtc == NULL || IS_FLOOD_AS (circuit->mtc->type))
+        continue;
+
+      if ((circuit->mtc->status == disable) && IS_LINK_TE(circuit->interface))
+        circuit->mtc->status = enable;
+      else
+        continue;
+
+      /* Reoriginate STD_TE & GMPLS circuits */
+      if (circuit->area)
+        lsp_regenerate_schedule (circuit->area, circuit->is_type, 0);
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_isis_mpls_te_on,
+       no_isis_mpls_te_on_cmd,
+       "no mpls-te",
+       NO_STR
+       "Disable the MPLS-TE functionality\n")
+{
+  struct listnode *node;
+  struct isis_circuit *circuit;
+
+  if (isisMplsTE.status == disable)
+    return CMD_SUCCESS;
+
+  if (IS_DEBUG_ISIS(DEBUG_TE))
+    zlog_debug ("ISIS MPLS-TE: ON -> OFF");
+
+  isisMplsTE.status = disable;
+
+  /* Flush LSP if circuit engage */
+  for (ALL_LIST_ELEMENTS_RO (isisMplsTE.cir_list, node, circuit))
+    {
+      if (circuit->mtc == NULL || (circuit->mtc->status == disable))
+        continue;
+
+      /* disable MPLS_TE Circuit */
+      circuit->mtc->status = disable;
+
+      /* Re-originate circuit without STD_TE & GMPLS parameters */
+      if (circuit->area)
+        lsp_regenerate_schedule (circuit->area, circuit->is_type, 0);
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (isis_mpls_te_router_addr,
+       isis_mpls_te_router_addr_cmd,
+       "mpls-te router-address A.B.C.D",
+       MPLS_TE_STR
+       "Stable IP address of the advertising router\n"
+       "MPLS-TE router address in IPv4 address format\n")
+{
+  struct in_addr value;
+  struct listnode *node;
+  struct isis_area *area;
+
+  if (! inet_aton (argv[0], &value))
+    {
+      vty_out (vty, "Please specify Router-Addr by A.B.C.D%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  isisMplsTE.router_id.s_addr = value.s_addr;
+
+  if (isisMplsTE.status == disable)
+    return CMD_SUCCESS;
+
+  /* Update main Router ID in isis global structure */
+  isis->router_id = value.s_addr;
+  /* And re-schedule LSP update */
+  for (ALL_LIST_ELEMENTS_RO (isis->area_list, node, area))
+    if (listcount (area->area_addrs) > 0)
+      lsp_regenerate_schedule (area, area->is_type, 0);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (isis_mpls_te_inter_as,
+       isis_mpls_te_inter_as_cmd,
+       "mpls-te inter-as (level-1|level-1-2|level-2-only)",
+       MPLS_TE_STR
+       "Configure MPLS-TE Inter-AS support\n"
+       "AREA native mode self originate INTER-AS LSP with L1 only flooding scope)\n"
+       "AREA native mode self originate INTER-AS LSP with L1 and L2 flooding scope)\n"
+       "AS native mode self originate INTER-AS LSP with L2 only flooding scope\n")
+{
+  vty_out (vty, "Not yet supported%s", VTY_NEWLINE);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_isis_mpls_te_inter_as,
+       no_isis_mpls_te_inter_as_cmd,
+       "no mpls-te inter-as",
+       NO_STR
+       "Disable the MPLS-TE functionality\n"
+       "Disable MPLS-TE Inter-AS support\n")
+{
+
+  vty_out (vty, "Not yet supported%s", VTY_NEWLINE);
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_isis_mpls_te_router,
+       show_isis_mpls_te_router_cmd,
+       "show isis mpls-te router",
+       SHOW_STR
+       ISIS_STR
+       MPLS_TE_STR
+       "Router information\n")
+{
+  if (IS_MPLS_TE(isisMplsTE))
+    {
+      vty_out (vty, "--- MPLS-TE router parameters ---%s", VTY_NEWLINE);
+
+      if (vty != NULL)
+        {
+          if (ntohs (isisMplsTE.router_id.s_addr) != 0)
+            vty_out (vty, "  Router-Address: %s%s", inet_ntoa (isisMplsTE.router_id), VTY_NEWLINE);
+          else
+            vty_out (vty, "  N/A%s", VTY_NEWLINE);
+        }
+    }
+  else
+    vty_out (vty, "  MPLS-TE is disable on this router%s", VTY_NEWLINE);
+
+  return CMD_SUCCESS;
+}
+
+static void
+show_mpls_te_sub (struct vty *vty, struct interface *ifp)
+{
+  struct mpls_te_circuit *mtc;
+
+  if ((IS_MPLS_TE(isisMplsTE))
+      &&  ((mtc =lookup_mpls_params_by_ifp (ifp)) != NULL))
+    {
+      /* Continue only if interface is not passive or support Inter-AS TEv2 */
+      if (mtc->status != enable)
+        {
+          if (IS_INTER_AS(mtc->type))
+            {
+              vty_out (vty, "-- Inter-AS TEv2 link parameters for %s --%s",
+                       ifp->name, VTY_NEWLINE);
+            }
+          else
+            {
+              /* MPLS-TE is not activate on this interface */
+              /* or this interface is passive and Inter-AS TEv2 is not activate */
+              vty_out (vty, "  %s: MPLS-TE is disabled on this interface%s",
+                       ifp->name, VTY_NEWLINE);
+              return;
+            }
+        }
+      else
+        {
+          vty_out (vty, "-- MPLS-TE link parameters for %s --%s",
+                   ifp->name, VTY_NEWLINE);
+        }
+
+      show_vty_subtlv_admin_grp (vty, &mtc->admin_grp);
+
+      if (SUBTLV_TYPE(mtc->local_ipaddr) != 0)
+        show_vty_subtlv_local_ipaddr (vty, &mtc->local_ipaddr);
+      if (SUBTLV_TYPE(mtc->rmt_ipaddr) != 0)
+        show_vty_subtlv_rmt_ipaddr (vty, &mtc->rmt_ipaddr);
+
+      show_vty_subtlv_max_bw (vty, &mtc->max_bw);
+      show_vty_subtlv_max_rsv_bw (vty, &mtc->max_rsv_bw);
+      show_vty_subtlv_unrsv_bw (vty, &mtc->unrsv_bw);
+      show_vty_subtlv_te_metric (vty, &mtc->te_metric);
+
+      if (IS_INTER_AS(mtc->type))
+        {
+          if (SUBTLV_TYPE(mtc->ras) != 0)
+            show_vty_subtlv_ras (vty, &mtc->ras);
+          if (SUBTLV_TYPE(mtc->rip) != 0)
+            show_vty_subtlv_rip (vty, &mtc->rip);
+        }
+
+      show_vty_subtlv_av_delay (vty, &mtc->av_delay);
+      show_vty_subtlv_mm_delay (vty, &mtc->mm_delay);
+      show_vty_subtlv_delay_var (vty, &mtc->delay_var);
+      show_vty_subtlv_pkt_loss (vty, &mtc->pkt_loss);
+      show_vty_subtlv_res_bw (vty, &mtc->res_bw);
+      show_vty_subtlv_ava_bw (vty, &mtc->ava_bw);
+      show_vty_subtlv_use_bw (vty, &mtc->use_bw);
+      vty_out (vty, "---------------%s%s", VTY_NEWLINE, VTY_NEWLINE);
+    }
+  else
+    {
+      vty_out (vty, "  %s: MPLS-TE is disabled on this interface%s",
+               ifp->name, VTY_NEWLINE);
+    }
+
+  return;
+}
+
+DEFUN (show_isis_mpls_te_interface,
+       show_isis_mpls_te_interface_cmd,
+       "show isis mpls-te interface [INTERFACE]",
+       SHOW_STR
+       ISIS_STR
+       MPLS_TE_STR
+       "Interface information\n"
+       "Interface name\n")
+{
+  struct interface *ifp;
+  struct listnode *node;
+
+  /* Show All Interfaces. */
+  if (argc == 0)
+    {
+      for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
+        show_mpls_te_sub (vty, ifp);
+    }
+  /* Interface name is specified. */
+  else
+    {
+      if ((ifp = if_lookup_by_name (argv[0])) == NULL)
+        vty_out (vty, "No such interface name%s", VTY_NEWLINE);
+      else
+        show_mpls_te_sub (vty, ifp);
+    }
+
+  return CMD_SUCCESS;
+}
+
+/* Initialize MPLS_TE */
+void
+isis_mpls_te_init (void)
+{
+
+  zlog_debug("ISIS MPLS-TE: Initialize");
+
+  /* Initialize MPLS_TE structure */
+  isisMplsTE.status = disable;
+  isisMplsTE.level = 0;
+  isisMplsTE.inter_as = off;
+  isisMplsTE.interas_areaid.s_addr = 0;
+  isisMplsTE.cir_list = list_new();
+  isisMplsTE.router_id.s_addr = 0;
+  
+  /* Register new VTY commands */
+  install_element (VIEW_NODE, &show_isis_mpls_te_router_cmd);
+  install_element (VIEW_NODE, &show_isis_mpls_te_interface_cmd);
+  install_element (ENABLE_NODE, &show_isis_mpls_te_router_cmd);
+  install_element (ENABLE_NODE, &show_isis_mpls_te_interface_cmd);
+
+  install_element (ISIS_NODE, &isis_mpls_te_on_cmd);
+  install_element (ISIS_NODE, &no_isis_mpls_te_on_cmd);
+  install_element (ISIS_NODE, &isis_mpls_te_router_addr_cmd);
+  install_element (ISIS_NODE, &isis_mpls_te_inter_as_cmd);
+  install_element (ISIS_NODE, &no_isis_mpls_te_inter_as_cmd);
+
+  return;
+}
+
diff --git a/isisd/isis_te.h b/isisd/isis_te.h
new file mode 100644
index 0000000..ad2f091
--- /dev/null
+++ b/isisd/isis_te.h
@@ -0,0 +1,330 @@
+/*
+ * IS-IS Rout(e)ing protocol - isis_te.c
+ *
+ * This is an implementation of RFC5305, RFC 5307 and draft-ietf-isis-te-metric-extensions-03
+ *
+ *      Copyright (C) 2014 Orange Labs
+ *      http://www.orange.com
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _ZEBRA_ISIS_MPLS_TE_H
+#define _ZEBRA_ISIS_MPLS_TE_H
+
+/*
+ * Traffic Engineering information are transport through LSP:
+ *  - Extended IS Reachability          TLV = 22
+ *  - Traffic Engineering Router ID     TLV = 134
+ *  - Extended IP Reachability          TLV = 135
+ *  - Inter-AS Reachability Information TLV = 141
+ *
+ *  and support following sub-TLV:
+ *
+ * Name                           Value   Status
+ * _________________________________________________
+ * Administartive group (color)       3   RFC5305
+ * Link Local/Remote Identifiers      4   RFC5307
+ * IPv4 interface address             6   RFC5305
+ * IPv4 neighbor address              8   RFC5305
+ * Maximum link bandwidth             9   RFC5305
+ * Reservable link bandwidth         10   RFC5305
+ * Unreserved bandwidth              11   RFC5305
+ * TE Default metric                 18   RFC5305
+ * Link Protection Type              20   RFC5307
+ * Interface Switching Capability    21   RFC5307
+ * Remote AS number                  24   RFC5316
+ * IPv4 Remote ASBR identifier       25   RFC5316
+ *
+ */
+
+/* NOTE: RFC5316 is not yet supported in this version */
+
+/* Following define the type of TE link regarding the various RFC */
+#define STD_TE			0x01
+#define GMPLS			0x02
+#define INTER_AS 		0x04
+#define FLOOD_L1		0x10
+#define FLOOD_L2		0x20
+#define FLOOD_AS                0x40
+#define EMULATED		0x80
+
+#define IS_STD_TE(x) 		(x & STD_TE)
+#define IS_INTER_AS(x) 		(x & INTER_AS)
+#define IS_EMULATED(x)		(x & EMULATED)
+#define IS_FLOOD_L1(x)		(x & FLOOD_L1)
+#define IS_FLOOD_L2(x)		(x & FLOOD_L2)
+#define IS_FLOOD_AS(x)          (x & FLOOD_AS)
+#define IS_INTER_AS_EMU(x) 	(x & INTER_AS & EMULATED)
+#define IS_INTER_AS_AS(x)	(x & INTER_AS & FLOOD_AS)
+
+/*
+ * Following section defines subTLV (tag, length, value) structures,
+ * used for Traffic Engineering.
+ */
+struct subtlv_header
+{
+  u_char	type;		/* sub_TLV_XXX type (see above) */
+  u_char	length;		/* Value portion only, in byte */
+};
+
+#define SUBTLV_HDR_SIZE        2  /* (sizeof (struct sub_tlv_header)) */
+
+#define SUBTLV_SIZE(stlvh) 	(SUBTLV_HDR_SIZE + (stlvh)->length)
+
+#define SUBTLV_HDR_TOP(lsph) 	(struct subtlv_header *)((char *)(lsph) + ISIS_LSP_HEADER_SIZE)
+
+#define SUBTLV_HDR_NEXT(stlvh) 	(struct subtlv_header *)((char *)(stlvh) + SUBTLV_SIZE(stlvh))
+
+#define SUBTLV_TYPE(stlvh)     stlvh.header.type
+#define SUBTLV_LEN(stlvh)      stlvh.header.length
+#define SUBTLV_VAL(stlvh)      stlvh.value
+#define SUBTLV_DATA(stlvh)     stlvh + SUBTLV_HDR_SIZE
+
+#define SUBTLV_DEF_SIZE		4
+
+/* Link Sub-TLV: Resource Class/Color - RFC 5305 */
+#define TE_SUBTLV_ADMIN_GRP	3
+struct te_subtlv_admin_grp
+{
+  struct subtlv_header header;		/* Value length is 4 octets. */
+  u_int32_t		value;		/* Admin. group membership. */
+} __attribute__((__packed__));
+
+/* Link Local/Remote Identifiers - RFC 5307 */
+#define TE_SUBTLV_LLRI		4
+#define TE_SUBTLV_LLRI_SIZE	8
+struct te_subtlv_llri
+{
+  struct subtlv_header header;		/* Value length is 8 octets. */
+  u_int32_t		local;		/* Link Local Identifier */
+  u_int32_t		remote;	/* Link Remote Identifier */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Local Interface IP Address - RFC 5305 */
+#define TE_SUBTLV_LOCAL_IPADDR	6
+struct te_subtlv_local_ipaddr
+{
+  struct subtlv_header	header;		/* Value length is 4 x N octets. */
+  struct in_addr	value;		/* Local IP address(es). */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Neighbor Interface IP Address - RFC 5305 */
+#define TE_SUBTLV_RMT_IPADDR	8
+struct te_subtlv_rmt_ipaddr
+{
+  struct subtlv_header	header;		/* Value length is 4 x N octets. */
+  struct in_addr	value;		/* Neighbor's IP address(es). */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Maximum Bandwidth - RFC 5305 */
+#define TE_SUBTLV_MAX_BW	9
+struct te_subtlv_max_bw
+{
+  struct subtlv_header	header;		/* Value length is 4 octets. */
+  float			value;		/* bytes/sec */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Maximum Reservable Bandwidth - RFC 5305 */
+#define TE_SUBTLV_MAX_RSV_BW	10
+struct te_subtlv_max_rsv_bw
+{
+  struct subtlv_header	header;		/* Value length is 4 octets. */
+  float			value;		/* bytes/sec */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Unreserved Bandwidth - RFC 5305 */
+#define TE_SUBTLV_UNRSV_BW	11
+#define TE_SUBTLV_UNRSV_SIZE	32
+struct te_subtlv_unrsv_bw
+{
+  struct subtlv_header	header;		/* Value length is 32 octets. */
+  float			value[8];	/* One for each priority level. */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Traffic Engineering Metric - RFC 5305 */
+#define TE_SUBTLV_TE_METRIC	18
+#define TE_SUBTLV_TE_METRIC_SIZE    3
+struct te_subtlv_te_metric
+{
+  struct subtlv_header	header;		/* Value length is 4 octets. */
+  u_char		value[3];	/* Link metric for TE purpose. */
+} __attribute__((__packed__));
+
+/* Remote AS Number sub-TLV - RFC5316 */
+#define TE_SUBTLV_RAS		24
+struct te_subtlv_ras
+{
+  struct subtlv_header header;		/* Value length is 4 octets. */
+  u_int32_t	       value;        	/* Remote AS number */
+} __attribute__((__packed__));
+
+/* IPv4 Remote ASBR ID Sub-TLV - RFC5316 */
+#define TE_SUBTLV_RIP		25
+struct te_subtlv_rip
+{
+  struct subtlv_header header;		/* Value length is 4 octets. */
+  struct in_addr       value;		/* Remote ASBR IP address */
+} __attribute__((__packed__));
+
+
+/* draft-ietf-isis-te-metric-extensions-03.txt */
+/* Link Sub-TLV: Average Link Delay */
+#define TE_SUBTLV_AV_DELAY	26
+struct te_subtlv_av_delay
+{
+  struct subtlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* Average delay in micro-seconds only 24 bits => 0 ... 16777215
+                                   with Anomalous Bit (A) as Upper most bit */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Low/High Link Delay */
+#define TE_SUBTLV_MM_DELAY     27
+#define TE_SUBTLV_MM_DELAY_SIZE    8
+struct te_subtlv_mm_delay
+{
+  struct subtlv_header header;  /* Value length is 8 bytes. */
+  u_int32_t            low;     /* low delay in micro-seconds only 24 bits => 0 ... 16777215
+                                   with Anomalous Bit (A) as Upper most bit */
+  u_int32_t            high;    /* high delay in micro-seconds only 24 bits => 0 ... 16777215 */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Link Delay Variation i.e. Jitter */
+#define TE_SUBTLV_DELAY_VAR    28
+struct te_subtlv_delay_var
+{
+  struct subtlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* interval in micro-seconds only 24 bits => 0 ... 16777215 */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Routine Unidirectional Link Packet Loss */
+#define TE_SUBTLV_PKT_LOSS	29
+struct te_subtlv_pkt_loss
+{
+  struct subtlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* in percentage of total traffic only 24 bits (2^24 - 2)
+                                   with Anomalous Bit (A) as Upper most bit */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Unidirectional Residual Bandwidth */ /* Optional */
+#define TE_SUBTLV_RES_BW	30
+struct te_subtlv_res_bw
+{
+  struct subtlv_header header;  /* Value length is 4 bytes. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Unidirectional Available Bandwidth */ /* Optional */
+#define TE_SUBTLV_AVA_BW	31
+struct te_subtlv_ava_bw
+{
+  struct subtlv_header header;  /* Value length is 4 octets. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+} __attribute__((__packed__));
+
+/* Link Sub-TLV: Unidirectional Utilized Bandwidth */ /* Optional */
+#define TE_SUBTLV_USE_BW        32
+struct te_subtlv_use_bw
+{
+  struct subtlv_header header;  /* Value length is 4 octets. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+} __attribute__((__packed__));
+
+#define TE_SUBTLV_MAX		33      /* Last SUBTLV + 1 */
+
+/* Following declaration concerns the MPLS-TE and LINk-TE management */
+typedef enum _status_t { disable, enable, learn } status_t;
+
+/* Mode for Inter-AS LSP */ /* TODO: Check how if LSP is flooded in RFC5316 */
+typedef enum _interas_mode_t { off, region, as, emulate } interas_mode_t;
+
+#define IS_MPLS_TE(m)    (m.status == enable)
+#define IS_CIRCUIT_TE(c) (c->status == enable)
+
+/* Following structure are internal use only. */
+struct isis_mpls_te
+{
+  /* Status of MPLS-TE: enable or disable */
+  status_t status;
+
+  /* L1, L1-L2, L2-Only */
+  u_int8_t level;
+
+  /* RFC5316 */
+  interas_mode_t inter_as;
+  struct in_addr interas_areaid;
+
+  /* Circuit list on which TE are enable */
+  struct list *cir_list;
+
+  /* MPLS_TE router ID */
+  struct in_addr router_id;
+};
+
+extern struct isis_mpls_te isisMplsTE;
+
+struct mpls_te_circuit
+{
+
+  /* Status of MPLS-TE on this interface */
+  status_t status;
+
+  /* Type of MPLS-TE circuit: STD_TE(RFC5305), INTER_AS(RFC5316), INTER_AS_EMU(RFC5316 emulated) */
+  u_int8_t type;
+
+  /* Total size of sub_tlvs */
+  u_char length;
+
+  /* Store subTLV in network byte order. */
+  /* RFC5305 */
+  struct te_subtlv_admin_grp admin_grp;
+  /* RFC5307 */
+  struct te_subtlv_llri llri;
+  /* RFC5305 */
+  struct te_subtlv_local_ipaddr local_ipaddr;
+  struct te_subtlv_rmt_ipaddr rmt_ipaddr;
+  struct te_subtlv_max_bw max_bw;
+  struct te_subtlv_max_rsv_bw max_rsv_bw;
+  struct te_subtlv_unrsv_bw unrsv_bw;
+  struct te_subtlv_te_metric te_metric;
+  /* RFC5316 */
+  struct te_subtlv_ras ras;
+  struct te_subtlv_rip rip;
+  /* draft-ietf-isis-te-metric-extension */
+  struct te_subtlv_av_delay av_delay;
+  struct te_subtlv_mm_delay mm_delay;
+  struct te_subtlv_delay_var delay_var;
+  struct te_subtlv_pkt_loss pkt_loss;
+  struct te_subtlv_res_bw res_bw;
+  struct te_subtlv_ava_bw ava_bw;
+  struct te_subtlv_use_bw use_bw;
+};
+
+/* Prototypes. */
+void isis_mpls_te_init (void);
+struct mpls_te_circuit *mpls_te_circuit_new(void);
+void mpls_te_print_detail(struct vty *, struct te_is_neigh *);
+void set_circuitparams_local_ipaddr (struct mpls_te_circuit *, struct in_addr);
+void set_circuitparams_rmt_ipaddr (struct mpls_te_circuit *, struct in_addr);
+u_char subtlvs_len (struct mpls_te_circuit *);
+u_char add_te_subtlvs(u_char *, struct mpls_te_circuit *);
+u_char build_te_subtlvs(u_char *, struct isis_circuit *);
+void isis_mpls_te_update(struct interface *);
+void isis_mpls_te_config_write_router (struct vty *);
+
+#endif /* _ZEBRA_ISIS_MPLS_TE_H */
diff --git a/isisd/isis_tlv.c b/isisd/isis_tlv.c
index bbfa5d8..c94d7e9 100644
--- a/isisd/isis_tlv.c
+++ b/isisd/isis_tlv.c
@@ -43,6 +43,10 @@
 #include "isisd/isis_pdu.h"
 #include "isisd/isis_lsp.h"
 
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
+
 void
 free_tlv (void *val)
 {
@@ -115,7 +119,6 @@ parse_tlvs (char *areatag, u_char * stream, int size, u_int32_t * expected,
   struct ipv6_reachability *ipv6_reach;
   int prefix_octets;
 #endif /* HAVE_IPV6 */
-  u_char virtual;
   int value_len, retval = ISIS_OK;
   u_char *start = stream, *pnt = stream, *endpnt;
 
@@ -179,7 +182,6 @@ parse_tlvs (char *areatag, u_char * stream, int size, u_int32_t * expected,
 	       * |                        Virtual Flag                           | 
 	       * +-------+-------+-------+-------+-------+-------+-------+-------+
 	       */
-	      virtual = *pnt;	/* FIXME: what is the use for this? */
 	      pnt++;
 	      value_len++;
 	      /* +-------+-------+-------+-------+-------+-------+-------+-------+
@@ -231,9 +233,25 @@ parse_tlvs (char *areatag, u_char * stream, int size, u_int32_t * expected,
 	      while (length > value_len)
 		{
 		  te_is_nei = (struct te_is_neigh *) pnt;
-		  value_len += 11;
-		  pnt += 11;
-		  /* FIXME - subtlvs are handled here, for now we skip */
+		  value_len += IS_NEIGHBOURS_LEN;
+		  pnt += IS_NEIGHBOURS_LEN;
+                  /* FIXME - subtlvs are handled here, for now we skip */
+#ifdef HAVE_ISIS_TE
+		  /* FIXME: All TE SubTLVs are not necessary present in LSP PDU. */
+		  /* So, it must be copied in a new te_is_neigh structure        */
+		  /* rather than just initialize pointer to the original LSP PDU */
+		  /* to avoid consider the rest of lspdu as subTLVs or buffer overflow */
+		  if (IS_MPLS_TE(isisMplsTE))
+		    {
+		      struct te_is_neigh *new = XCALLOC(MTYPE_ISIS_TLV, sizeof(struct te_is_neigh));
+		      memcpy(new->neigh_id, te_is_nei->neigh_id, ISIS_SYS_ID_LEN + 1);
+		      memcpy(new->te_metric, te_is_nei->te_metric, 3);
+		      new->sub_tlvs_length = te_is_nei->sub_tlvs_length;
+		      memcpy(new->sub_tlvs, pnt, te_is_nei->sub_tlvs_length);
+                      te_is_nei = new;
+                    }
+#endif /* HAVE_ISIS_TE */
+		  /* Skip SUB TLVs payload */
 		  value_len += te_is_nei->sub_tlvs_length;
 		  pnt += te_is_nei->sub_tlvs_length;
 
@@ -848,7 +866,12 @@ tlv_add_te_is_neighs (struct list *te_is_neighs, struct stream *stream)
   for (ALL_LIST_ELEMENTS_RO (te_is_neighs, node, te_is_neigh))
     {
       /* FIXME: This will be wrong if we are going to add TE sub TLVs. */
+#ifndef HAVE_ISIS_TE
       if (pos - value + IS_NEIGHBOURS_LEN > 255)
+#else
+      /* FIXME: Check if Total SubTLVs size doesn't exceed 255 */
+      if (pos - value + IS_NEIGHBOURS_LEN + te_is_neigh->sub_tlvs_length > 255)
+#endif /* HAVE_ISIS_TE */
         {
           retval = add_tlv (TE_IS_NEIGHBOURS, pos - value, value, stream);
           if (retval != ISIS_OK)
@@ -860,9 +883,21 @@ tlv_add_te_is_neighs (struct list *te_is_neighs, struct stream *stream)
       pos += ISIS_SYS_ID_LEN + 1;
       memcpy (pos, te_is_neigh->te_metric, 3);
       pos += 3;
+#ifndef HAVE_ISIS_TE
       /* Sub TLVs length. */
       *pos = 0;
       pos++;
+#else
+      /* Set the total size of Sub TLVs */
+      *pos = te_is_neigh->sub_tlvs_length;
+      pos++;
+      /* Copy Sub TLVs if any */
+      if (te_is_neigh->sub_tlvs_length > 0)
+        {
+          memcpy (pos, te_is_neigh->sub_tlvs, te_is_neigh->sub_tlvs_length);
+          pos += te_is_neigh->sub_tlvs_length;
+        }
+#endif /* HAVE_ISIS_TE */
     }
 
   return add_tlv (TE_IS_NEIGHBOURS, pos - value, value, stream);
diff --git a/isisd/isis_tlv.h b/isisd/isis_tlv.h
index e092f4d..088c35c 100644
--- a/isisd/isis_tlv.h
+++ b/isisd/isis_tlv.h
@@ -39,7 +39,7 @@
  * LSP Entries                9   n   n   y  ISO10589
  * Authentication            10   y   y   y  ISO10589, RFC3567
  * Checksum                  12   y   n   y  RFC3358
- * TE IS Reachability        22   n   y   n  RFC5305
+ * Extended IS Reachability  22   n   y   n  RFC5305
  * IS Alias                  24   n   y   n  RFC3786
  * IP Int. Reachability     128   n   y   n  RFC1195
  * Protocols Supported      129   y   y   n  RFC1195
@@ -50,6 +50,7 @@
  * Extended IP Reachability 135   n   y   n  RFC5305
  * Dynamic Hostname         137   n   y   n  RFC2763
  * Shared Risk Link Group   138   n   y   y  RFC5307
+ * Inter-AS Reachability    141   n   y   n  RFC5316
  * Restart TLV              211   y   n   n  RFC3847
  * MT IS Reachability       222   n   y   n  RFC5120
  * MT Supported             229   y   y   n  RFC5120
@@ -59,10 +60,10 @@
  * MT IPv6 IP Reachability  237   n   y   n  RFC5120
  * P2P Adjacency State      240   y   n   n  RFC3373
  * IIH Sequence Number      241   y   n   n  draft-shen-isis-iih-sequence
- * Router Capability        242   -   -   -  draft-ietf-isis-caps
+ * Router Capability        242   n   y   n  RFC4971
  *
  *
- * IS Reachability sub-TLVs we (should) support.
+ * IS Reachability sub-TLVs we support (See isis_te.[c,h])
  * ____________________________________________________________________________
  * Name                           Value   Status
  * ____________________________________________________________________________
@@ -76,6 +77,8 @@
  * TE Default metric                 18   RFC5305
  * Link Protection Type              20   RFC5307
  * Interface Switching Capability    21   RFC5307
+ * Remote AS number                  24   RFC5316
+ * IPv4 Remote ASBR identifier       25   RFC5316
  *
  *
  * IP Reachability sub-TLVs we (should) support.
@@ -109,6 +112,7 @@
 #define IPV6_ADDR                 232
 #define IPV6_REACHABILITY         236
 #define WAY3_HELLO                240
+#define ROUTER_INFORMATION        242
 
 #define AUTH_INFO_HDRLEN          3
 
@@ -119,6 +123,8 @@
 #define IPV6_REACH_LEN 22
 #define TE_IPV4_REACH_LEN 9
 
+#define MAX_SUBTLV_SIZE         256
+
 /* struct for neighbor */
 struct is_neigh
 {
@@ -126,12 +132,20 @@ struct is_neigh
   u_char neigh_id[ISIS_SYS_ID_LEN + 1];
 };
 
-/* struct for te is neighbor */
+/* struct for te metric */
 struct te_is_neigh
 {
   u_char neigh_id[ISIS_SYS_ID_LEN + 1];
   u_char te_metric[3];
   u_char sub_tlvs_length;
+#ifdef HAVE_ISIS_TE
+  /* Theorical Maximum SubTLVs is 256 because the sub_tlvs_length is 8 bits */
+  /* Practically, 118 bytes are necessary to store all supported TE parameters */
+  /* FIXME: A pointer will use less memory, but need to be free */
+  /* which is hard to fix, especially within free_tlvs() function */
+  /* and malloc() / free() as a CPU cost compared to the memory usage */
+  u_char sub_tlvs[MAX_SUBTLV_SIZE];      /* SUB TLVs storage */
+#endif /* HAVE_ISIS_TE */
 };
 
 /* Decode and encode three-octet metric into host byte order integer */
diff --git a/isisd/isis_zebra.c b/isisd/isis_zebra.c
index 2df7462..50d88af 100644
--- a/isisd/isis_zebra.c
+++ b/isisd/isis_zebra.c
@@ -46,6 +46,9 @@
 #include "isisd/isis_lsp.h"
 #include "isisd/isis_route.h"
 #include "isisd/isis_zebra.h"
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
 
 struct zclient *zclient = NULL;
 
@@ -58,6 +61,15 @@ isis_router_id_update_zebra (int command, struct zclient *zclient,
   struct listnode *node;
   struct prefix router_id;
 
+#ifdef HAVE_ISIS_TE
+  /*
+   * If ISIS TE is enable, TE Router ID is set through specific command.
+   * See mpls_te_router_addr() command in isis_te.c
+   */
+  if (IS_MPLS_TE(isisMplsTE))
+    return 0;
+#endif /* HAVE_ISIS_TE */
+
   zebra_router_id_update_read (zclient->ibuf, &router_id);
   if (isis->router_id == router_id.u.prefix4.s_addr)
     return 0;
@@ -223,6 +235,25 @@ isis_zebra_if_address_del (int command, struct zclient *client,
   return 0;
 }
 
+#ifdef HAVE_ISIS_TE
+static int
+isis_zebra_if_update (int command, struct zclient *zclient,
+                        zebra_size_t length)
+{
+  struct interface *ifp;
+
+  ifp = zebra_interface_state_read (zclient->ibuf);
+
+  if (ifp == NULL)
+    return 0;
+
+  /* Update TE TLV */
+  isis_mpls_te_update(ifp);
+
+  return 0;
+}
+#endif /* HAVE_ISIS_TE*/
+
 static void
 isis_zebra_route_add_ipv4 (struct prefix *prefix,
 			   struct isis_route_info *route_info)
@@ -599,6 +630,9 @@ isis_zebra_init ()
   zclient->interface_down = isis_zebra_if_state_down;
   zclient->interface_address_add = isis_zebra_if_address_add;
   zclient->interface_address_delete = isis_zebra_if_address_del;
+#ifdef HAVE_ISIS_TE
+  zclient->interface_update = isis_zebra_if_update;
+#endif /* HAVE_ISIS_TE */
   zclient->ipv4_route_add = isis_zebra_read_ipv4;
   zclient->ipv4_route_delete = isis_zebra_read_ipv4;
 #ifdef HAVE_IPV6
diff --git a/isisd/isisd.c b/isisd/isisd.c
index ce6a262..e68aa00 100644
--- a/isisd/isisd.c
+++ b/isisd/isisd.c
@@ -55,6 +55,10 @@
 #include "isisd/isis_zebra.h"
 #include "isisd/isis_events.h"
 
+#ifdef HAVE_ISIS_TE
+#include "isisd/isis_te.h"
+#endif /* HAVE_ISIS_TE */
+
 #ifdef TOPOLOGY_GENERATE
 #include "spgrid.h"
 u_char DEFAULT_TOPOLOGY_BASEIS[6] = { 0xFE, 0xED, 0xFE, 0xED, 0x00, 0x00 };
@@ -98,6 +102,9 @@ isis_new (unsigned long process_id)
    * uncomment the next line for full debugs
    */
   /* isis->debugs = 0xFFFF; */
+#ifdef HAVE_ISIS_TE
+  isisMplsTE.status = disable;            /* Only support TE metric */
+#endif /* HAVE_ISIS_TE */
 }
 
 struct isis_area *
@@ -777,13 +784,15 @@ print_debug (struct vty *vty, int flags, int onoff)
 }
 
 DEFUN (show_debugging,
-       show_debugging_cmd,
-       "show debugging",
+       show_debugging_isis_cmd,
+       "show debugging isis",
        SHOW_STR
        "State of each debugging option\n")
 {
-  vty_out (vty, "IS-IS:%s", VTY_NEWLINE);
-  print_debug (vty, isis->debugs, 1);
+  if (isis->debugs) {
+      vty_out (vty, "IS-IS:%s", VTY_NEWLINE);
+      print_debug (vty, isis->debugs, 1);
+  }
   return CMD_SUCCESS;
 }
 
@@ -3071,6 +3080,9 @@ isis_config_write (struct vty *vty)
 #endif /* TOPOLOGY_GENERATE */
 
       }
+#ifdef HAVE_ISIS_TE
+    isis_mpls_te_config_write_router(vty);
+#endif /* HAVE_ISIS_TE */
     }
 
   return write;
@@ -3125,7 +3137,7 @@ isis_init ()
   install_element (ENABLE_NODE, &show_database_arg_detail_cmd);
   install_element (ENABLE_NODE, &show_database_detail_cmd);
   install_element (ENABLE_NODE, &show_database_detail_arg_cmd);
-  install_element (ENABLE_NODE, &show_debugging_cmd);
+  install_element (ENABLE_NODE, &show_debugging_isis_cmd);
 
   install_node (&debug_node, config_write_debug);
 
diff --git a/isisd/isisd.h b/isisd/isisd.h
index 5db485f..971afdf 100644
--- a/isisd/isisd.h
+++ b/isisd/isisd.h
@@ -164,4 +164,10 @@ extern struct thread_master *master;
 #define DEBUG_ZEBRA                      (1<<11)
 #define DEBUG_PACKET_DUMP                (1<<12)
 
+#ifdef HAVE_ISIS_TE
+#define DEBUG_TE                         (1<<13)
+#endif /* HAVE_ISIS_TE */
+
+#define IS_DEBUG_ISIS(x)                 (isis->debugs & x)
+
 #endif /* ISISD_H */
diff --git a/lib/command.h b/lib/command.h
index e47c425..52d770a 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -482,6 +482,14 @@ struct cmd_token
 "(neighbor|interface|area|lsa|zebra|config|dbex|spf|route|lsdb|redistribute|hook|asbr|prefix|abr)"
 #define ISIS_STR "IS-IS information\n"
 #define AREA_TAG_STR "[area tag]\n"
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+#define MPLS_TE_STR "MPLS-TE specific commands\n"
+#define MPLS_TE_LINK_STR "Configure MPLS-TE link parameters\n"
+#endif /* HAVE_OSPF_TE or HAVE_ISIS_TE */
+#ifdef HAVE_OSPF_RI
+#define OSPF_RI_STR "OSPF Router Information specific commands\n"
+#define PCE_STR "PCE Router Information specific commands\n"
+#endif /* HAVE_OSPF_RI */
 
 #define CONF_BACKUP_EXT ".sav"
 
diff --git a/lib/if.h b/lib/if.h
index 8081be8..5c62c05 100644
--- a/lib/if.h
+++ b/lib/if.h
@@ -68,6 +68,42 @@ struct if_stats
 };
 #endif /* HAVE_PROC_NET_DEV */
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+
+/* Here are "non-official" architectural constants. */
+#define TE_EXT_MASK             0x0FFFFFFF
+#define TE_EXT_ANORMAL          0x80000000
+#define LOSS_PRECISION          0.000003
+#define TE_KILO_BIT             1000
+#define TE_BYTE                 8
+#define DEFAULT_BANDWIDTH       10000
+#define MAX_CLASS_TYPE          8
+#define MAX_PKT_LOSS            50.331642
+
+/* Traffic Engineering Link Parameters */
+struct if_link_te {
+  u_int32_t te_metric;   /* Traffic Engineering metric */
+  float max_bw;          /* Maximum Bandwidth */
+  float max_rsv_bw;      /* Maximum Reservable Bandwidth */
+  float unrsv_bw[MAX_CLASS_TYPE];     /* Unreserved Bandwidth per Class Type (8) */
+  u_int32_t admin_grp;   /* Administrative group */
+  u_int32_t rmt_as;      /* Remote AS number */
+  struct in_addr rmt_ip; /* Remote IP address */
+  u_int32_t av_delay;    /* Link Average Delay */
+  u_int32_t min_delay;   /* Link Min Delay */
+  u_int32_t max_delay;   /* Link Max Delay */
+  u_int32_t delay_var;   /* Link Delay Variation */
+  float pkt_loss;        /* Link Packet Loss */
+  float res_bw;          /* Residual Bandwidth */
+  float ava_bw;          /* Available Bandwidth */
+  float use_bw;          /* Utilized Bandwidth */
+};
+
+#define INTERFACE_LINK_TE_SIZE   sizeof(struct if_link_te)
+#define IS_LINK_TE(ifp)  (ifp->mpls_te == MPLS_TE_ON)
+
+#endif /* Traffic Engineering */
+
 /* Interface structure */
 struct interface 
 {
@@ -119,6 +155,15 @@ struct interface
   /* interface bandwidth, kbits */
   unsigned int bandwidth;
   
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  /* Traffic Engineering Link status */
+  u_char mpls_te;        /* MPLS TE status */
+#define MPLS_TE_OFF  0
+#define MPLS_TE_ON   1
+  /* Traffic Engineering Link parameters */
+  struct if_link_te link_te;
+#endif /* Traffic Engineering */
+
   /* description of the interface. */
   char *desc;			
 
@@ -139,6 +184,7 @@ struct interface
 #ifdef HAVE_NET_RT_IFLIST
   struct if_data stats;
 #endif /* HAVE_NET_RT_IFLIST */
+
 };
 
 /* Connected address structure. */
diff --git a/lib/memtypes.c b/lib/memtypes.c
index 47a3438..25e70af 100644
--- a/lib/memtypes.c
+++ b/lib/memtypes.c
@@ -211,6 +211,8 @@ struct memory_list memory_list_ospf[] =
   { MTYPE_OSPF_IF_INFO,       "OSPF if info"			},
   { MTYPE_OSPF_IF_PARAMS,     "OSPF if params"			},
   { MTYPE_OSPF_MESSAGE,		"OSPF message"			},
+  { MTYPE_OSPF_MPLS_TE,       "OSPF MPLS parameters"            },
+  { MTYPE_OSPF_PCE_PARAMS,    "OSPF PCE parameters"             },
   { -1, NULL },
 };
 
@@ -252,6 +254,7 @@ struct memory_list memory_list_isis[] =
   { MTYPE_ISIS_NEXTHOP6,      "ISIS nexthop6"			},
   { MTYPE_ISIS_DICT,          "ISIS dictionary"			},
   { MTYPE_ISIS_DICT_NODE,     "ISIS dictionary node"		},
+  { MTYPE_ISIS_MPLS_TE,       "ISIS MPLS_TE parameters"         },
   { -1, NULL },
 };
 
diff --git a/lib/zclient.c b/lib/zclient.c
index 3b5477e..2277b2e 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -740,6 +740,15 @@ zebra_interface_if_set_value (struct stream *s, struct interface *ifp)
   if (ifp->hw_addr_len)
     stream_get (ifp->hw_addr, s, ifp->hw_addr_len);
 #endif /* HAVE_STRUCT_SOCKADDR_DL */
+
+#if defined(HAVE_OSPF_TE) || defined (HAVE_ISIS_TE)
+  /* Read Traffic Engineering status */
+  ifp->mpls_te = stream_getc (s);
+  /* Then, Traffic Engineering parameters if any */
+  if (IS_LINK_TE(ifp))
+    stream_get (&ifp->link_te, s, INTERFACE_LINK_TE_SIZE);
+#endif /* Traffic Engineering */
+
 }
 
 static int
@@ -951,6 +960,12 @@ zclient_read (struct thread *thread)
       if (zclient->interface_down)
 	(*zclient->interface_down) (command, zclient, length);
       break;
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+    case ZEBRA_INTERFACE_UPDATE:
+      if (zclient->interface_update)
+        (*zclient->interface_update) (command, zclient, length);
+      break;
+#endif /* Traffic Engineering */
     case ZEBRA_IPV4_ROUTE_ADD:
       if (zclient->ipv4_route_add)
 	(*zclient->ipv4_route_add) (command, zclient, length);
diff --git a/lib/zclient.h b/lib/zclient.h
index a660bbf..f49205b 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -78,6 +78,9 @@ struct zclient
   int (*interface_down) (int, struct zclient *, uint16_t);
   int (*interface_address_add) (int, struct zclient *, uint16_t);
   int (*interface_address_delete) (int, struct zclient *, uint16_t);
+#if defined(HAVE_OSPF_TE) || defined (HAVE_ISIS_TE)
+  int (*interface_update) (int, struct zclient *, uint16_t);
+#endif /* Traffic Engineering */
   int (*ipv4_route_add) (int, struct zclient *, uint16_t);
   int (*ipv4_route_delete) (int, struct zclient *, uint16_t);
   int (*ipv6_route_add) (int, struct zclient *, uint16_t);
diff --git a/lib/zebra.h b/lib/zebra.h
index 3715b34..95cfec9 100644
--- a/lib/zebra.h
+++ b/lib/zebra.h
@@ -424,7 +424,8 @@ struct in_pktinfo
 #define ZEBRA_ROUTER_ID_DELETE            21
 #define ZEBRA_ROUTER_ID_UPDATE            22
 #define ZEBRA_HELLO                       23
-#define ZEBRA_MESSAGE_MAX                 24
+#define ZEBRA_INTERFACE_UPDATE            24
+#define ZEBRA_MESSAGE_MAX                 25
 
 /* Marker value used in new Zserv, in the byte location corresponding
  * the command value in the old zserv header. To allow old and new
diff --git a/ospfd/Makefile.am b/ospfd/Makefile.am
index 4e1a4fe..200c6a5 100644
--- a/ospfd/Makefile.am
+++ b/ospfd/Makefile.am
@@ -14,7 +14,7 @@ libospf_la_SOURCES = \
 	ospf_nsm.c ospf_dump.c ospf_network.c ospf_packet.c ospf_lsa.c \
 	ospf_spf.c ospf_route.c ospf_ase.c ospf_abr.c ospf_ia.c ospf_flood.c \
 	ospf_lsdb.c ospf_asbr.c ospf_routemap.c ospf_snmp.c \
-	ospf_opaque.c ospf_te.c ospf_vty.c ospf_api.c ospf_apiserver.c
+	ospf_opaque.c ospf_te.c ospf_ri.c ospf_vty.c ospf_api.c ospf_apiserver.c
 
 ospfdheaderdir = $(pkgincludedir)/ospfd
 
@@ -25,11 +25,11 @@ ospfdheader_HEADERS = \
 noinst_HEADERS = \
 	ospf_interface.h ospf_neighbor.h ospf_network.h ospf_packet.h \
 	ospf_zebra.h ospf_spf.h ospf_route.h ospf_ase.h ospf_abr.h ospf_ia.h \
-	ospf_flood.h ospf_snmp.h ospf_te.h ospf_vty.h ospf_apiserver.h
+	ospf_flood.h ospf_snmp.h ospf_te.h ospf_ri.h ospf_vty.h ospf_apiserver.h
 
 ospfd_SOURCES = ospf_main.c
 
-ospfd_LDADD = libospf.la ../lib/libzebra.la @LIBCAP@
+ospfd_LDADD = libospf.la ../lib/libzebra.la @LIBCAP@ @LIBM@
 
 EXTRA_DIST = OSPF-MIB.txt OSPF-TRAP-MIB.txt ChangeLog.opaque.txt
 
diff --git a/ospfd/ospf_dump.c b/ospfd/ospf_dump.c
index ef02336..6e9bc03 100644
--- a/ospfd/ospf_dump.c
+++ b/ospfd/ospf_dump.c
@@ -133,6 +133,7 @@ unsigned long conf_debug_ospf_nsm = 0;
 unsigned long conf_debug_ospf_lsa = 0;
 unsigned long conf_debug_ospf_zebra = 0;
 unsigned long conf_debug_ospf_nssa = 0;
+unsigned long conf_debug_ospf_te = 0;
 
 /* Enable debug option variables -- valid only session. */
 unsigned long term_debug_ospf_packet[5] = {0, 0, 0, 0, 0};
@@ -142,7 +143,7 @@ unsigned long term_debug_ospf_nsm = 0;
 unsigned long term_debug_ospf_lsa = 0;
 unsigned long term_debug_ospf_zebra = 0;
 unsigned long term_debug_ospf_nssa = 0;
-
+unsigned long term_debug_ospf_te = 0;
 
 
 const char *
@@ -321,13 +322,14 @@ ospf_options_dump (u_char options)
 {
   static char buf[OSPF_OPTION_STR_MAXLEN];
 
-  snprintf (buf, OSPF_OPTION_STR_MAXLEN, "*|%s|%s|%s|%s|%s|%s|*",
+  snprintf (buf, OSPF_OPTION_STR_MAXLEN, "*|%s|%s|%s|%s|%s|%s|%s",
 	    (options & OSPF_OPTION_O) ? "O" : "-",
 	    (options & OSPF_OPTION_DC) ? "DC" : "-",
 	    (options & OSPF_OPTION_EA) ? "EA" : "-",
 	    (options & OSPF_OPTION_NP) ? "N/P" : "-",
 	    (options & OSPF_OPTION_MC) ? "MC" : "-",
-	    (options & OSPF_OPTION_E) ? "E" : "-");
+           (options & OSPF_OPTION_E) ? "E" : "-",
+           (options & OSPF_OPTION_MT) ? "M/T" : "-");
 
   return buf;
 }
@@ -1421,6 +1423,32 @@ DEFUN (no_debug_ospf_nssa,
   return CMD_SUCCESS;
 }
 
+DEFUN (debug_ospf_te,
+       debug_ospf_te_cmd,
+       "debug ospf te",
+       DEBUG_STR
+       OSPF_STR
+       "OSPF-TE information\n")
+{
+  if (vty->node == CONFIG_NODE)
+    CONF_DEBUG_ON (te, TE);
+  TERM_DEBUG_ON (te, TE);
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_ospf_te,
+       no_debug_ospf_te_cmd,
+       "no debug ospf te",
+       NO_STR
+       DEBUG_STR
+       OSPF_STR
+       "OSPF-TE information\n")
+{
+  if (vty->node == CONFIG_NODE)
+    CONF_DEBUG_OFF (te, TE);
+  TERM_DEBUG_OFF (te, TE);
+  return CMD_SUCCESS;
+}
 
 DEFUN (show_debugging_ospf,
        show_debugging_ospf_cmd,
@@ -1668,6 +1696,7 @@ debug_init ()
   install_element (ENABLE_NODE, &debug_ospf_zebra_cmd);
   install_element (ENABLE_NODE, &debug_ospf_event_cmd);
   install_element (ENABLE_NODE, &debug_ospf_nssa_cmd);
+  install_element (ENABLE_NODE, &debug_ospf_te_cmd);
   install_element (ENABLE_NODE, &no_debug_ospf_packet_send_recv_detail_cmd);
   install_element (ENABLE_NODE, &no_debug_ospf_packet_send_recv_cmd);
   install_element (ENABLE_NODE, &no_debug_ospf_packet_all_cmd);
@@ -1681,6 +1710,7 @@ debug_init ()
   install_element (ENABLE_NODE, &no_debug_ospf_zebra_cmd);
   install_element (ENABLE_NODE, &no_debug_ospf_event_cmd);
   install_element (ENABLE_NODE, &no_debug_ospf_nssa_cmd);
+  install_element (ENABLE_NODE, &no_debug_ospf_te_cmd);
 
   install_element (CONFIG_NODE, &debug_ospf_packet_send_recv_detail_cmd);
   install_element (CONFIG_NODE, &debug_ospf_packet_send_recv_cmd);
@@ -1695,6 +1725,7 @@ debug_init ()
   install_element (CONFIG_NODE, &debug_ospf_zebra_cmd);
   install_element (CONFIG_NODE, &debug_ospf_event_cmd);
   install_element (CONFIG_NODE, &debug_ospf_nssa_cmd);
+  install_element (CONFIG_NODE, &debug_ospf_te_cmd);
   install_element (CONFIG_NODE, &no_debug_ospf_packet_send_recv_detail_cmd);
   install_element (CONFIG_NODE, &no_debug_ospf_packet_send_recv_cmd);
   install_element (CONFIG_NODE, &no_debug_ospf_packet_all_cmd);
@@ -1708,4 +1739,5 @@ debug_init ()
   install_element (CONFIG_NODE, &no_debug_ospf_zebra_cmd);
   install_element (CONFIG_NODE, &no_debug_ospf_event_cmd);
   install_element (CONFIG_NODE, &no_debug_ospf_nssa_cmd);
+  install_element (CONFIG_NODE, &no_debug_ospf_te_cmd);
 }
diff --git a/ospfd/ospf_dump.h b/ospfd/ospf_dump.h
index a2d5e8b..f843df0 100644
--- a/ospfd/ospf_dump.h
+++ b/ospfd/ospf_dump.h
@@ -57,6 +57,7 @@
 
 #define OSPF_DEBUG_EVENT        0x01
 #define OSPF_DEBUG_NSSA		0x02
+#define OSPF_DEBUG_TE          0x04
 
 /* Macro for setting debug option. */
 #define CONF_DEBUG_PACKET_ON(a, b)	    conf_debug_ospf_packet[a] |= (b)
@@ -98,6 +99,8 @@
 
 #define IS_DEBUG_OSPF_NSSA  IS_DEBUG_OSPF(nssa,NSSA)
 
+#define IS_DEBUG_OSPF_TE  IS_DEBUG_OSPF(te,TE)
+
 #define IS_CONF_DEBUG_OSPF_PACKET(a, b) \
 	(conf_debug_ospf_packet[a] & OSPF_DEBUG_ ## b)
 #define IS_CONF_DEBUG_OSPF(a, b) \
@@ -119,6 +122,7 @@ extern unsigned long term_debug_ospf_nsm;
 extern unsigned long term_debug_ospf_lsa;
 extern unsigned long term_debug_ospf_zebra;
 extern unsigned long term_debug_ospf_nssa;
+extern unsigned long term_debug_ospf_te;
 
 /* Message Strings. */
 extern char *ospf_lsa_type_str[];
diff --git a/ospfd/ospf_opaque.c b/ospfd/ospf_opaque.c
index 744952c..24443c9 100644
--- a/ospfd/ospf_opaque.c
+++ b/ospfd/ospf_opaque.c
@@ -66,6 +66,10 @@
 #include "ospfd/ospf_te.h"
 #endif /* HAVE_OSPF_TE */
 
+#ifdef HAVE_OSPF_RI
+#include "ospfd/ospf_ri.h"
+#endif /* HAVE_OSPF_RI */
+
 #ifdef SUPPORT_OSPF_API
 int ospf_apiserver_init (void);
 void ospf_apiserver_term (void); 
@@ -92,6 +96,11 @@ ospf_opaque_init (void)
     exit (1);
 #endif /* HAVE_OSPF_TE */
 
+#ifdef HAVE_OSPF_RI
+  if (ospf_router_info_init () != 0)
+    exit (1);
+#endif /* HAVE_OSPF_RI */
+
 #ifdef SUPPORT_OSPF_API
   if ((ospf_apiserver_enable) && (ospf_apiserver_init () != 0))
     exit (1);
@@ -107,6 +116,10 @@ ospf_opaque_term (void)
   ospf_mpls_te_term ();
 #endif /* HAVE_OSPF_TE */
 
+#ifdef HAVE_OSPF_RI
+  ospf_router_info_term ();
+#endif /* HAVE_OSPF_RI */
+
 #ifdef SUPPORT_OSPF_API
   ospf_apiserver_term ();
 #endif /* SUPPORT_OSPF_API */
@@ -220,6 +233,14 @@ ospf_opaque_type_name (u_char opaque_type)
     case OPAQUE_TYPE_GRACE_LSA:
       name = "Grace-LSA";
       break;
+    case OPAQUE_TYPE_INTER_AS_LSA:
+      name = "Inter-AS TE-v2 LSA";
+      break;
+#ifdef HAVE_OSPF_RI
+    case OPAQUE_TYPE_ROUTER_INFORMATION_LSA:
+      name = "Router Information LSA";
+      break;
+#endif /* HAVE_OSPF_RI */
     default:
       if (OPAQUE_TYPE_RANGE_UNASSIGNED (opaque_type))
         name = "Unassigned";
@@ -1992,6 +2013,7 @@ ospf_opaque_lsa_refresh_schedule (struct ospf_lsa *lsa0)
   struct opaque_info_per_type *oipt;
   struct opaque_info_per_id *oipi;
   struct ospf_lsa *lsa;
+  struct ospf *top;
   int delay;
 
   if ((oipt = lookup_opaque_info_by_type (lsa0)) == NULL
@@ -2023,7 +2045,10 @@ ospf_opaque_lsa_refresh_schedule (struct ospf_lsa *lsa0)
       ospf_ls_retransmit_delete_nbr_area (lsa->area, lsa);
       break;
     case OSPF_OPAQUE_AS_LSA:
-      ospf_ls_retransmit_delete_nbr_as (lsa0->area->ospf, lsa);
+      top = ospf_lookup ();
+      if ((lsa0->area != NULL) && (lsa0->area->ospf != NULL))
+        top = lsa0->area->ospf;
+      ospf_ls_retransmit_delete_nbr_as (top, lsa);
       break;
     default:
       zlog_warn ("ospf_opaque_lsa_refresh_schedule: Unexpected LSA-type(%u)", lsa->data->type);
@@ -2068,6 +2093,9 @@ ospf_opaque_lsa_flush_schedule (struct ospf_lsa *lsa0)
   struct opaque_info_per_type *oipt;
   struct opaque_info_per_id *oipi;
   struct ospf_lsa *lsa;
+  struct ospf *top;
+
+  top = ospf_lookup ();
 
   if ((oipt = lookup_opaque_info_by_type (lsa0)) == NULL
   ||  (oipi = lookup_opaque_info_by_id (oipt, lsa0)) == NULL)
@@ -2091,7 +2119,9 @@ ospf_opaque_lsa_flush_schedule (struct ospf_lsa *lsa0)
       ospf_ls_retransmit_delete_nbr_area (lsa->area, lsa);
       break;
     case OSPF_OPAQUE_AS_LSA:
-      ospf_ls_retransmit_delete_nbr_as (lsa0->area->ospf, lsa);
+      if ((lsa0->area != NULL) && (lsa0->area->ospf != NULL))
+        top = lsa0->area->ospf;
+      ospf_ls_retransmit_delete_nbr_as (top, lsa);
       break;
     default:
       zlog_warn ("ospf_opaque_lsa_flush_schedule: Unexpected LSA-type(%u)", lsa->data->type);
@@ -2115,7 +2145,7 @@ ospf_opaque_lsa_flush_schedule (struct ospf_lsa *lsa0)
     zlog_debug ("Schedule Type-%u Opaque-LSA to FLUSH: [opaque-type=%u, opaque-id=%x]", lsa->data->type, GET_OPAQUE_TYPE (ntohl (lsa->data->id.s_addr)), GET_OPAQUE_ID (ntohl (lsa->data->id.s_addr)));
 
   /* This lsa will be flushed and removed eventually. */
-  ospf_lsa_flush (lsa0->area->ospf, lsa);
+  ospf_lsa_flush (top, lsa);
 
 out:
   return;
diff --git a/ospfd/ospf_opaque.h b/ospfd/ospf_opaque.h
index 2273064..091569a 100644
--- a/ospfd/ospf_opaque.h
+++ b/ospfd/ospf_opaque.h
@@ -77,6 +77,10 @@
 #define OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA		1
 #define OPAQUE_TYPE_SYCAMORE_OPTICAL_TOPOLOGY_DESC	2
 #define OPAQUE_TYPE_GRACE_LSA				3
+#define OPAQUE_TYPE_L1VPN_LSA                          5
+#define OPAQUE_TYPE_ROUTER_INFORMATION_LSA             4
+#define OPAQUE_TYPE_INTER_AS_LSA                       6
+#define OPAQUE_TYPE_MAX                                6
 
 /* Followings types are proposed in internet-draft documents. */
 #define OPAQUE_TYPE_8021_QOSPF				129
@@ -87,7 +91,7 @@
 #define OPAQUE_TYPE_WILDCARD				0
 
 #define OPAQUE_TYPE_RANGE_UNASSIGNED(type) \
-	(  4 <= (type) && (type) <= 127)
+	( OPAQUE_TYPE_MAX  <= (type) && (type) <= 127)
 
 #define OPAQUE_TYPE_RANGE_RESERVED(type) \
 	(127 <  (type) && (type) <= 255)
diff --git a/ospfd/ospf_packet.c b/ospfd/ospf_packet.c
index efdf826..cf67578 100644
--- a/ospfd/ospf_packet.c
+++ b/ospfd/ospf_packet.c
@@ -879,7 +879,7 @@ ospf_hello (struct ip *iph, struct ospf_header *ospfh,
   /* Compare options. */
 #define REJECT_IF_TBIT_ON	1 /* XXX */
 #ifdef REJECT_IF_TBIT_ON
-  if (CHECK_FLAG (hello->options, OSPF_OPTION_T))
+  if (CHECK_FLAG (hello->options, OSPF_OPTION_MT))
     {
       /*
        * This router does not support non-zero TOS.
@@ -1234,7 +1234,7 @@ ospf_db_desc (struct ip *iph, struct ospf_header *ospfh,
     }
 
 #ifdef REJECT_IF_TBIT_ON
-  if (CHECK_FLAG (dd->options, OSPF_OPTION_T))
+  if (CHECK_FLAG (dd->options, OSPF_OPTION_MT))
     {
       /*
        * In Hello protocol, optional capability must have checked
diff --git a/ospfd/ospf_ri.c b/ospfd/ospf_ri.c
new file mode 100644
index 0000000..3660165
--- /dev/null
+++ b/ospfd/ospf_ri.c
@@ -0,0 +1,1647 @@
+/*
+ * This is an implementation of RFC4970 Router Information
+ * with support of RFC5088 PCE Capabilites announcement
+ *
+ * Module name: Router Information
+ * Version:     0.99.22
+ * Created:     2012-02-01 by Olivier Dugeon
+ * Copyright (C) 2012 Orange Labs http://www.orange.com/
+ *
+ * This file is part of GNU Quagga.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * GNU Quagga is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Quagga; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+#include <math.h>
+
+#ifdef HAVE_OSPF_RI
+#ifndef HAVE_OPAQUE_LSA
+#error "Wrong configure option"
+#endif /* HAVE_OPAQUE_LSA */
+#endif /* HAVE_OSPF_RI */
+
+#include "linklist.h"
+#include "prefix.h"
+#include "if.h"
+#include "table.h"
+#include "memory.h"
+#include "command.h"
+#include "vty.h"
+#include "stream.h"
+#include "log.h"
+#include "thread.h"
+#include "hash.h"
+#include "sockunion.h"          /* for inet_aton() */
+
+#include "ospfd/ospfd.h"
+#include "ospfd/ospf_interface.h"
+#include "ospfd/ospf_ism.h"
+#include "ospfd/ospf_asbr.h"
+#include "ospfd/ospf_lsa.h"
+#include "ospfd/ospf_lsdb.h"
+#include "ospfd/ospf_neighbor.h"
+#include "ospfd/ospf_nsm.h"
+#include "ospfd/ospf_flood.h"
+#include "ospfd/ospf_packet.h"
+#include "ospfd/ospf_spf.h"
+#include "ospfd/ospf_dump.h"
+#include "ospfd/ospf_route.h"
+#include "ospfd/ospf_ase.h"
+#include "ospfd/ospf_zebra.h"
+#include "ospfd/ospf_ri.h"
+#include "ospfd/ospf_te.h"
+
+struct ospf_pce_info
+{
+
+  /* Store Router Information PCE TLV and SubTLV in network byte order. */
+  struct ri_tlv_pce pce_header;
+  struct ri_pce_subtlv_address pce_address;
+  struct ri_pce_subtlv_path_scope pce_scope;
+  struct list *pce_domain;
+  struct list *pce_neighbor;
+  struct ri_pce_subtlv_cap_flag pce_cap_flag;
+};
+
+/* Following structure are internal use only. */
+struct ospf_router_info
+{
+  status_t status;
+
+  u_int8_t registered;
+  u_int8_t scope;
+
+  /* Flags to manage this router information. */
+#define RIFLG_LOOKUP_DONE			0x1
+#define RIFLG_LSA_ENGAGED			0x2
+#define RIFLG_LSA_FORCED_REFRESH	0x4
+  u_int32_t flags;
+
+  /* area pointer if flooding is Type 10 Null if flooding is AS scope */
+  struct ospf_area *area;
+  struct in_addr area_id;
+
+  /* Store Router Information Capabilities LSA */
+  struct ri_tlv_router_cap router_cap;
+
+  /* Store PCE capability LSA */
+  struct ospf_pce_info pce_info;
+};
+
+/*
+ * Global variable to manage Opaque-LSA/Router Information on this node.
+ * Note that all parameter values are stored in network byte order.
+ */
+static struct ospf_router_info OspfRI;
+
+/*------------------------------------------------------------------------------*
+ * Followings are initialize/terminate functions for Router Information handling.
+ *------------------------------------------------------------------------------*/
+
+static void ospf_router_info_ism_change (struct ospf_interface *oi,
+                                         int old_status);
+static void ospf_router_info_nsm_change (struct ospf_neighbor *nbr,
+                                         int old_status);
+static void ospf_router_info_config_write_router (struct vty *vty);
+static void ospf_router_info_show_info (struct vty *vty,
+                                        struct ospf_lsa *lsa);
+static int ospf_router_info_lsa_originate (void *arg);
+static struct ospf_lsa *ospf_router_info_lsa_refresh (struct ospf_lsa *lsa);
+static void ospf_router_info_lsa_schedule (opcode_t opcode);
+static void ospf_router_info_register_vty (void);
+static void del_pce_info (void *val);
+
+int
+ospf_router_info_init (void)
+{
+
+  memset (&OspfRI, 0, sizeof (struct ospf_router_info));
+  OspfRI.status = disabled;
+  OspfRI.registered = 0;
+  OspfRI.scope = OSPF_OPAQUE_AS_LSA;
+  OspfRI.flags = 0;
+
+  /* Initialize pce domain and neighbor list */
+  OspfRI.pce_info.pce_domain = list_new ();
+  OspfRI.pce_info.pce_domain->del = del_pce_info;
+  OspfRI.pce_info.pce_neighbor = list_new ();
+  OspfRI.pce_info.pce_neighbor->del = del_pce_info;
+
+  ospf_router_info_register_vty ();
+
+  return 0;
+}
+
+static int
+ospf_router_info_register (u_int8_t scope)
+{
+  int rc = 0;
+
+  if (OspfRI.registered)
+    return 0;
+
+  zlog_info ("Register Router Information with scope %s(%d)",
+             scope == OSPF_OPAQUE_AREA_LSA ? "Area" : "AS", scope);
+  rc = ospf_register_opaque_functab (scope,
+                                     OPAQUE_TYPE_ROUTER_INFORMATION_LSA,
+                                     NULL,    /* new interface */
+                                     NULL,    /* del interface */
+                                     ospf_router_info_ism_change,
+                                     ospf_router_info_nsm_change,
+                                     ospf_router_info_config_write_router,
+                                     NULL,    /* Config. write interface */
+                                     NULL,    /* Config. write debug */
+                                     ospf_router_info_show_info,
+                                     ospf_router_info_lsa_originate,
+                                     ospf_router_info_lsa_refresh,
+                                     NULL,    /* new_lsa_hook */
+                                     NULL);   /* del_lsa_hook */
+
+  if (rc != 0)
+    {
+      zlog_warn ("ospf_router_info_init: Failed to register functions");
+      return rc;
+    }
+
+  OspfRI.registered = 1;
+  OspfRI.scope = scope;
+  return 0;
+}
+
+static int
+ospf_router_info_unregister ()
+{
+
+  if ((OspfRI.scope != OSPF_OPAQUE_AS_LSA)
+      && (OspfRI.scope != OSPF_OPAQUE_AREA_LSA))
+    {
+      zlog_warn ("Unable to unregister Router Info functions: Wrong scope!");
+      return -1;
+    }
+
+  ospf_delete_opaque_functab (OspfRI.scope,
+                              OPAQUE_TYPE_ROUTER_INFORMATION_LSA);
+
+  OspfRI.registered = 0;
+  return 0;
+
+}
+
+void
+ospf_router_info_term (void)
+{
+
+  list_delete (OspfRI.pce_info.pce_domain);
+  list_delete (OspfRI.pce_info.pce_neighbor);
+
+  OspfRI.pce_info.pce_domain = NULL;
+  OspfRI.pce_info.pce_neighbor = NULL;
+  OspfRI.status = disabled;
+
+  ospf_router_info_unregister (OspfRI.scope);
+
+  return;
+}
+
+static void
+del_pce_info (void *val)
+{
+  XFREE (MTYPE_OSPF_PCE_PARAMS, val);
+  return;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are control functions for ROUTER INFORMATION parameters management.
+ *------------------------------------------------------------------------*/
+
+static void
+set_router_info_capabilities (struct ri_tlv_router_cap *ric, u_int32_t cap)
+{
+  ric->header.type = htons (RI_TLV_CAPABILITIES);
+  ric->header.length = htons (RI_TLV_LENGTH);
+  ric->value = htonl (cap);
+  return;
+}
+
+static int
+set_pce_header (struct ospf_pce_info *pce)
+{
+  u_int16_t length = 0;
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *domain;
+  struct ri_pce_subtlv_neighbor *neighbor;
+
+  /* PCE Address */
+  if (ntohs (pce->pce_address.header.type) != 0)
+    length += RI_TLV_SIZE (&pce->pce_address.header);
+
+  /* PCE Path Scope */
+  if (ntohs (pce->pce_scope.header.type) != 0)
+    length += RI_TLV_SIZE (&pce->pce_scope.header);
+
+  /* PCE Domain */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_domain, node, domain))
+    {
+      if (ntohs (domain->header.type) != 0)
+        length += RI_TLV_SIZE (&domain->header);
+    }
+
+  /* PCE Neighbor */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_neighbor, node, neighbor))
+    {
+      if (ntohs (neighbor->header.type) != 0)
+        length += RI_TLV_SIZE (&neighbor->header);
+    }
+
+  /* PCE Capabilities */
+  if (ntohs (pce->pce_cap_flag.header.type) != 0)
+    length += RI_TLV_SIZE (&pce->pce_cap_flag.header);
+
+  if (length != 0)
+    {
+      pce->pce_header.header.type = htons (RI_TLV_PCE);
+      pce->pce_header.header.length = htons (length);
+    }
+  else
+    {
+      pce->pce_header.header.type = 0;
+      pce->pce_header.header.length = 0;
+    }
+
+  return length;
+}
+
+static void
+set_pce_address (struct in_addr ipv4, struct ospf_pce_info *pce)
+{
+
+  /* Enable PCE Info */
+  pce->pce_header.header.type = htons (RI_TLV_PCE);
+  /* Set PCE Address */
+  pce->pce_address.header.type = htons (RI_PCE_SUBTLV_ADDRESS);
+  pce->pce_address.header.length = htons (PCE_ADDRESS_LENGTH_IPV4);
+  pce->pce_address.address.type = htons (PCE_ADDRESS_TYPE_IPV4);
+  pce->pce_address.address.value = ipv4;
+
+  return;
+}
+
+static void
+set_pce_path_scope (u_int32_t scope, struct ospf_pce_info *pce)
+{
+
+  /* Enable PCE Info */
+  pce->pce_header.header.type = htons (RI_TLV_PCE);
+  /* Set PCE Scope */
+  pce->pce_scope.header.type = htons (RI_PCE_SUBTLV_PATH_SCOPE);
+  pce->pce_scope.header.length = htons (RI_TLV_LENGTH);
+  pce->pce_scope.value = htonl (scope);
+
+  return;
+}
+
+static void
+set_pce_domain (u_int16_t type, u_int32_t domain, struct ospf_pce_info *pce)
+{
+
+  struct ri_pce_subtlv_domain *new;
+
+  /* Enable PCE Info */
+  pce->pce_header.header.type = htons (RI_TLV_PCE);
+
+  /* Create new domain info */
+  new =
+    XCALLOC (MTYPE_OSPF_PCE_PARAMS,
+             sizeof (struct ri_pce_subtlv_domain));
+
+  new->header.type = htons (RI_PCE_SUBTLV_DOMAIN);
+  new->header.length = htons (PCE_ADDRESS_LENGTH_IPV4);
+  new->type = htons (type);
+  new->value = htonl (domain);
+
+  /* Add new domain to the list */
+  listnode_add (pce->pce_domain, new);
+
+  return;
+}
+
+static void
+unset_pce_domain (u_int16_t type, u_int32_t domain, struct ospf_pce_info *pce)
+{
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *old = NULL;
+  int found = 0;
+
+  /* Search the corresponding node */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_domain, node, old))
+    {
+      if ((old->type == htons (type)) && (old->value == htonl (domain)))
+        {
+          found = 1;
+          break;
+        }
+    }
+
+  /* if found remove it */
+  if (found)
+    {
+      listnode_delete (pce->pce_domain, old);
+
+      /* Avoid misjudgement in the next lookup. */
+      if (listcount (pce->pce_domain) == 0)
+        pce->pce_domain->head = pce->pce_domain->tail = NULL;
+
+      /* Finally free the old domain */
+      XFREE (MTYPE_OSPF_PCE_PARAMS, old);
+    }
+}
+
+static void
+set_pce_neighbor (u_int16_t type, u_int32_t domain, struct ospf_pce_info *pce)
+{
+
+  struct ri_pce_subtlv_neighbor *new;
+
+  /* Enable PCE Info */
+  pce->pce_header.header.type = htons (RI_TLV_PCE);
+
+  /* Create new neighbor info */
+  new =
+    XCALLOC (MTYPE_OSPF_PCE_PARAMS,
+             sizeof (struct ri_pce_subtlv_neighbor));
+
+  new->header.type = htons (RI_PCE_SUBTLV_NEIGHBOR);
+  new->header.length = htons (PCE_ADDRESS_LENGTH_IPV4);
+  new->type = htons (type);
+  new->value = htonl (domain);
+
+  /* Add new domain to the list */
+  listnode_add (pce->pce_neighbor, new);
+
+  return;
+}
+
+static void
+unset_pce_neighbor (u_int16_t type, u_int32_t domain,
+                    struct ospf_pce_info *pce)
+{
+  struct listnode *node;
+  struct ri_pce_subtlv_neighbor *old = NULL;
+  int found = 0;
+
+  /* Search the corresponding node */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_neighbor, node, old))
+    {
+      if ((old->type == htons (type)) && (old->value == htonl (domain)))
+        {
+          found = 1;
+          break;
+        }
+    }
+
+  /* if found remove it */
+  if (found)
+    {
+      listnode_delete (pce->pce_neighbor, old);
+
+      /* Avoid misjudgement in the next lookup. */
+      if (listcount (pce->pce_neighbor) == 0)
+        pce->pce_neighbor->head = pce->pce_neighbor->tail = NULL;
+
+      /* Finally free the old domain */
+      XFREE (MTYPE_OSPF_PCE_PARAMS, old);
+    }
+}
+
+static void
+set_pce_cap_flag (u_int32_t cap, struct ospf_pce_info *pce)
+{
+
+  /* Enable PCE Info */
+  pce->pce_header.header.type = htons (RI_TLV_PCE);
+  /* Set PCE Capabilities flag */
+  pce->pce_cap_flag.header.type = htons (RI_PCE_SUBTLV_CAP_FLAG);
+  pce->pce_cap_flag.header.length = htons (RI_TLV_LENGTH);
+  pce->pce_cap_flag.value = htonl (cap);
+
+  return;
+}
+
+
+static void
+unset_param (struct ri_tlv_header *tlv)
+{
+
+  tlv->type = 0;
+  /* Fill the Value to 0 */
+  memset ((tlv + RI_TLV_HDR_SIZE), 0, RI_TLV_BODY_SIZE (tlv));
+  tlv->length = 0;
+
+  return;
+}
+
+static void
+initialize_params (struct ospf_router_info *ori)
+{
+  u_int32_t cap;
+  struct ospf *top;
+
+  /*
+   * Initialize default Router Information Capabilities.
+   */
+  cap = 0;
+#ifdef HAVE_OSPF_TE
+  cap = cap | RI_TE_SUPPORT;
+#endif /* HAVE_OSPF_TE */
+
+  set_router_info_capabilities (&ori->router_cap, cap);
+
+  /* If Area address is not null and exist, retrieve corresponding structure */
+  top = ospf_lookup ();
+  zlog_info ("RI-> Initialize Router Info for %s scope within area %s",
+             OspfRI.scope == OSPF_OPAQUE_AREA_LSA ? "Area" : "AS",
+             inet_ntoa (OspfRI.area_id));
+
+  /* Try to get the Area context at this step. Do it latter if not available */
+  if ((OspfRI.scope == OSPF_OPAQUE_AREA_LSA) && (OspfRI.area == NULL))
+    OspfRI.area = ospf_area_lookup_by_area_id (top, OspfRI.area_id);
+
+  /*
+   * Initialize default PCE Information values
+   */
+  /* PCE address == OSPF Router ID */
+  set_pce_address (top->router_id, &ori->pce_info);
+
+  /* PCE scope */
+  cap = 7;                      /* Set L, R and Rd bits to one = intra & inter-area path computation */
+  set_pce_path_scope (cap, &ori->pce_info);
+
+  /* PCE Capabilities */
+  cap =
+    PCE_CAP_BIDIRECTIONAL | PCE_CAP_DIVERSE_PATH | PCE_CAP_OBJECTIVES |
+    PCE_CAP_ADDITIVE | PCE_CAP_MULTIPLE_REQ;
+  set_pce_cap_flag (cap, &ori->pce_info);
+
+  /* Finally compute PCE header */
+  set_pce_header (&ori->pce_info);
+
+  return;
+}
+
+static int
+is_mandated_params_set (struct ospf_router_info ori)
+{
+  int rc = 0;
+
+  if (ntohs (ori.router_cap.header.type) == 0)
+    goto out;
+
+  if ((ntohs (ori.pce_info.pce_header.header.type) == RI_TLV_PCE)
+      && (ntohs (ori.pce_info.pce_address.header.type) == 0)
+      && (ntohs (ori.pce_info.pce_cap_flag.header.type) == 0))
+    goto out;
+
+  rc = 1;
+
+out:
+  return rc;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are callback functions against generic Opaque-LSAs handling.
+ *------------------------------------------------------------------------*/
+static void
+ospf_router_info_ism_change (struct ospf_interface *oi, int old_state)
+{
+  /* So far, nothing to do here. */
+  return;
+
+}
+
+static void
+ospf_router_info_nsm_change (struct ospf_neighbor *nbr, int old_state)
+{
+
+  /* So far, nothing to do here. */
+  return;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are OSPF protocol processing functions for ROUTER INFORMATION
+ *------------------------------------------------------------------------*/
+
+static void
+build_tlv_header (struct stream *s, struct ri_tlv_header *tlvh)
+{
+
+  stream_put (s, tlvh, sizeof (struct ri_tlv_header));
+  return;
+}
+
+static void
+build_tlv (struct stream *s, struct ri_tlv_header *tlvh)
+{
+
+  if (ntohs (tlvh->type) != 0)
+    {
+      build_tlv_header (s, tlvh);
+      stream_put (s, tlvh + 1, RI_TLV_BODY_SIZE (tlvh));
+    }
+  return;
+}
+
+static void
+ospf_router_info_lsa_body_set (struct stream *s)
+{
+
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *domain;
+  struct ri_pce_subtlv_neighbor *neighbor;
+
+  /* Build Router Information TLV */
+  build_tlv (s, &OspfRI.router_cap.header);
+
+  /* Add RI PCE TLV if it is set */
+  /* Compute PCE Info header first */
+  if ((set_pce_header (&OspfRI.pce_info)) != 0)
+    {
+
+      /* Build PCE TLV */
+      build_tlv_header (s, &OspfRI.pce_info.pce_header.header);
+
+      /* Build PCE address sub-tlv */
+      build_tlv (s, &OspfRI.pce_info.pce_address.header);
+
+      /* Build PCE path scope sub-tlv */
+      build_tlv (s, &OspfRI.pce_info.pce_scope.header);
+
+      /* Build PCE domain sub-tlv */
+      for (ALL_LIST_ELEMENTS_RO (OspfRI.pce_info.pce_domain, node, domain))
+        build_tlv (s, &domain->header);
+
+      /* Build PCE neighbor sub-tlv */
+      for (ALL_LIST_ELEMENTS_RO
+           (OspfRI.pce_info.pce_neighbor, node, neighbor))
+        build_tlv (s, &neighbor->header);
+
+      /* Build PCE cap flag sub-tlv */
+      build_tlv (s, &OspfRI.pce_info.pce_cap_flag.header);
+    }
+
+  return;
+}
+
+/* Create new opaque-LSA. */
+static struct ospf_lsa *
+ospf_router_info_lsa_new ()
+{
+  struct ospf *top;
+  struct stream *s;
+  struct lsa_header *lsah;
+  struct ospf_lsa *new = NULL;
+  u_char options, lsa_type;
+  struct in_addr lsa_id;
+  u_int32_t tmp;
+  u_int16_t length;
+
+  /* Create a stream for LSA. */
+  if ((s = stream_new (OSPF_MAX_LSA_SIZE)) == NULL)
+    {
+      zlog_warn ("ospf_router_info_lsa_new: stream_new() ?");
+      goto out;
+    }
+  lsah = (struct lsa_header *) STREAM_DATA (s);
+
+  options = OSPF_OPTION_E;      /* Enable AS external as we flood RI with Opaque Type 11 */
+  options |= OSPF_OPTION_O;     /* Don't forget this :-) */
+
+  lsa_type = OspfRI.scope;
+  /* LSA ID == 0 for Router Information see RFC 4970 */
+  tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_ROUTER_INFORMATION_LSA, 0);
+  lsa_id.s_addr = htonl (tmp);
+
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    zlog_debug
+      ("LSA[Type%d:%s]: Create an Opaque-LSA/ROUTER INFORMATION instance",
+       lsa_type, inet_ntoa (lsa_id));
+
+  top = ospf_lookup ();
+
+  /* Set opaque-LSA header fields. */
+  lsa_header_set (s, options, lsa_type, lsa_id, top->router_id);
+
+  /* Set opaque-LSA body fields. */
+  ospf_router_info_lsa_body_set (s);
+
+  /* Set length. */
+  length = stream_get_endp (s);
+  lsah->length = htons (length);
+
+  /* Now, create an OSPF LSA instance. */
+  if ((new = ospf_lsa_new ()) == NULL)
+    {
+      zlog_warn ("ospf_router_info_lsa_new: ospf_lsa_new() ?");
+      stream_free (s);
+      goto out;
+    }
+  if ((new->data = ospf_lsa_data_new (length)) == NULL)
+    {
+      zlog_warn ("ospf_router_info_lsa_new: ospf_lsa_data_new() ?");
+      ospf_lsa_unlock (&new);
+      new = NULL;
+      stream_free (s);
+      goto out;
+    }
+
+  new->area = OspfRI.area;      /* Area must be null if the Opaque type is AS scope, fulfill otherwise */
+
+  SET_FLAG (new->flags, OSPF_LSA_SELF);
+  memcpy (new->data, lsah, length);
+  stream_free (s);
+
+out:return new;
+}
+
+static int
+ospf_router_info_lsa_originate1 (void *arg)
+{
+  struct ospf_lsa *new;
+  struct ospf *top;
+  struct ospf_area *area;
+  int rc = -1;
+
+  /* First check if the area is known if flooding scope is Area */
+  if (OspfRI.scope == OSPF_OPAQUE_AREA_LSA)
+    {
+      area = (struct ospf_area *) arg;
+      if (area->area_id.s_addr != OspfRI.area_id.s_addr)
+        {
+          zlog_debug
+            ("RI -> This is not the Router Information Area. Stop processing");
+          goto out;
+        }
+      OspfRI.area = area;
+    }
+
+  /* Create new Opaque-LSA/ROUTER INFORMATION instance. */
+  if ((new = ospf_router_info_lsa_new ()) == NULL)
+    {
+      zlog_warn
+        ("ospf_router_info_lsa_originate1: ospf_router_info_lsa_new() ?");
+      goto out;
+    }
+
+  /* Get ospf info */
+  top = ospf_lookup ();
+
+  /* Install this LSA into LSDB. */
+  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)
+    {
+      zlog_warn ("ospf_router_info_lsa_originate1: ospf_lsa_install() ?");
+      ospf_lsa_unlock (&new);
+      goto out;
+    }
+
+  /* Now this Router Info parameter entry has associated LSA. */
+  SET_FLAG (OspfRI.flags, RIFLG_LSA_ENGAGED);
+
+  /* Update new LSA origination count. */
+  top->lsa_originate_count++;
+
+  /* Flood new LSA through AS. */
+  if (OspfRI.scope == OSPF_OPAQUE_AS_LSA)
+    ospf_flood_through_as (top, NULL /*nbr */ , new);
+  else
+    ospf_flood_through_area (OspfRI.area, NULL /*nbr */ , new);
+
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    {
+      zlog_debug ("LSA[Type%d:%s]: Originate Opaque-LSA/ROUTER INFORMATION",
+                  new->data->type, inet_ntoa (new->data->id));
+      ospf_lsa_header_dump (new->data);
+    }
+
+  rc = 0;
+out:return rc;
+}
+
+static int
+ospf_router_info_lsa_originate (void *arg)
+{
+
+  int rc = -1;
+
+  if (OspfRI.status == disabled)
+    {
+      zlog_info
+        ("ospf_router_info_lsa_originate: ROUTER INFORMATION is disabled now.");
+      rc = 0;                   /* This is not an error case. */
+      goto out;
+    }
+
+  /* Check if Router Information LSA is already engaged */
+  if (OspfRI.flags & RIFLG_LSA_ENGAGED)
+    {
+      if (OspfRI.flags & RIFLG_LSA_FORCED_REFRESH)
+        {
+          OspfRI.flags &= ~RIFLG_LSA_FORCED_REFRESH;
+          ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+        }
+    }
+  else
+    {
+      if (!is_mandated_params_set (OspfRI))
+        zlog_warn
+          ("ospf_router_info_lsa_originate: lacks mandated ROUTER INFORMATION parameters");
+
+      /* Ok, let's try to originate an LSA */
+      if (ospf_router_info_lsa_originate1 (arg) != 0)
+        goto out;
+    }
+
+  rc = 0;
+out:return rc;
+}
+
+static struct ospf_lsa *
+ospf_router_info_lsa_refresh (struct ospf_lsa *lsa)
+{
+  struct ospf_lsa *new = NULL;
+  struct ospf *top;
+
+  if (OspfRI.status == disabled)
+    {
+      /*
+       * This LSA must have flushed before due to ROUTER INFORMATION status change.
+       * It seems a slip among routers in the routing domain.
+       */
+      zlog_info
+        ("ospf_router_info_lsa_refresh: ROUTER INFORMATION is disabled now.");
+      lsa->data->ls_age = htons (OSPF_LSA_MAXAGE);      /* Flush it anyway. */
+    }
+
+  /* Verify that the Router Information ID is supported */
+  if (GET_OPAQUE_ID (ntohl (lsa->data->id.s_addr)) != 0)
+    {
+      zlog_warn
+        ("ospf_router_info_lsa_refresh: Unsupported Router Information ID");
+      goto out;
+    }
+
+  /* If the lsa's age reached to MaxAge, start flushing procedure. */
+  if (IS_LSA_MAXAGE (lsa))
+    {
+      OspfRI.flags &= ~RIFLG_LSA_ENGAGED;
+      ospf_opaque_lsa_flush_schedule (lsa);
+      goto out;
+    }
+
+  /* Create new Opaque-LSA/ROUTER INFORMATION instance. */
+  if ((new = ospf_router_info_lsa_new ()) == NULL)
+    {
+      zlog_warn
+        ("ospf_router_info_lsa_refresh: ospf_router_info_lsa_new() ?");
+      goto out;
+    }
+  new->data->ls_seqnum = lsa_seqnum_increment (lsa);
+
+  /* Install this LSA into LSDB. */
+  /* Given "lsa" will be freed in the next function. */
+  top = ospf_lookup ();
+  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)
+    {
+      zlog_warn ("ospf_router_info_lsa_refresh: ospf_lsa_install() ?");
+      ospf_lsa_unlock (&new);
+      goto out;
+    }
+
+  /* Flood updated LSA through AS or AREA depending of OspfRI.scope. */
+  if (OspfRI.scope == OSPF_OPAQUE_AS_LSA)
+    ospf_flood_through_as (top, NULL /*nbr */ , new);
+  else
+    ospf_flood_through_area (OspfRI.area, NULL /*nbr */ , new);
+
+  /* Debug logging. */
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    {
+      zlog_debug ("LSA[Type%d:%s]: Refresh Opaque-LSA/ROUTER INFORMATION",
+                  new->data->type, inet_ntoa (new->data->id));
+      ospf_lsa_header_dump (new->data);
+    }
+
+out:return new;
+}
+
+static void
+ospf_router_info_lsa_schedule (opcode_t opcode)
+{
+  struct ospf_lsa lsa;
+  struct lsa_header lsah;
+  struct ospf *top;
+  u_int32_t tmp;
+
+  memset (&lsa, 0, sizeof (lsa));
+  memset (&lsah, 0, sizeof (lsah));
+
+  zlog_debug ("RI-> LSA schedule %s%s%s",
+              opcode == REORIGINATE_THIS_LSA ? "Re-Originate" : "",
+              opcode == REFRESH_THIS_LSA ? "Refresh" : "",
+              opcode == FLUSH_THIS_LSA ? "Flush" : "");
+
+  top = ospf_lookup ();
+  if ((OspfRI.scope == OSPF_OPAQUE_AREA_LSA) && (OspfRI.area == NULL))
+    {
+      zlog_warn
+        ("ospf_router_info_lsa_schedule(): Router Info is Area scope flooding but area is not set");
+      OspfRI.area = ospf_area_lookup_by_area_id (top, OspfRI.area_id);
+    }
+  lsa.area = OspfRI.area;
+  lsa.data = &lsah;
+  lsah.type = OspfRI.scope;
+
+  /* LSA ID is set to 0 for the Router Information. See RFC 4970 */
+  tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_ROUTER_INFORMATION_LSA, 0);
+  lsah.id.s_addr = htonl (tmp);
+
+  switch (opcode)
+    {
+    case REORIGINATE_THIS_LSA:
+      if (OspfRI.scope == OSPF_OPAQUE_AREA_LSA)
+        ospf_opaque_lsa_reoriginate_schedule ((void *) OspfRI.area,
+                                              OSPF_OPAQUE_AREA_LSA,
+                                              OPAQUE_TYPE_ROUTER_INFORMATION_LSA);
+      else
+        ospf_opaque_lsa_reoriginate_schedule ((void *) top,
+                                              OSPF_OPAQUE_AS_LSA,
+                                              OPAQUE_TYPE_ROUTER_INFORMATION_LSA);
+      break;
+    case REFRESH_THIS_LSA:
+      ospf_opaque_lsa_refresh_schedule (&lsa);
+      break;
+    case FLUSH_THIS_LSA:
+      OspfRI.flags &= ~RIFLG_LSA_ENGAGED;
+      ospf_opaque_lsa_flush_schedule (&lsa);
+      break;
+    default:
+      zlog_warn ("ospf_router_info_lsa_schedule: Unknown opcode (%u)",
+                 opcode);
+      break;
+    }
+
+  return;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are vty session control functions.
+ *------------------------------------------------------------------------*/
+
+static u_int16_t
+show_vty_router_cap (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  struct ri_tlv_router_cap *top = (struct ri_tlv_router_cap *) tlvh;
+
+  if (vty != NULL)
+    vty_out (vty, "  Router Capabilities: 0x%x%s", ntohl (top->value),
+             VTY_NEWLINE);
+  else
+    zlog_debug ("    Router Capabilities: 0x%x", ntohl (top->value));
+
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_subtlv_address (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  struct ri_pce_subtlv_address *top = (struct ri_pce_subtlv_address *) tlvh;
+
+  if (ntohs (top->address.type) == PCE_ADDRESS_TYPE_IPV4)
+    {
+      if (vty != NULL)
+        vty_out (vty, "  PCE Address: %s%s", inet_ntoa (top->address.value),
+                 VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE Address: %s", inet_ntoa (top->address.value));
+    }
+  else
+    {
+      /* TODO: Add support to IPv6 with inet_ntop() */
+      if (vty != NULL)
+        vty_out (vty, "  PCE Address: 0x%x%s",
+                 ntohl (top->address.value.s_addr), VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE Address: 0x%x",
+                    ntohl (top->address.value.s_addr));
+    }
+
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_subtlv_path_scope (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  struct ri_pce_subtlv_path_scope *top =
+    (struct ri_pce_subtlv_path_scope *) tlvh;
+
+  if (vty != NULL)
+    vty_out (vty, "  PCE Path Scope: 0x%x%s", ntohl (top->value),
+             VTY_NEWLINE);
+  else
+    zlog_debug ("    PCE Path Scope: 0x%x", ntohl (top->value));
+
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_subtlv_domain (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  struct ri_pce_subtlv_domain *top = (struct ri_pce_subtlv_domain *) tlvh;
+  struct in_addr tmp;
+
+  if (ntohs (top->type) == PCE_DOMAIN_TYPE_AREA)
+    {
+      tmp.s_addr = top->value;
+      if (vty != NULL)
+        vty_out (vty, "  PCE domain Area: %s%s", inet_ntoa (tmp),
+                 VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE domain Area: %s", inet_ntoa (tmp));
+    }
+  else
+    {
+      if (vty != NULL)
+        vty_out (vty, "  PCE domain AS: %d%s", ntohl (top->value),
+                 VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE domain AS: %d", ntohl (top->value));
+    }
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_subtlv_neighbor (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+
+  struct ri_pce_subtlv_neighbor *top = (struct ri_pce_subtlv_neighbor *) tlvh;
+  struct in_addr tmp;
+
+  if (ntohs (top->type) == PCE_DOMAIN_TYPE_AREA)
+    {
+      tmp.s_addr = top->value;
+      if (vty != NULL)
+        vty_out (vty, "  PCE neighbor Area: %s%s", inet_ntoa (tmp),
+                 VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE neighbor Area: %s", inet_ntoa (tmp));
+    }
+  else
+    {
+      if (vty != NULL)
+        vty_out (vty, "  PCE neighbor AS: %d%s", ntohl (top->value),
+                 VTY_NEWLINE);
+      else
+        zlog_debug ("    PCE neighbor AS: %d", ntohl (top->value));
+    }
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_subtlv_cap_flag (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  struct ri_pce_subtlv_cap_flag *top = (struct ri_pce_subtlv_cap_flag *) tlvh;
+
+  if (vty != NULL)
+    vty_out (vty, "  PCE Capabilities Flag: 0x%x%s", ntohl (top->value),
+             VTY_NEWLINE);
+  else
+    zlog_debug ("    PCE Capabilities Flag: 0x%x", ntohl (top->value));
+
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_unknown_tlv (struct vty *vty, struct ri_tlv_header *tlvh)
+{
+  if (vty != NULL)
+    vty_out (vty, "  Unknown TLV: [type(0x%x), length(0x%x)]%s",
+             ntohs (tlvh->type), ntohs (tlvh->length), VTY_NEWLINE);
+  else
+    zlog_debug ("    Unknown TLV: [type(0x%x), length(0x%x)]",
+                ntohs (tlvh->type), ntohs (tlvh->length));
+
+  return RI_TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_pce_info (struct vty *vty, struct ri_tlv_header *ri, uint32_t total)
+{
+  struct ri_tlv_header *tlvh;
+  u_int16_t sum = 0;
+
+  for (tlvh = ri; sum < total; tlvh = RI_TLV_HDR_NEXT (tlvh))
+    {
+      switch (ntohs (tlvh->type))
+        {
+        case RI_PCE_SUBTLV_ADDRESS:
+          sum += show_vty_pce_subtlv_address (vty, tlvh);
+          break;
+        case RI_PCE_SUBTLV_PATH_SCOPE:
+          sum += show_vty_pce_subtlv_path_scope (vty, tlvh);
+          break;
+        case RI_PCE_SUBTLV_DOMAIN:
+          sum += show_vty_pce_subtlv_domain (vty, tlvh);
+          break;
+        case RI_PCE_SUBTLV_NEIGHBOR:
+          sum += show_vty_pce_subtlv_neighbor (vty, tlvh);
+          break;
+        case RI_PCE_SUBTLV_CAP_FLAG:
+          sum += show_vty_pce_subtlv_cap_flag (vty, tlvh);
+          break;
+        default:
+          sum += show_vty_unknown_tlv (vty, tlvh);
+          break;
+        }
+    }
+  return sum;
+}
+
+static void
+ospf_router_info_show_info (struct vty *vty, struct ospf_lsa *lsa)
+{
+  struct lsa_header *lsah = (struct lsa_header *) lsa->data;
+  struct ri_tlv_header *tlvh;
+  u_int16_t length = 0, sum = 0;
+
+  /* Initialize TLV browsing */
+  length = ntohs (lsah->length) - OSPF_LSA_HEADER_SIZE;
+
+  for (tlvh = RI_TLV_HDR_TOP (lsah); sum < length;
+       tlvh = RI_TLV_HDR_NEXT (tlvh))
+    {
+      switch (ntohs (tlvh->type))
+        {
+        case RI_TLV_CAPABILITIES:
+          sum += show_vty_router_cap (vty, tlvh);
+          break;
+        case RI_TLV_PCE:
+          tlvh++;
+          sum += RI_TLV_HDR_SIZE;
+          sum += show_vty_pce_info (vty, tlvh, length - sum);
+          break;
+        default:
+          sum += show_vty_unknown_tlv (vty, tlvh);
+          break;
+        }
+    }
+
+  return;
+}
+
+static void
+ospf_router_info_config_write_router (struct vty *vty)
+{
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *domain;
+  struct ri_pce_subtlv_neighbor *neighbor;
+  struct in_addr tmp;
+
+  if (OspfRI.status == enabled)
+    {
+      if (OspfRI.scope == OSPF_OPAQUE_AS_LSA)
+        vty_out (vty, " router-info as%s", VTY_NEWLINE);
+      else
+        vty_out (vty, " router-info area %s%s", inet_ntoa (OspfRI.area_id),
+                 VTY_NEWLINE);
+
+      if (pce->pce_address.header.type != 0)
+        vty_out (vty, "  pce address %s%s",
+                 inet_ntoa (pce->pce_address.address.value), VTY_NEWLINE);
+
+      if (pce->pce_cap_flag.header.type != 0)
+        vty_out (vty, "  pce flag 0x%x%s", ntohl (pce->pce_cap_flag.value),
+                 VTY_NEWLINE);
+
+      for (ALL_LIST_ELEMENTS_RO (pce->pce_domain, node, domain))
+        {
+          if (domain->header.type != 0)
+            {
+              if (domain->type == PCE_DOMAIN_TYPE_AREA)
+                {
+                  tmp.s_addr = domain->value;
+                  vty_out (vty, "  pce domain area %s%s", inet_ntoa (tmp),
+                           VTY_NEWLINE);
+                }
+              else
+                {
+                  vty_out (vty, "  pce domain as %d%s", ntohl (domain->value),
+                           VTY_NEWLINE);
+                }
+            }
+        }
+
+      for (ALL_LIST_ELEMENTS_RO (pce->pce_neighbor, node, neighbor))
+        {
+          if (neighbor->header.type != 0)
+            {
+              if (neighbor->type == PCE_DOMAIN_TYPE_AREA)
+                {
+                  tmp.s_addr = neighbor->value;
+                  vty_out (vty, "  pce neighbor area %s%s", inet_ntoa (tmp),
+                           VTY_NEWLINE);
+                }
+              else
+                {
+                  vty_out (vty, "  pce neighbor as %d%s",
+                           ntohl (neighbor->value), VTY_NEWLINE);
+                }
+            }
+        }
+
+      if (pce->pce_scope.header.type != 0)
+        vty_out (vty, "  pce scope 0x%x%s",
+                 ntohl (OspfRI.pce_info.pce_scope.value), VTY_NEWLINE);
+    }
+  return;
+}
+
+/*------------------------------------------------------------------------*
+ * Followings are vty command functions.
+ *------------------------------------------------------------------------*/
+
+DEFUN (router_info,
+       router_info_area_cmd,
+       "router-info area A.B.C.D",
+       OSPF_RI_STR
+       "Enable the Router Information functionality with Area flooding scope\n"
+       "OSPF area ID in IP format")
+{
+
+  u_int8_t scope;
+
+  if (OspfRI.status == enabled)
+    return CMD_SUCCESS;
+
+  /* Check and get Area value if present */
+  if (argc == 1)
+    {
+      if (!inet_aton (argv[0], &OspfRI.area_id))
+        {
+          vty_out (vty, "Please specify Router Info Area by A.B.C.D%s",
+                   VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+      scope = OSPF_OPAQUE_AREA_LSA;
+    }
+  else
+    {
+      OspfRI.area_id.s_addr = 0;
+      scope = OSPF_OPAQUE_AS_LSA;
+    }
+
+  /* First start to register Router Information callbacks */
+  if ((ospf_router_info_register (scope)) != 0)
+    {
+      zlog_warn ("Enable to register Router Information callbacks. Abort!");
+      return CMD_WARNING;
+    }
+
+  OspfRI.status = enabled;
+
+  if (IS_DEBUG_OSPF_EVENT)
+    zlog_debug ("RI-> Router Information (%s flooding): OFF -> ON",
+                 OspfRI.scope == OSPF_OPAQUE_AREA_LSA ? "Area" : "AS");
+
+  /*
+   * Following code is intended to handle two cases;
+   *
+   * 1) Router Information was disabled at startup time, but now become enabled.
+   * 2) Router Information was once enabled then disabled, and now enabled again.
+   */
+
+  initialize_params (&OspfRI);
+
+  /* Refresh RI LSA if already engaged */
+  if (OspfRI.flags & RIFLG_LSA_ENGAGED)
+    {
+      zlog_debug ("RI-> Initial origination following configuration");
+      ospf_router_info_lsa_schedule (REORIGINATE_THIS_LSA);
+    }
+  return CMD_SUCCESS;
+
+}
+
+ALIAS (router_info,
+       router_info_as_cmd,
+       "router-info as",
+       OSPF_RI_STR
+       "Enable the Router Information functionality with AS flooding scope\n")
+
+DEFUN (no_router_info,
+       no_router_info_cmd,
+       "no router-info",
+       NO_STR
+       "Disable the Router Information functionality\n")
+{
+
+  if (OspfRI.status == disabled)
+    return CMD_SUCCESS;
+
+  if (IS_DEBUG_OSPF_EVENT)
+    zlog_debug ("RI-> Router Information: ON -> OFF");
+
+  if (OspfRI.flags & RIFLG_LSA_ENGAGED)
+    ospf_router_info_lsa_schedule (FLUSH_THIS_LSA);
+
+  /* Unregister the callbacks */
+  ospf_router_info_unregister ();
+
+  OspfRI.status = disabled;
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (pce_address,
+       pce_address_cmd,
+       "pce address A.B.C.D",
+       PCE_STR
+       "Stable IP address of the PCE\n"
+       "PCE address in IPv4 address format\n")
+{
+  struct in_addr value;
+  struct ospf_pce_info *pi = &OspfRI.pce_info;
+
+  if (!inet_aton (argv[0], &value))
+    {
+      vty_out (vty, "Please specify PCE Address by A.B.C.D%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (ntohs (pi->pce_address.header.type) == 0
+      || ntohl (pi->pce_address.address.value.s_addr) != ntohl (value.s_addr))
+    {
+
+      set_pce_address (value, pi);
+
+      /* Refresh RI LSA if already engaged */
+      if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+        ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_pce_address,
+       no_pce_address_cmd,
+       "no pce address",
+       NO_STR
+       PCE_STR
+       "Disable PCE address\n")
+{
+
+  unset_param (&OspfRI.pce_info.pce_address.header);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (pce_path_scope,
+       pce_path_scope_cmd,
+       "pce scope BITPATTERN",
+       PCE_STR
+       "Path scope visibilities of the PCE for path computation\n"
+       "32-bit Hexadecimal value\n")
+{
+  uint32_t scope;
+  struct ospf_pce_info *pi = &OspfRI.pce_info;
+
+  if (sscanf (argv[0], "0x%x", &scope) != 1)
+    {
+      vty_out (vty, "pce_path_scope: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (ntohl (pi->pce_scope.header.type) == 0 || scope != pi->pce_scope.value)
+    {
+      set_pce_path_scope (scope, pi);
+
+      /* Refresh RI LSA if already engaged */
+      if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+        ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_pce_path_scope,
+       no_pce_path_scope_cmd,
+       "no pce scope",
+       NO_STR
+       PCE_STR
+       "Disable PCE path scope\n")
+{
+
+  unset_param (&OspfRI.pce_info.pce_address.header);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (pce_domain,
+       pce_domain_cmd,
+       "pce domain as <0-65535>",
+       PCE_STR
+       "Configure PCE domain AS number\n"
+       "AS number where the PCE as visibilities for path computation\n"
+       "AS number in decimal <0-65535>\n")
+{
+
+  uint32_t as;
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *domain;
+
+  if (sscanf (argv[0], "%d", &as) != 1)
+    {
+      vty_out (vty, "pce_domain: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Check if the domain is not already in the domain list */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_domain, node, domain))
+    {
+      if (ntohl (domain->header.type) == 0 && as == domain->value)
+        goto out;
+    }
+
+  /* Create new domain if not found */
+  set_pce_domain (PCE_DOMAIN_TYPE_AS, as, pce);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+out:return CMD_SUCCESS;
+}
+
+DEFUN (no_pce_domain,
+       no_pce_domain_cmd,
+       "no pce domain as <0-65535>",
+       NO_STR
+       PCE_STR
+       "Disable PCE domain AS number\n"
+       "AS number where the PCE as visibilities for path computation\n"
+       "AS number in decimal <0-65535>\n")
+{
+
+  uint32_t as;
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+
+  if (sscanf (argv[0], "%d", &as) != 1)
+    {
+      vty_out (vty, "no_pce_domain: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Unset corresponding PCE domain */
+  unset_pce_domain (PCE_DOMAIN_TYPE_AS, as, pce);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (pce_neigbhor,
+       pce_neighbor_cmd,
+       "pce neighbor as <0-65535>",
+       PCE_STR
+       "Configure PCE neighbor domain AS number\n"
+       "AS number of PCE neighbors\n"
+       "AS number in decimal <0-65535>\n")
+{
+
+  uint32_t as;
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+  struct listnode *node;
+  struct ri_pce_subtlv_neighbor *neighbor;
+
+  if (sscanf (argv[0], "%d", &as) != 1)
+    {
+      vty_out (vty, "pce_neighbor: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Check if the domain is not already in the domain list */
+  for (ALL_LIST_ELEMENTS_RO (pce->pce_neighbor, node, neighbor))
+    {
+      if (ntohl (neighbor->header.type) == 0 && as == neighbor->value)
+        goto out;
+    }
+
+  /* Create new domain if not found */
+  set_pce_neighbor (PCE_DOMAIN_TYPE_AS, as, pce);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+out:return CMD_SUCCESS;
+}
+
+DEFUN (no_pce_neighbor,
+       no_pce_neighbor_cmd,
+       "no pce neighbor as <0-65535>",
+       NO_STR
+       PCE_STR
+       "Disable PCE neighbor AS number\n"
+       "AS number of PCE neighbor\n"
+       "AS number in decimal <0-65535>\n")
+{
+
+  uint32_t as;
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+
+  if (sscanf (argv[0], "%d", &as) != 1)
+    {
+      vty_out (vty, "no_pce_neighbor: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Unset corresponding PCE domain */
+  unset_pce_neighbor (PCE_DOMAIN_TYPE_AS, as, pce);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (pce_cap_flag,
+       pce_cap_flag_cmd,
+       "pce flag BITPATTERN",
+       PCE_STR
+       "Capabilities of the PCE for path computation\n"
+       "32-bit Hexadecimal value\n")
+{
+
+  uint32_t cap;
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+
+  if (sscanf (argv[0], "0x%x", &cap) != 1)
+    {
+      vty_out (vty, "pce_cap_flag: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (ntohl (pce->pce_cap_flag.header.type) == 0
+      || cap != pce->pce_cap_flag.value)
+    {
+      set_pce_cap_flag (cap, pce);
+
+      /* Refresh RI LSA if already engaged */
+      if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+        ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_pce_cap_flag,
+       no_pce_cap_flag_cmd,
+       "no pce flag",
+       NO_STR
+       PCE_STR
+       "Disable PCE capabilities\n")
+{
+
+  unset_param (&OspfRI.pce_info.pce_cap_flag.header);
+
+  /* Refresh RI LSA if already engaged */
+  if ((OspfRI.status == enabled) && (OspfRI.flags & RIFLG_LSA_ENGAGED))
+    ospf_router_info_lsa_schedule (REFRESH_THIS_LSA);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_ip_ospf_router_info,
+       show_ip_ospf_router_info_cmd,
+       "show ip ospf router-info",
+       SHOW_STR
+       IP_STR
+       OSPF_STR
+       "Router Information\n")
+{
+
+  if (OspfRI.status == enabled)
+    {
+      vty_out (vty, "--- Router Information parameters ---%s", VTY_NEWLINE);
+      show_vty_router_cap (vty, &OspfRI.router_cap.header);
+    }
+  else
+    {
+      if (vty != NULL)
+        vty_out (vty, "  Router Information is disabled on this router%s", VTY_NEWLINE);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_ip_opsf_router_info_pce,
+       show_ip_ospf_router_info_pce_cmd,
+       "show ip ospf router-info pce",
+       SHOW_STR
+       IP_STR
+       OSPF_STR
+       "Router Information\n"
+       "PCE information\n")
+{
+
+  struct ospf_pce_info *pce = &OspfRI.pce_info;
+  struct listnode *node;
+  struct ri_pce_subtlv_domain *domain;
+  struct ri_pce_subtlv_neighbor *neighbor;
+
+  if (OspfRI.status == enabled)
+    {
+      vty_out (vty, "--- PCE parameters ---%s", VTY_NEWLINE);
+
+      if (pce->pce_address.header.type != 0)
+        show_vty_pce_subtlv_address (vty, &pce->pce_address.header);
+
+      if (pce->pce_scope.header.type != 0)
+        show_vty_pce_subtlv_path_scope (vty, &pce->pce_scope.header);
+
+      for (ALL_LIST_ELEMENTS_RO (pce->pce_domain, node, domain))
+        {
+          if (domain->header.type != 0)
+            show_vty_pce_subtlv_domain (vty, &domain->header);
+        }
+
+      for (ALL_LIST_ELEMENTS_RO (pce->pce_neighbor, node, neighbor))
+        {
+          if (neighbor->header.type != 0)
+            show_vty_pce_subtlv_neighbor (vty, &neighbor->header);
+        }
+
+      if (pce->pce_cap_flag.header.type != 0)
+        show_vty_pce_subtlv_cap_flag (vty, &pce->pce_cap_flag.header);
+
+    }
+  else
+    {
+      vty_out (vty, "  Router Information is disabled on this router%s",
+               VTY_NEWLINE);
+    }
+
+  return CMD_SUCCESS;
+}
+
+/* Install new CLI commands */
+static void
+ospf_router_info_register_vty (void)
+{
+  install_element (VIEW_NODE, &show_ip_ospf_router_info_cmd);
+  install_element (VIEW_NODE, &show_ip_ospf_router_info_pce_cmd);
+  install_element (ENABLE_NODE, &show_ip_ospf_router_info_cmd);
+  install_element (ENABLE_NODE, &show_ip_ospf_router_info_pce_cmd);
+
+  install_element (OSPF_NODE, &router_info_area_cmd);
+  install_element (OSPF_NODE, &router_info_as_cmd);
+  install_element (OSPF_NODE, &no_router_info_cmd);
+  install_element (OSPF_NODE, &pce_address_cmd);
+  install_element (OSPF_NODE, &pce_path_scope_cmd);
+  install_element (OSPF_NODE, &pce_domain_cmd);
+  install_element (OSPF_NODE, &no_pce_domain_cmd);
+  install_element (OSPF_NODE, &pce_neighbor_cmd);
+  install_element (OSPF_NODE, &no_pce_neighbor_cmd);
+  install_element (OSPF_NODE, &pce_cap_flag_cmd);
+
+  return;
+}
diff --git a/ospfd/ospf_ri.h b/ospfd/ospf_ri.h
new file mode 100644
index 0000000..c507434
--- /dev/null
+++ b/ospfd/ospf_ri.h
@@ -0,0 +1,191 @@
+/*
+ * This is an implementation of RFC4970 Router Information
+ * with support of RFC5088 PCE Capabilites announcement
+ *
+ * Module name: Router Information
+ * Version:     0.99.22
+ * Created:     2012-02-01 by Olivier Dugeon
+ * Copyright (C) 2012 Orange Labs http://www.orange.com/
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ * 
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _ZEBRA_OSPF_ROUTER_INFO_H
+#define _ZEBRA_OSPF_ROUTER_INFO_H
+
+/*
+ * Opaque LSA's link state ID for Router Information is
+ * structured as follows.
+ *
+ *        24       16        8        0
+ * +--------+--------+--------+--------+
+ * |    1   |  MBZ   |........|........|
+ * +--------+--------+--------+--------+
+ * |<-Type->|<Resv'd>|<-- Instance --->|
+ *
+ *
+ * Type:      IANA has assigned '4' for Router Information.
+ * MBZ:       Reserved, must be set to zero.
+ * Instance:  User may select an arbitrary 16-bit value.
+ *
+ */
+
+/*
+ *        24       16        8        0
+ * +--------+--------+--------+--------+ ---
+ * |   LS age        |Options | 9,10,11|  A
+ * +--------+--------+--------+--------+  |
+ * |    4   |   0    |    Instance     |  |
+ * +--------+--------+--------+--------+  |
+ * |        Advertising router         |  |  Standard (Opaque) LSA header;
+ * +--------+--------+--------+--------+  |  Type 9,10 or 11 are used.
+ * |        LS sequence number         |  |
+ * +--------+--------+--------+--------+  |
+ * |   LS checksum   |     Length      |  V
+ * +--------+--------+--------+--------+ ---
+ * |      Type       |     Length      |  A
+ * +--------+--------+--------+--------+  |  TLV part for Router Information; Values might be
+ * |              Values ...           |  V  structured as a set of sub-TLVs.
+ * +--------+--------+--------+--------+ ---
+ */
+
+/*
+ * Following section defines TLV (tag, length, value) structures,
+ * used for Router Information.
+ */
+struct ri_tlv_header
+{
+  u_int16_t type;               /* RI_TLV_XXX (see below) */
+  u_int16_t length;             /* Value portion only, in byte */
+};
+
+#define RI_TLV_HDR_SIZE (sizeof (struct ri_tlv_header))
+#define RI_TLV_BODY_SIZE(tlvh) (ROUNDUP (ntohs ((tlvh)->length), sizeof (u_int32_t)))
+#define RI_TLV_SIZE(tlvh) (RI_TLV_HDR_SIZE + RI_TLV_BODY_SIZE(tlvh))
+#define RI_TLV_HDR_TOP(lsah) (struct ri_tlv_header *)((char *)(lsah) + OSPF_LSA_HEADER_SIZE)
+#define RI_TLV_HDR_NEXT(tlvh) (struct ri_tlv_header *)((char *)(tlvh) + RI_TLV_SIZE(tlvh))
+
+/*
+ * Following section defines TLV body parts.
+ */
+
+/* Up to now, 8 code point have been assigned to Router Information */
+/* Only type 1 Router Capabilities and 6 PCE are supported with this code */
+#define RI_IANA_MAX_TYPE		8
+
+/* RFC4970: Router Information Capabilities TLV */ /* Mandatory */
+#define RI_TLV_CAPABILITIES		1
+
+struct ri_tlv_router_cap
+{
+  struct ri_tlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t value;
+};
+
+#define RI_GRACE_RESTART	0x01
+#define RI_GRACE_HELPER		0x02
+#define RI_STUB_SUPPORT		0x04
+#define RI_TE_SUPPORT		0x08
+#define RI_P2P_OVER_LAN		0x10
+#define RI_TE_EXPERIMENTAL	0x20
+
+#define RI_TLV_LENGTH		4
+
+/* RFC5088: PCE Capabilities TLV */ /* Optional */
+/* RI PCE TLV */
+#define RI_TLV_PCE			6
+
+struct ri_tlv_pce
+{
+  struct ri_tlv_header header;
+/* A set of PCE-sub-TLVs will follow. */
+};
+
+/* PCE Address Sub-TLV */ /* Mandatory */
+#define	RI_PCE_SUBTLV_ADDRESS		1
+struct ri_pce_subtlv_address
+{
+  struct ri_tlv_header header;  /* Type = 1; Length is 8 (IPv4) or 20 (IPv6) bytes. */
+#define	PCE_ADDRESS_LENGTH_IPV4		8
+#define	PCE_ADDRESS_LENGTH_IPV6		20
+  struct
+  {
+    u_int16_t type;             /* Address type: 1 = IPv4, 2 = IPv6 */
+#define	PCE_ADDRESS_TYPE_IPV4		1
+#define	PCE_ADDRESS_TYPE_IPV6		2
+    u_int16_t reserved;
+    struct in_addr value;      /* PCE address */
+  } address;
+};
+
+/* PCE Path-Scope Sub-TLV */ /* Mandatory */
+#define	RI_PCE_SUBTLV_PATH_SCOPE	2
+struct ri_pce_subtlv_path_scope
+{
+  struct ri_tlv_header header; /* Type = 2; Length = 4 bytes. */
+  u_int32_t value;              /* L, R, Rd, S, Sd, Y, PrefL, PrefR, PrefS and PrefY bits see RFC5088 page 9 */
+};
+
+/* PCE Domain Sub-TLV */ /* Optional */
+#define	RI_PCE_SUBTLV_DOMAIN		3
+
+#define	PCE_DOMAIN_TYPE_AREA		1
+#define	PCE_DOMAIN_TYPE_AS			2
+
+struct ri_pce_subtlv_domain
+{
+  struct ri_tlv_header header;  /* Type = 3; Length = 8 bytes. */
+  u_int16_t type;               /* Domain type: 1 = OSPF Area ID, 2 = AS Number */
+  u_int16_t reserved;
+  u_int32_t value;
+};
+
+/* PCE Neighbor Sub-TLV */ /* Mandatory if R or S bit is set */
+#define RI_PCE_SUBTLV_NEIGHBOR		4
+struct ri_pce_subtlv_neighbor
+{
+  struct ri_tlv_header header;  /* Type = 4; Length = 8 bytes. */
+  u_int16_t type;               /* Domain type: 1 = OSPF Area ID, 2 = AS Number */
+  u_int16_t reserved;
+  u_int32_t value;
+};
+
+/* PCE Capabilities Flags Sub-TLV */ /* Optional */
+#define RI_PCE_SUBTLV_CAP_FLAG		5
+
+#define PCE_CAP_GMPLS_LINK		0x0001
+#define PCE_CAP_BIDIRECTIONAL	0x0002
+#define PCE_CAP_DIVERSE_PATH	0x0004
+#define PCE_CAP_LOAD_BALANCE	0x0008
+#define PCE_CAP_SYNCHRONIZED	0x0010
+#define PCE_CAP_OBJECTIVES		0x0020
+#define PCE_CAP_ADDITIVE		0x0040
+#define PCE_CAP_PRIORIZATION	0x0080
+#define PCE_CAP_MULTIPLE_REQ	0x0100
+
+struct ri_pce_subtlv_cap_flag
+{
+  struct ri_tlv_header header;  /* Type = 5; Length = n x 4 bytes. */
+  u_int32_t value;
+};
+
+/* Prototypes. */
+extern int ospf_router_info_init (void);
+extern void ospf_router_info_term (void);
+
+#endif /* _ZEBRA_OSPF_ROUTER_INFO_H */
diff --git a/ospfd/ospf_te.c b/ospfd/ospf_te.c
index c605ce6..980a79d 100644
--- a/ospfd/ospf_te.c
+++ b/ospfd/ospf_te.c
@@ -1,8 +1,11 @@
 /*
- * This is an implementation of draft-katz-yeung-ospf-traffic-06.txt
+ * This is an implementation of RFC3630
  * Copyright (C) 2001 KDD R&D Laboratories, Inc.
  * http://www.kddlabs.co.jp/
  *
+ * Copyright (C) 2012 Orange Labs
+ * http://www.orange.com
+ *
  * This file is part of GNU Zebra.
  *
  * GNU Zebra is free software; you can redistribute it and/or modify it
@@ -21,10 +24,11 @@
  * 02111-1307, USA.
  */
 
-/***** MTYPE definition is not reflected to "memory.h" yet. *****/
-#define MTYPE_OSPF_MPLS_TE_LINKPARAMS	0
+/* Add support to draft-ietf-ospf-te-metric-extensions */
+/* Add support of RFC5392, RFC6827 */
 
 #include <zebra.h>
+#include <math.h>
 
 #ifdef HAVE_OSPF_TE
 #ifndef HAVE_OPAQUE_LSA
@@ -60,65 +64,19 @@
 #include "ospfd/ospf_ase.h"
 #include "ospfd/ospf_zebra.h"
 #include "ospfd/ospf_te.h"
-
-/* Following structure are internal use only. */
-struct ospf_mpls_te
-{
-  enum { disabled, enabled } status;
-
-  /* List elements are zebra-interfaces (ifp), not ospf-interfaces (oi). */
-  struct list *iflist;
-
-  /* Store Router-TLV in network byte order. */
-  struct te_tlv_router_addr router_addr;
-};
-
-struct mpls_te_link
-{
-  /*
-   * According to MPLS-TE (draft) specification, 24-bit Opaque-ID field
-   * is subdivided into 8-bit "unused" field and 16-bit "instance" field.
-   * In this implementation, each Link-TLV has its own instance.
-   */
-  u_int32_t instance;
-
-  /* Reference pointer to a Zebra-interface. */
-  struct interface *ifp;
-
-  /* Area info in which this MPLS-TE link belongs to. */
-  struct ospf_area *area;
-
-  /* Flags to manage this link parameters. */
-  u_int32_t flags;
-#define LPFLG_LOOKUP_DONE		0x1
-#define LPFLG_LSA_ENGAGED		0x2
-#define LPFLG_LSA_FORCED_REFRESH	0x4
-
-  /* Store Link-TLV in network byte order. */
-  struct te_tlv_link link_header;
-  struct te_link_subtlv_link_type link_type;
-  struct te_link_subtlv_link_id link_id;
-  struct te_link_subtlv_lclif_ipaddr *lclif_ipaddr;
-  struct te_link_subtlv_rmtif_ipaddr *rmtif_ipaddr;
-  struct te_link_subtlv_te_metric te_metric;
-  struct te_link_subtlv_max_bw max_bw;
-  struct te_link_subtlv_max_rsv_bw max_rsv_bw;
-  struct te_link_subtlv_unrsv_bw unrsv_bw;
-  struct te_link_subtlv_rsc_clsclr rsc_clsclr;
-};
+#include "ospfd/ospf_vty.h"
 
 /*
  * Global variable to manage Opaque-LSA/MPLS-TE on this node.
  * Note that all parameter values are stored in network byte order.
  */
-static struct ospf_mpls_te OspfMplsTE;
+struct ospf_mpls_te OspfMplsTE;
 
-enum oifstate {
-  OI_ANY, OI_DOWN, OI_UP
-};
+const char *mode2text[] = { "Disable", "AS", "Area", "Emulate" };
 
-enum sched_opcode {
-  REORIGINATE_PER_AREA, REFRESH_THIS_LSA, FLUSH_THIS_LSA
+enum oifstate
+{
+  OI_ANY, OI_DOWN, OI_UP
 };
 
 /*------------------------------------------------------------------------*
@@ -127,14 +85,14 @@ enum sched_opcode {
 
 static int ospf_mpls_te_new_if (struct interface *ifp);
 static int ospf_mpls_te_del_if (struct interface *ifp);
-static void ospf_mpls_te_ism_change (struct ospf_interface *oi, int old_status);
+static void ospf_mpls_te_ism_change (struct ospf_interface *oi,
+                                     int old_status);
 static void ospf_mpls_te_nsm_change (struct ospf_neighbor *nbr, int old_status);
 static void ospf_mpls_te_config_write_router (struct vty *vty);
-static void ospf_mpls_te_config_write_if (struct vty *vty, struct interface *ifp);
 static void ospf_mpls_te_show_info (struct vty *vty, struct ospf_lsa *lsa);
-static int ospf_mpls_te_lsa_originate (void *arg);
+static int ospf_mpls_te_lsa_originate_area (void *arg);
+static int ospf_mpls_te_lsa_originate_as (void *arg);
 static struct ospf_lsa *ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa);
-static void ospf_mpls_te_lsa_schedule (struct mpls_te_link *lp, enum sched_opcode);
 
 static void del_mpls_te_link (void *val);
 static void ospf_mpls_te_register_vty (void);
@@ -152,21 +110,22 @@ ospf_mpls_te_init (void)
 		ospf_mpls_te_ism_change,
 		ospf_mpls_te_nsm_change,
 		ospf_mpls_te_config_write_router,
-		ospf_mpls_te_config_write_if,
+		NULL,/*ospf_mpls_te_config_write_if */
 		NULL,/* ospf_mpls_te_config_write_debug */
                 ospf_mpls_te_show_info,
-                ospf_mpls_te_lsa_originate,
+                ospf_mpls_te_lsa_originate_area,
                 ospf_mpls_te_lsa_refresh,
 		NULL,/* ospf_mpls_te_new_lsa_hook */
 		NULL /* ospf_mpls_te_del_lsa_hook */);
   if (rc != 0)
     {
-      zlog_warn ("ospf_mpls_te_init: Failed to register functions");
+      zlog_warn ("ospf_mpls_te_init: Failed to register Traffic Engineering functions");
       goto out;
     }
 
   memset (&OspfMplsTE, 0, sizeof (struct ospf_mpls_te));
   OspfMplsTE.status = disabled;
+  OspfMplsTE.inter_as = Disable;
   OspfMplsTE.iflist = list_new ();
   OspfMplsTE.iflist->del = del_mpls_te_link;
 
@@ -176,16 +135,75 @@ out:
   return rc;
 }
 
+/* Additional register for RFC5392 support */
+static int
+ospf_mpls_te_register (enum inter_as_mode mode)
+{
+  int rc;
+  u_int8_t scope;
+
+  if (OspfMplsTE.inter_as != Disable)
+    return 0;
+
+  if (mode == AS)
+    scope = OSPF_OPAQUE_AS_LSA;
+  else
+    scope = OSPF_OPAQUE_AREA_LSA;
+
+  rc = ospf_register_opaque_functab (scope,
+                                     OPAQUE_TYPE_INTER_AS_LSA,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     ospf_mpls_te_show_info,
+                                     ospf_mpls_te_lsa_originate_as,
+                                     ospf_mpls_te_lsa_refresh, NULL, NULL);
+
+  if (rc != 0)
+    {
+      zlog_warn ("ospf_router_info_init: Failed to register Inter-AS functions");
+      return rc;
+    }
+
+  return 0;
+}
+
+static int
+ospf_mpls_te_unregister ()
+{
+  u_int8_t scope;
+
+  if (OspfMplsTE.inter_as == Disable)
+    return 0;
+
+  if (OspfMplsTE.inter_as == AS)
+    scope = OSPF_OPAQUE_AS_LSA;
+  else
+    scope = OSPF_OPAQUE_AREA_LSA;
+
+  ospf_delete_opaque_functab (scope, OPAQUE_TYPE_INTER_AS_LSA);
+
+  return 0;
+
+}
+
 void
 ospf_mpls_te_term (void)
 {
   list_delete (OspfMplsTE.iflist);
-
   OspfMplsTE.iflist = NULL;
-  OspfMplsTE.status = disabled;
 
   ospf_delete_opaque_functab (OSPF_OPAQUE_AREA_LSA,
                               OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA);
+  OspfMplsTE.status = disabled;
+
+  ospf_mpls_te_unregister ();
+  OspfMplsTE.inter_as = Disable;
+
   return;
 }
 
@@ -196,11 +214,11 @@ ospf_mpls_te_term (void)
 static void
 del_mpls_te_link (void *val)
 {
-  XFREE (MTYPE_OSPF_MPLS_TE_LINKPARAMS, val);
+  XFREE (MTYPE_OSPF_MPLS_TE, val);
   return;
 }
 
-static u_int32_t
+u_int32_t
 get_mpls_te_instance_value (void)
 {
   static u_int32_t seqno = 0;
@@ -278,9 +296,9 @@ lookup_linkparams_by_instance (struct ospf_lsa *lsa)
 }
 
 static void
-ospf_mpls_te_foreach_area (
-  void (*func)(struct mpls_te_link *lp, enum sched_opcode),
-  enum sched_opcode sched_opcode)
+ospf_mpls_te_foreach_area (void (*func)
+                           (struct mpls_te_link * lp, opcode_t sched_opcode),
+                           opcode_t sched_opcode)
 {
   struct listnode *node, *nnode; 
   struct listnode *node2;
@@ -289,10 +307,12 @@ ospf_mpls_te_foreach_area (
 
   for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
     {
-      if ((area = lp->area) == NULL)
+      /* Skip Inter-AS TEv2 Links */
+      if (IS_INTER_AS (lp->type))
         continue;
-      if (lp->flags & LPFLG_LOOKUP_DONE)
+      if ((area = lp->area) == NULL)
         continue;
+      if CHECK_FLAG (lp->flags, LPFLG_LOOKUP_DONE) continue;
 
       if (func != NULL)
         (* func)(lp, sched_opcode);
@@ -301,12 +321,12 @@ ospf_mpls_te_foreach_area (
         if ((lp = listgetdata (node2)) != NULL)
           if (lp->area != NULL)
             if (IPV4_ADDR_SAME (&lp->area->area_id, &area->area_id))
-              lp->flags |= LPFLG_LOOKUP_DONE;
+              SET_FLAG (lp->flags, LPFLG_LOOKUP_DONE);
     }
 
   for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))
     if (lp->area != NULL)
-      lp->flags &= ~LPFLG_LOOKUP_DONE;
+      UNSET_FLAG (lp->flags, LPFLG_LOOKUP_DONE);
 
   return;
 }
@@ -315,7 +335,7 @@ static void
 set_mpls_te_router_addr (struct in_addr ipv4)
 {
   OspfMplsTE.router_addr.header.type   = htons (TE_TLV_ROUTER_ADDR);
-  OspfMplsTE.router_addr.header.length = htons (sizeof (ipv4));
+  OspfMplsTE.router_addr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
   OspfMplsTE.router_addr.value = ipv4;
   return;
 }
@@ -323,7 +343,6 @@ set_mpls_te_router_addr (struct in_addr ipv4)
 static void
 set_linkparams_link_header (struct mpls_te_link *lp)
 {
-  struct te_tlv_header *tlvh;
   u_int16_t length = 0;
 
   /* TE_LINK_SUBTLV_LINK_TYPE */
@@ -335,14 +354,12 @@ set_linkparams_link_header (struct mpls_te_link *lp)
     length += TLV_SIZE (&lp->link_id.header);
 
   /* TE_LINK_SUBTLV_LCLIF_IPADDR */
-  if ((tlvh = (struct te_tlv_header *) lp->lclif_ipaddr) != NULL
-  &&  ntohs (tlvh->type) != 0)
-    length += TLV_SIZE (tlvh);
+  if (lp->lclif_ipaddr.header.type != 0)
+    length += TLV_SIZE (&lp->lclif_ipaddr.header);
 
   /* TE_LINK_SUBTLV_RMTIF_IPADDR */
-  if ((tlvh = (struct te_tlv_header *) lp->rmtif_ipaddr) != NULL
-  &&  ntohs (tlvh->type) != 0)
-    length += TLV_SIZE (tlvh);
+  if (lp->rmtif_ipaddr.header.type != 0)
+    length += TLV_SIZE (&lp->rmtif_ipaddr.header);
 
   /* TE_LINK_SUBTLV_TE_METRIC */
   if (ntohs (lp->te_metric.header.type) != 0)
@@ -364,6 +381,50 @@ set_linkparams_link_header (struct mpls_te_link *lp)
   if (ntohs (lp->rsc_clsclr.header.type) != 0)
     length += TLV_SIZE (&lp->rsc_clsclr.header);
 
+  /* TE_LINK_SUBTLV_LLRI */
+  if (ntohs (lp->llri.header.type) != 0)
+    length += TLV_SIZE (&lp->llri.header);
+
+  /* TE_LINK_SUBTLV_RIP */
+  if (ntohs (lp->rip.header.type) != 0)
+    length += TLV_SIZE (&lp->rip.header);
+
+  /* TE_LINK_SUBTLV_RAS */
+  if (ntohs (lp->ras.header.type) != 0)
+    length += TLV_SIZE (&lp->ras.header);
+
+  /* TE_LINK_SUBTLV_LRRID */
+  if (ntohs (lp->lrrid.header.type) != 0)
+    length += TLV_SIZE (&lp->lrrid.header);
+
+  /* TE_LINK_SUBTLV_AV_DELAY */
+  if (ntohs (lp->av_delay.header.type) != 0)
+    length += TLV_SIZE (&lp->av_delay.header);
+
+  /* TE_LINK_SUBTLV_MM_DELAY */
+  if (ntohs (lp->mm_delay.header.type) != 0)
+    length += TLV_SIZE (&lp->mm_delay.header);
+
+  /* TE_LINK_SUBTLV_DELAY_VAR */
+  if (ntohs (lp->delay_var.header.type) != 0)
+    length += TLV_SIZE (&lp->delay_var.header);
+
+  /* TE_LINK_SUBTLV_PKT_LOSS */
+  if (ntohs (lp->pkt_loss.header.type) != 0)
+    length += TLV_SIZE (&lp->pkt_loss.header);
+
+  /* TE_LINK_SUBTLV_RES_BW */
+  if (ntohs (lp->res_bw.header.type) != 0)
+    length += TLV_SIZE (&lp->res_bw.header);
+
+  /* TE_LINK_SUBTLV_AVA_BW */
+  if (ntohs (lp->ava_bw.header.type) != 0)
+    length += TLV_SIZE (&lp->ava_bw.header);
+
+  /* TE_LINK_SUBTLV_USE_BW */
+  if (ntohs (lp->use_bw.header.type) != 0)
+    length += TLV_SIZE (&lp->use_bw.header);
+
   lp->link_header.header.type   = htons (TE_TLV_LINK);
   lp->link_header.header.length = htons (length);
 
@@ -374,7 +435,7 @@ static void
 set_linkparams_link_type (struct ospf_interface *oi, struct mpls_te_link *lp)
 {
   lp->link_type.header.type   = htons (TE_LINK_SUBTLV_LINK_TYPE);
-  lp->link_type.header.length = htons (sizeof (lp->link_type.link_type.value));
+  lp->link_type.header.length = htons (TE_LINK_SUBTLV_TYPE_SIZE);
 
   switch (oi->type)
     {
@@ -400,7 +461,7 @@ set_linkparams_link_id (struct ospf_interface *oi, struct mpls_te_link *lp)
   int done = 0;
 
   lp->link_id.header.type   = htons (TE_LINK_SUBTLV_LINK_ID);
-  lp->link_id.header.length = htons (sizeof (lp->link_id.value));
+  lp->link_id.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
 
   /*
    * The Link ID is identical to the contents of the Link ID field
@@ -410,8 +471,7 @@ set_linkparams_link_id (struct ospf_interface *oi, struct mpls_te_link *lp)
     {
     case OSPF_IFTYPE_POINTOPOINT:
       /* Take the router ID of the neighbor. */
-      if ((nbr = ospf_nbr_lookup_ptop (oi))
-	  && nbr->state == NSM_Full)
+      if ((nbr = ospf_nbr_lookup_ptop (oi)) && nbr->state == NSM_Full)
         {
           lp->link_id.value = nbr->router_id;
           done = 1;
@@ -447,10 +507,30 @@ set_linkparams_link_id (struct ospf_interface *oi, struct mpls_te_link *lp)
 }
 
 static void
+set_linkparams_lclif_ipaddr (struct mpls_te_link *lp, struct in_addr lclif)
+{
+
+  lp->lclif_ipaddr.header.type = htons (TE_LINK_SUBTLV_LCLIF_IPADDR);
+  lp->lclif_ipaddr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  lp->lclif_ipaddr.value[0] = lclif;
+  return;
+}
+
+static void
+set_linkparams_rmtif_ipaddr (struct mpls_te_link *lp, struct in_addr rmtif)
+{
+
+  lp->rmtif_ipaddr.header.type = htons (TE_LINK_SUBTLV_RMTIF_IPADDR);
+  lp->rmtif_ipaddr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  lp->rmtif_ipaddr.value[0] = rmtif;
+  return;
+}
+
+static void
 set_linkparams_te_metric (struct mpls_te_link *lp, u_int32_t te_metric)
 {
   lp->te_metric.header.type   = htons (TE_LINK_SUBTLV_TE_METRIC);
-  lp->te_metric.header.length = htons (sizeof (lp->te_metric.value));
+  lp->te_metric.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
   lp->te_metric.value = htonl (te_metric);
   return;
 }
@@ -459,7 +539,7 @@ static void
 set_linkparams_max_bw (struct mpls_te_link *lp, float *fp)
 {
   lp->max_bw.header.type   = htons (TE_LINK_SUBTLV_MAX_BW);
-  lp->max_bw.header.length = htons (sizeof (lp->max_bw.value));
+  lp->max_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
   htonf (fp, &lp->max_bw.value);
   return;
 }
@@ -468,7 +548,7 @@ static void
 set_linkparams_max_rsv_bw (struct mpls_te_link *lp, float *fp)
 {
   lp->max_rsv_bw.header.type   = htons (TE_LINK_SUBTLV_MAX_RSV_BW);
-  lp->max_rsv_bw.header.length = htons (sizeof (lp->max_rsv_bw.value));
+  lp->max_rsv_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
   htonf (fp, &lp->max_rsv_bw.value);
   return;
 }
@@ -478,7 +558,7 @@ set_linkparams_unrsv_bw (struct mpls_te_link *lp, int priority, float *fp)
 {
   /* Note that TLV-length field is the size of array. */
   lp->unrsv_bw.header.type   = htons (TE_LINK_SUBTLV_UNRSV_BW);
-  lp->unrsv_bw.header.length = htons (sizeof (lp->unrsv_bw.value));
+  lp->unrsv_bw.header.length = htons (TE_LINK_SUBTLV_UNRSV_SIZE);
   htonf (fp, &lp->unrsv_bw.value [priority]);
   return;
 }
@@ -487,21 +567,284 @@ static void
 set_linkparams_rsc_clsclr (struct mpls_te_link *lp, u_int32_t classcolor)
 {
   lp->rsc_clsclr.header.type   = htons (TE_LINK_SUBTLV_RSC_CLSCLR);
-  lp->rsc_clsclr.header.length = htons (sizeof (lp->rsc_clsclr.value));
+  lp->rsc_clsclr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
   lp->rsc_clsclr.value = htonl (classcolor);
   return;
 }
 
 static void
+set_linkparams_inter_as (struct mpls_te_link *lp, struct in_addr addr,
+                         u_int32_t as)
+{
+
+  /* Set the Remote ASBR IP address and then the associated AS number */
+  lp->rip.header.type = htons (TE_LINK_SUBTLV_RIP);
+  lp->rip.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  lp->rip.value = addr;
+
+  lp->ras.header.type = htons (TE_LINK_SUBTLV_RAS);
+  lp->ras.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  lp->ras.value = htonl (as);
+}
+
+static void
+unset_linkparams_inter_as (struct mpls_te_link *lp)
+{
+
+  /* Reset the Remote ASBR IP address and then the associated AS number */
+  lp->rip.header.type = htons (0);
+  lp->rip.header.length = htons (0);
+  lp->rip.value.s_addr = htonl (0);
+
+  lp->ras.header.type = htons (0);
+  lp->ras.header.length = htons (0);
+  lp->ras.value = htonl (0);
+}
+
+void
+set_linkparams_llri (struct mpls_te_link *lp, u_int32_t local,
+                     u_int32_t remote)
+{
+
+  lp->llri.header.type = htons (TE_LINK_SUBTLV_LLRI);
+  lp->llri.header.length = htons (TE_LINK_SUBTLV_LLRI_SIZE);
+  lp->llri.local = htonl (local);
+  lp->llri.remote = htonl (remote);
+}
+
+void
+set_linkparams_lrrid (struct mpls_te_link *lp, struct in_addr local,
+                           struct in_addr remote)
+{
+
+  lp->lrrid.header.type = htons (TE_LINK_SUBTLV_LRRID);
+  lp->lrrid.header.length = htons (TE_LINK_SUBTLV_LRRID_SIZE);
+  lp->lrrid.local.s_addr = local.s_addr;
+  lp->lrrid.remote.s_addr = remote.s_addr;
+}
+
+static void
+set_linkparams_av_delay (struct mpls_te_link *lp, u_int32_t delay, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  lp->av_delay.header.type = htons (TE_LINK_SUBTLV_AV_DELAY);
+  lp->av_delay.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  tmp = delay & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  lp->av_delay.value = htonl (tmp);
+  return;
+}
+
+static void
+set_linkparams_mm_delay (struct mpls_te_link *lp, u_int32_t low, u_int32_t high, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  lp->mm_delay.header.type = htons (TE_LINK_SUBTLV_MM_DELAY);
+  lp->mm_delay.header.length = htons (TE_LINK_SUBTLV_MM_DELAY_SIZE);
+  tmp = low & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  lp->mm_delay.low = htonl (tmp);
+  lp->mm_delay.high = htonl (high);
+  return;
+}
+
+static void
+set_linkparams_delay_var (struct mpls_te_link *lp, u_int32_t jitter)
+{
+  /* Note that TLV-length field is the size of array. */
+  lp->delay_var.header.type = htons (TE_LINK_SUBTLV_DELAY_VAR);
+  lp->delay_var.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  lp->delay_var.value = htonl (jitter & TE_EXT_MASK);
+  return;
+}
+
+static void
+set_linkparams_pkt_loss (struct mpls_te_link *lp, u_int32_t loss, u_char anormal)
+{
+  u_int32_t tmp;
+  /* Note that TLV-length field is the size of array. */
+  lp->pkt_loss.header.type = htons (TE_LINK_SUBTLV_PKT_LOSS);
+  lp->pkt_loss.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  tmp = loss & TE_EXT_MASK;
+  if (anormal)
+    tmp |= TE_EXT_ANORMAL;
+  lp->pkt_loss.value = htonl (tmp);
+  return;
+}
+
+static void
+set_linkparams_res_bw (struct mpls_te_link *lp, float *fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  lp->res_bw.header.type = htons (TE_LINK_SUBTLV_RES_BW);
+  lp->res_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  htonf (fp, &lp->res_bw.value);
+  return;
+}
+
+static void
+set_linkparams_ava_bw (struct mpls_te_link *lp, float *fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  lp->ava_bw.header.type = htons (TE_LINK_SUBTLV_AVA_BW);
+  lp->ava_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  htonf (fp, &lp->ava_bw.value);
+  return;
+}
+
+static void
+set_linkparams_use_bw (struct mpls_te_link *lp, float *fp)
+{
+  /* Note that TLV-length field is the size of array. */
+  lp->use_bw.header.type = htons (TE_LINK_SUBTLV_USE_BW);
+  lp->use_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);
+  htonf (fp, &lp->use_bw.value);
+  return;
+}
+
+/* Update TE parameters from Interface */
+static void
+update_linkparams(struct mpls_te_link *lp)
+{
+  int i, unset;
+  struct interface *ifp;
+
+  /* Get the Interface structure */
+  if ((ifp = lp->ifp) == NULL)
+    {
+      zlog_warn("OSPF MPLS-TE: Abort update TE parameters: no interface associated to Link Parameters");
+      return;
+    }
+
+  /* RFC3630 metrics */
+  if (ifp->link_te.admin_grp != 0)
+    set_linkparams_rsc_clsclr (lp, ifp->link_te.admin_grp);
+  else
+    TLV_TYPE(lp->rsc_clsclr) = 0;
+
+  if (ifp->link_te.max_bw != 0)
+    set_linkparams_max_bw (lp, &ifp->link_te.max_bw);
+  else
+    TLV_TYPE(lp->max_bw) = 0;
+
+  if (ifp->link_te.max_rsv_bw != 0)
+    set_linkparams_max_rsv_bw (lp, &ifp->link_te.max_rsv_bw);
+  else
+    TLV_TYPE(lp->max_rsv_bw) = 0;
+
+  unset = 0;
+  for (i = 0; i < MAX_CLASS_TYPE; i++)
+    {
+      if (ifp->link_te.unrsv_bw[i] != 0)
+        set_linkparams_unrsv_bw (lp, i, &ifp->link_te.unrsv_bw[i]);
+      else
+        unset++;
+    }
+  /* Reset UNRSV_BW SubTLV if all Class Type value equal 0 */
+  if (unset == MAX_CLASS_TYPE)
+    TLV_TYPE(lp->unrsv_bw) = 0;
+
+  if (ifp->link_te.te_metric != 0)
+    set_linkparams_te_metric(lp, ifp->link_te.te_metric);
+  else
+    TLV_TYPE(lp->te_metric) = 0;
+
+  /* TE metric Extensions */
+  if (ifp->link_te.av_delay != 0)
+    set_linkparams_av_delay(lp, ifp->link_te.av_delay, 0);
+  else
+    TLV_TYPE(lp->av_delay) = 0;
+
+  if ((ifp->link_te.min_delay != 0) || (ifp->link_te.max_delay != 0))
+    set_linkparams_mm_delay(lp, ifp->link_te.min_delay, ifp->link_te.max_delay, 0);
+  else
+    TLV_TYPE(lp->mm_delay) = 0;
+
+  if (ifp->link_te.delay_var != 0)
+    set_linkparams_delay_var(lp, ifp->link_te.delay_var);
+  else
+    TLV_TYPE(lp->delay_var) = 0;
+
+  if (ifp->link_te.pkt_loss >= 0.0)
+    set_linkparams_pkt_loss(lp, ifp->link_te.pkt_loss, 0);
+  else
+    TLV_TYPE(lp->pkt_loss) = 0;
+
+  if (ifp->link_te.res_bw != 0)
+    set_linkparams_res_bw(lp, &ifp->link_te.res_bw);
+  else
+    TLV_TYPE(lp->res_bw) = 0;
+
+  if (ifp->link_te.ava_bw != 0)
+    set_linkparams_ava_bw(lp, &ifp->link_te.ava_bw);
+  else
+    TLV_TYPE(lp->ava_bw) = 0;
+
+  if (ifp->link_te.use_bw != 0)
+    set_linkparams_use_bw(lp, &ifp->link_te.use_bw);
+  else
+    TLV_TYPE(lp->use_bw) = 0;
+
+  /* RFC5392 */
+  if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+    {
+      /* Flush LSA if it engaged and was previously a STD_TE one */
+      if (IS_STD_TE(lp->type) && CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED))
+        {
+          if (IS_DEBUG_OSPF_TE)
+            zlog_debug("OSPF MPLS-TE Update IF: Switch from Standard LSA to INTER-AS for %s[%d/%d]",
+              ifp->name, lp->flags, lp->type);
+
+          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
+          /* Then, switch it to INTER-AS */
+          if (OspfMplsTE.inter_as == AS)
+            lp->flags = INTER_AS | FLOOD_AS;
+          else
+            {
+              lp->flags = INTER_AS | FLOOD_AREA;
+              lp->area = ospf_area_lookup_by_area_id (ospf_lookup(), OspfMplsTE.interas_areaid);
+            }
+        }
+      set_linkparams_inter_as(lp, ifp->link_te.rmt_ip, ifp->link_te.rmt_as);
+    }
+  else
+    {
+      if (IS_DEBUG_OSPF_TE)
+        zlog_debug("OSPF MPLS-TE Update IF: Switch from INTER-AS LSA to Standard for %s[%d/%d]",
+          ifp->name, lp->flags, lp->type);
+
+      /* reset inter-as TE params */
+      /* Flush LSA if it engaged and was previously an INTER_AS one */
+      if (IS_INTER_AS(lp->type) && CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED))
+        {
+          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
+          /* Then, switch it to Standard TE */
+          lp->flags = STD_TE | FLOOD_AREA;
+        }
+      unset_linkparams_inter_as (lp);
+    }
+}
+
+static void
 initialize_linkparams (struct mpls_te_link *lp)
 {
   struct interface *ifp = lp->ifp;
   struct ospf_interface *oi;
-  float fval;
-  int i;
+
+  if (IS_DEBUG_OSPF_TE)
+    zlog_debug("MPLS-TE(initialize_linkparams) Initialize Link Parameters for interface %s",
+                ifp->name);
 
   if ((oi = lookup_oi_by_ifp (ifp, NULL, OI_ANY)) == NULL)
-    return;
+    {
+      zlog_warn("MPLS-TE(initialize_linkparams) Could not find corresponding OSPF Interface for %s",
+                 ifp->name);
+      return;
+    }
 
   /*
    * Try to set initial values those can be derived from
@@ -509,18 +852,19 @@ initialize_linkparams (struct mpls_te_link *lp)
    */
   set_linkparams_link_type (oi, lp);
 
-  /*
-   * Linux and *BSD kernel holds bandwidth parameter as an "int" type.
-   * We may have to reconsider, if "ifp->bandwidth" type changes to float.
-   */
-  fval = (float)((ifp->bandwidth ? ifp->bandwidth
-                                 : OSPF_DEFAULT_BANDWIDTH) * 1000 / 8);
+  /* Set local IP addr */
+  set_linkparams_lclif_ipaddr (lp, oi->address->u.prefix4);
 
-  set_linkparams_max_bw (lp, &fval);
-  set_linkparams_max_rsv_bw (lp, &fval);
+  /* Set Remote IP addr if Point to Point Interface */
+  if (oi->type == LINK_TYPE_SUBTLV_VALUE_PTP)
+    {
+      struct prefix *pref = CONNECTED_PREFIX(oi->connected);
+      if (pref != NULL)
+        set_linkparams_rmtif_ipaddr(lp, pref->u.prefix4);
+    }
 
-  for (i = 0; i < 8; i++)
-    set_linkparams_unrsv_bw (lp, i, &fval);
+  /* Keep Area information in combination with link parameters. */
+  lp->area = oi->area;
 
   return;
 }
@@ -531,13 +875,22 @@ is_mandated_params_set (struct mpls_te_link *lp)
   int rc = 0;
 
   if (ntohs (OspfMplsTE.router_addr.header.type) == 0)
+    {
+      zlog_warn ("MPLS-TE(is_mandated_params_set) Missing Router Address");
     goto out;
+    }
 
   if (ntohs (lp->link_type.header.type) == 0)
+    {
+      zlog_warn ("MPLS-TE(is_mandated_params_set) Missing Link Type");
     goto out;
+    }
 
-  if (ntohs (lp->link_id.header.type) == 0)
+  if (!IS_INTER_AS (lp->type) && (ntohs (lp->link_id.header.type) == 0))
+    {
+      zlog_warn ("MPLS-TE(is_mandated_params_set) Missing Link ID");
     goto out;
+    }
 
   rc = 1;
 out:
@@ -554,6 +907,10 @@ ospf_mpls_te_new_if (struct interface *ifp)
   struct mpls_te_link *new;
   int rc = -1;
 
+  if (IS_DEBUG_OSPF_TE)
+    zlog_debug ("MPLS-TE(ospf_mpls_te_new_if) Add new %s interface %s to MPLS-TE list",
+                 ifp->mpls_te ? "Active" : "Inactive", ifp->name);
+
   if (lookup_linkparams_by_ifp (ifp) != NULL)
     {
       zlog_warn ("ospf_mpls_te_new_if: ifp(%p) already in use?", ifp);
@@ -561,23 +918,33 @@ ospf_mpls_te_new_if (struct interface *ifp)
       goto out;
     }
 
-  new = XCALLOC (MTYPE_OSPF_MPLS_TE_LINKPARAMS,
-                  sizeof (struct mpls_te_link));
+  new = XCALLOC (MTYPE_OSPF_MPLS_TE, sizeof (struct mpls_te_link));
   if (new == NULL)
     {
       zlog_warn ("ospf_mpls_te_new_if: XMALLOC: %s", safe_strerror (errno));
       goto out;
     }
 
-  new->area = NULL;
-  new->flags = 0;
   new->instance = get_mpls_te_instance_value ();
   new->ifp = ifp;
+  /* By default TE-Link is RFC3630 compatible flooding in Area and not active */
+  /* This default behavior will be adapted with call to ospf_mpls_te_update_if() */
+  new->type = STD_TE | FLOOD_AREA;
+  new->flags = LPFLG_LSA_INACTIVE;
 
-  initialize_linkparams (new);
+  /* Initialize Link Parameters from Interface */
+  initialize_linkparams(new);
 
+  /* Set TE Parameters from Interface */
+  update_linkparams(new);
+
+  /* Add Link Parameters structure to the list */
   listnode_add (OspfMplsTE.iflist, new);
 
+  if (IS_DEBUG_OSPF_TE)
+    zlog_debug("OSPF MPLS-TE New IF: Add new LP context for %s[%d/%d]",
+      ifp->name, new->flags, new->type);
+
   /* Schedule Opaque-LSA refresh. *//* XXX */
 
   rc = 0;
@@ -602,7 +969,7 @@ ospf_mpls_te_del_if (struct interface *ifp)
       if (listcount (iflist) == 0)
         iflist->head = iflist->tail = NULL;
 
-      XFREE (MTYPE_OSPF_MPLS_TE_LINKPARAMS, lp);
+      XFREE (MTYPE_OSPF_MPLS_TE, lp);
     }
 
   /* Schedule Opaque-LSA refresh. *//* XXX */
@@ -612,6 +979,56 @@ ospf_mpls_te_del_if (struct interface *ifp)
   return rc;
 }
 
+/* Main initialization / update function of the MPLS TE Link context */
+
+/* Call when interface TE Link parameters are modified */
+void
+ospf_mpls_te_update_if (struct interface *ifp)
+{
+  struct mpls_te_link *lp;
+
+  if (IS_DEBUG_OSPF_TE)
+    zlog_debug ("OSPF MPLS-TE: Update LSA parameters for interface %s [%s]",
+        ifp->name, ifp->mpls_te ? "ON" : "OFF");
+
+  /* Get Link context from interface */
+  if ((lp = lookup_linkparams_by_ifp(ifp)) == NULL)
+    {
+      zlog_warn ("OSPF MPLS-TE Update: Did not find Link Parameters context for interface %s", ifp->name);
+      return;
+    }
+
+  /* Fulfill MPLS-TE Link TLV from Interface TE Link parameters */
+  if (IS_LINK_TE(ifp))
+    {
+      SET_FLAG (lp->flags, LPFLG_LSA_ACTIVE);
+
+      /* Update TE parameters */
+      update_linkparams(lp);
+
+      /* Finally Re-Originate or Refresh Opaque LSA if MPLS_TE is enabled */
+      if (OspfMplsTE.status == enabled)
+        if (lp->area != NULL)
+          {
+            if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
+                ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
+            else
+                ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);
+          }
+    }
+  else
+    {
+      /* If MPLS TE is disable on this interface, flush LSA if it is already engaged */
+      if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
+          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
+      else
+        /* Reset Activity flag */
+        lp->flags = LPFLG_LSA_INACTIVE;
+    }
+
+  return;
+}
+
 static void
 ospf_mpls_te_ism_change (struct ospf_interface *oi, int old_state)
 {
@@ -624,10 +1041,10 @@ ospf_mpls_te_ism_change (struct ospf_interface *oi, int old_state)
       zlog_warn ("ospf_mpls_te_ism_change: Cannot get linkparams from OI(%s)?", IF_NAME (oi));
       goto out;
     }
+
   if (oi->area == NULL || oi->area->ospf == NULL)
     {
-      zlog_warn ("ospf_mpls_te_ism_change: Cannot refer to OSPF from OI(%s)?",
-IF_NAME (oi));
+      zlog_warn ("ospf_mpls_te_ism_change: Cannot refer to OSPF from OI(%s)?", IF_NAME (oi));
       goto out;
     }
 #ifdef notyet
@@ -636,13 +1053,17 @@ IF_NAME (oi));
   || (lp->area != NULL && oi->area == NULL))
     {
       /* How should we consider this case? */
-      zlog_warn ("MPLS-TE: Area for OI(%s) has changed to [%s], flush previous LSAs", IF_NAME (oi), oi->area ? inet_ntoa (oi->area->area_id) : "N/A");
+      zlog_warn ("MPLS-TE: Area for OI(%s) has changed to [%s], flush previous LSAs",
+         IF_NAME (oi), oi->area ? inet_ntoa (oi->area->area_id) : "N/A");
       ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
     }
 #endif
-  /* Keep Area information in conbination with linkparams. */
+  /* Keep Area information in combination with linkparams. */
   lp->area = oi->area;
 
+  /* Keep interface MPLS-TE status */
+  lp->flags = oi->ifp->mpls_te;
+
   switch (oi->state)
     {
     case ISM_PointToPoint:
@@ -652,37 +1073,53 @@ IF_NAME (oi));
       old_type = lp->link_type;
       old_id   = lp->link_id;
 
+      /* Set Link type, Link ID, Local and Remote IP addr */
       set_linkparams_link_type (oi, lp);
       set_linkparams_link_id (oi, lp);
+      set_linkparams_lclif_ipaddr (lp, oi->address->u.prefix4);
+
+      if (oi->type == LINK_TYPE_SUBTLV_VALUE_PTP)
+        {
+          struct prefix *pref = CONNECTED_PREFIX(oi->connected);
+          if (pref != NULL)
+            set_linkparams_rmtif_ipaddr(lp, pref->u.prefix4);
+        }
+
+      /* Update TE parameters */
+      update_linkparams(lp);
 
+      /* Try to Schedule LSA */
       if ((ntohs (old_type.header.type) != ntohs (lp->link_type.header.type)
       ||   old_type.link_type.value     != lp->link_type.link_type.value)
       ||  (ntohs (old_id.header.type)   != ntohs (lp->link_id.header.type)
-      ||   ntohl (old_id.value.s_addr)  != ntohl (lp->link_id.value.s_addr)))
+              || ntohl (old_id.value.s_addr) !=
+              ntohl (lp->link_id.value.s_addr)))
         {
-          if (lp->flags & LPFLG_LSA_ENGAGED)
+          if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
             ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
           else
-            ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
+            ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);
+
         }
       break;
     default:
       lp->link_type.header.type = htons (0);
       lp->link_id.header.type   = htons (0);
 
-      if (lp->flags & LPFLG_LSA_ENGAGED)
+      if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
         ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
       break;
     }
 
 out:
   return;
+
 }
 
 static void
 ospf_mpls_te_nsm_change (struct ospf_neighbor *nbr, int old_state)
 {
-  /* So far, nothing to do here. */
+  /* Nothing to do here */
   return;
 }
 
@@ -710,10 +1147,10 @@ build_router_tlv (struct stream *s)
 }
 
 static void
-build_link_subtlv_link_type (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->link_type.header;
-  if (ntohs (tlvh->type) != 0)
+build_link_subtlv (struct stream *s, struct te_tlv_header *tlvh)
+    {
+
+  if ((tlvh != NULL) && (ntohs (tlvh->type) != 0))
     {
       build_tlv_header (s, tlvh);
       stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
@@ -722,116 +1159,32 @@ build_link_subtlv_link_type (struct stream *s, struct mpls_te_link *lp)
 }
 
 static void
-build_link_subtlv_link_id (struct stream *s, struct mpls_te_link *lp)
+build_link_tlv (struct stream *s, struct mpls_te_link *lp)
 {
-  struct te_tlv_header *tlvh = &lp->link_id.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_lclif_ipaddr (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = (struct te_tlv_header *) lp->lclif_ipaddr;
-  if (tlvh != NULL && ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_rmtif_ipaddr (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = (struct te_tlv_header *) lp->rmtif_ipaddr;
-  if (tlvh != NULL && ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_te_metric (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->te_metric.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_max_bw (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->max_bw.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_max_rsv_bw (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->max_rsv_bw.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_unrsv_bw (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->unrsv_bw.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_subtlv_rsc_clsclr (struct stream *s, struct mpls_te_link *lp)
-{
-  struct te_tlv_header *tlvh = &lp->rsc_clsclr.header;
-  if (ntohs (tlvh->type) != 0)
-    {
-      build_tlv_header (s, tlvh);
-      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));
-    }
-  return;
-}
-
-static void
-build_link_tlv (struct stream *s, struct mpls_te_link *lp)
-{
-  set_linkparams_link_header (lp);
-  build_tlv_header (s, &lp->link_header.header);
-
-  build_link_subtlv_link_type (s, lp);
-  build_link_subtlv_link_id (s, lp);
-  build_link_subtlv_lclif_ipaddr (s, lp);
-  build_link_subtlv_rmtif_ipaddr (s, lp);
-  build_link_subtlv_te_metric (s, lp);
-  build_link_subtlv_max_bw (s, lp);
-  build_link_subtlv_max_rsv_bw (s, lp);
-  build_link_subtlv_unrsv_bw (s, lp);
-  build_link_subtlv_rsc_clsclr (s, lp);
+  set_linkparams_link_header (lp);
+  build_tlv_header (s, &lp->link_header.header);
+
+  build_link_subtlv (s, &lp->link_type.header);
+  build_link_subtlv (s, &lp->link_id.header);
+  build_link_subtlv (s, &lp->lclif_ipaddr.header);
+  build_link_subtlv (s, &lp->rmtif_ipaddr.header);
+  build_link_subtlv (s, &lp->te_metric.header);
+  build_link_subtlv (s, &lp->max_bw.header);
+  build_link_subtlv (s, &lp->max_rsv_bw.header);
+  build_link_subtlv (s, &lp->unrsv_bw.header);
+  build_link_subtlv (s, &lp->rsc_clsclr.header);
+  build_link_subtlv (s, &lp->lrrid.header);
+  build_link_subtlv (s, &lp->llri.header);
+  build_link_subtlv (s, &lp->rip.header);
+  build_link_subtlv (s, &lp->ras.header);
+  build_link_subtlv (s, &lp->av_delay.header);
+  build_link_subtlv (s, &lp->mm_delay.header);
+  build_link_subtlv (s, &lp->delay_var.header);
+  build_link_subtlv (s, &lp->pkt_loss.header);
+  build_link_subtlv (s, &lp->res_bw.header);
+  build_link_subtlv (s, &lp->ava_bw.header);
+  build_link_subtlv (s, &lp->res_bw.header);
+
   return;
 }
 
@@ -860,7 +1213,7 @@ ospf_mpls_te_lsa_new (struct ospf_area *area, struct mpls_te_link *lp)
   struct stream *s;
   struct lsa_header *lsah;
   struct ospf_lsa *new = NULL;
-  u_char options, lsa_type;
+  u_char options, lsa_type = 0;
   struct in_addr lsa_id;
   u_int32_t tmp;
   u_int16_t length;
@@ -873,19 +1226,42 @@ ospf_mpls_te_lsa_new (struct ospf_area *area, struct mpls_te_link *lp)
     }
   lsah = (struct lsa_header *) STREAM_DATA (s);
 
-  options  = LSA_OPTIONS_GET (area);
-  options |= LSA_OPTIONS_NSSA_GET (area);
-  options |= OSPF_OPTION_O; /* Don't forget this :-) */
+  options = OSPF_OPTION_O;      /* Don't forget this :-) */
 
-  lsa_type = OSPF_OPAQUE_AREA_LSA;
-  tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp->instance);
-  lsa_id.s_addr = htonl (tmp);
+  /* Set opaque-LSA header fields depending of the type of RFC */
+  if (IS_INTER_AS (lp->type))
+    {
+      if IS_FLOOD_AS (lp->type)
+        {
+          options |= OSPF_OPTION_E;     /* Enable AS external as we flood Inter-AS with Opaque Type 11 */
+          lsa_type = OSPF_OPAQUE_AS_LSA;
+        }
+      else
+        {
+          options |= LSA_OPTIONS_GET (area);    /* Get area default option */
+          options |= LSA_OPTIONS_NSSA_GET (area);
+          lsa_type = OSPF_OPAQUE_AREA_LSA;
+        }
+      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp->instance);
+      lsa_id.s_addr = htonl (tmp);
 
-  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
-    zlog_debug ("LSA[Type%d:%s]: Create an Opaque-LSA/MPLS-TE instance", lsa_type, inet_ntoa (lsa_id));
+      struct ospf *top = ospf_lookup ();
 
-  /* Set opaque-LSA header fields. */
-  lsa_header_set (s, options, lsa_type, lsa_id, area->ospf->router_id);
+      lsa_header_set (s, options, lsa_type, lsa_id, top->router_id);
+    }
+  else
+    {
+      options |= LSA_OPTIONS_GET (area);        /* Get area default option */
+      options |= LSA_OPTIONS_NSSA_GET (area);
+      lsa_type = OSPF_OPAQUE_AREA_LSA;
+      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp->instance);
+      lsa_id.s_addr = htonl (tmp);
+      lsa_header_set (s, options, lsa_type, lsa_id, area->ospf->router_id);
+    }
+
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    zlog_debug ("LSA[Type%d:%s]: Create an Opaque-LSA/MPLS-TE instance",
+                lsa_type, inet_ntoa (lsa_id));
 
   /* Set opaque-LSA body fields. */
   ospf_mpls_te_lsa_body_set (s, lp);
@@ -940,9 +1316,8 @@ ospf_mpls_te_lsa_originate1 (struct ospf_area *area, struct mpls_te_link *lp)
       goto out;
     }
 
-  /* Now this linkparameter entry has associated LSA. */
-  lp->flags |= LPFLG_LSA_ENGAGED;
-
+  /* Now this link-parameter entry has associated LSA. */
+  SET_FLAG (lp->flags, LPFLG_LSA_ENGAGED);
   /* Update new LSA origination count. */
   area->ospf->lsa_originate_count++;
 
@@ -953,7 +1328,8 @@ ospf_mpls_te_lsa_originate1 (struct ospf_area *area, struct mpls_te_link *lp)
     {
       char area_id[INET_ADDRSTRLEN];
       strcpy (area_id, inet_ntoa (area->area_id));
-      zlog_debug ("LSA[Type%d:%s]: Originate Opaque-LSA/MPLS-TE: Area(%s), Link(%s)", new->data->type, inet_ntoa (new->data->id), area_id, lp->ifp->name);
+      zlog_debug ("LSA[Type%d:%s]: Originate Opaque-LSA/MPLS-TE: Area(%s), Link(%s)",
+                   new->data->type, inet_ntoa (new->data->id), area_id, lp->ifp->name);
       ospf_lsa_header_dump (new->data);
     }
 
@@ -963,7 +1339,7 @@ out:
 }
 
 static int
-ospf_mpls_te_lsa_originate (void *arg)
+ospf_mpls_te_lsa_originate_area (void *arg)
 {
   struct ospf_area *area = (struct ospf_area *) arg;
   struct listnode *node, *nnode;
@@ -972,34 +1348,44 @@ ospf_mpls_te_lsa_originate (void *arg)
 
   if (OspfMplsTE.status == disabled)
     {
-      zlog_info ("ospf_mpls_te_lsa_originate: MPLS-TE is disabled now.");
+      zlog_info ("ospf_mpls_te_lsa_originate_area: MPLS-TE is disabled now.");
       rc = 0; /* This is not an error case. */
       goto out;
     }
 
   for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
     {
+      /* Process only enabled LSA with area scope flooding */
+      if (!CHECK_FLAG (lp->flags, LPFLG_LSA_ACTIVE) || IS_FLOOD_AS (lp->type))
+        continue;
+
       if (lp->area == NULL)
         continue;
+
       if (! IPV4_ADDR_SAME (&lp->area->area_id, &area->area_id))
         continue;
 
-      if (lp->flags & LPFLG_LSA_ENGAGED)
+      if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
         {
-          if (lp->flags & LPFLG_LSA_FORCED_REFRESH)
+          if CHECK_FLAG (lp->flags, LPFLG_LSA_FORCED_REFRESH)
             {
-              lp->flags &= ~LPFLG_LSA_FORCED_REFRESH;
+              UNSET_FLAG (lp->flags, LPFLG_LSA_FORCED_REFRESH);
+              zlog_warn ("OSPF MPLS-TE (ospf_mpls_te_lsa_originate_area): Refresh instead of Originate");
               ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
             }
           continue;
         }
       if (! is_mandated_params_set (lp))
         {
-          zlog_warn ("ospf_mpls_te_lsa_originate: Link(%s) lacks some mandated MPLS-TE parameters.", lp->ifp ? lp->ifp->name : "?");
+          zlog_warn ("ospf_mpls_te_lsa_originate_area: Link(%s) lacks some mandated MPLS-TE parameters.",
+              lp->ifp ? lp->ifp->name : "?");
           continue;
         }
 
       /* Ok, let's try to originate an LSA for this area and Link. */
+      if (IS_DEBUG_OSPF_TE)
+        zlog_debug ("MPLS-TE(ospf_mpls_te_lsa_originate_area) Let's finally reoriginate the LSA %d through the Area %s for Link %s",
+                     lp->instance, inet_ntoa (area->area_id), lp->ifp ? lp->ifp->name : "?");
       if (ospf_mpls_te_lsa_originate1 (area, lp) != 0)
         goto out;
     }
@@ -1009,11 +1395,112 @@ out:
   return rc;
 }
 
+static int
+ospf_mpls_te_lsa_originate2 (struct ospf *top, struct mpls_te_link *lp)
+{
+  struct ospf_lsa *new;
+  int rc = -1;
+
+  /* Create new Opaque-LSA/Inter-AS instance. */
+  if ((new = ospf_mpls_te_lsa_new (NULL, lp)) == NULL)
+    {
+      zlog_warn ("ospf_mpls_te_lsa_originate2: ospf_router_info_lsa_new() ?");
+      goto out;
+    }
+
+  /* Install this LSA into LSDB. */
+  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)
+    {
+      zlog_warn ("ospf_mpls_te_lsa_originate2: ospf_lsa_install() ?");
+      ospf_lsa_unlock (&new);
+      goto out;
+    }
+
+  /* Now this Router Info parameter entry has associated LSA. */
+  SET_FLAG (lp->flags, LPFLG_LSA_ENGAGED);
+  /* Update new LSA origination count. */
+  top->lsa_originate_count++;
+
+  /* Flood new LSA through AS. */
+  ospf_flood_through_as (top, NULL /*nbr */ , new);
+
+  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
+    {
+      zlog_debug ("LSA[Type%d:%s]: Originate Opaque-LSA/MPLS-TE Inter-AS",
+                  new->data->type, inet_ntoa (new->data->id));
+      ospf_lsa_header_dump (new->data);
+    }
+
+  rc = 0;
+out:return rc;
+}
+
+static int
+ospf_mpls_te_lsa_originate_as (void *arg)
+{
+  struct ospf *top;
+  struct ospf_area *area;
+  struct listnode *node, *nnode;
+  struct mpls_te_link *lp;
+  int rc = -1;
+
+  if ((OspfMplsTE.status == disabled) || (OspfMplsTE.inter_as == Disable))
+    {
+      zlog_info
+        ("ospf_mpls_te_lsa_originate_as: MPLS-TE Inter-AS is disabled for now.");
+      rc = 0;                   /* This is not an error case. */
+      goto out;
+    }
+
+  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
+    {
+      /* Process only enabled INTER_AS Links or Pseudo-Links */
+      if (!CHECK_FLAG (lp->flags, LPFLG_LSA_ACTIVE) || !IS_INTER_AS (lp->type))
+        continue;
+
+      if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
+        {
+          if CHECK_FLAG (lp->flags, LPFLG_LSA_FORCED_REFRESH)
+            {
+              UNSET_FLAG (lp->flags, LPFLG_LSA_FORCED_REFRESH);
+              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
+            }
+          continue;
+        }
+      if (!is_mandated_params_set (lp))
+        {
+          zlog_warn ("ospf_mpls_te_lsa_originate_as: Link(%s) lacks some mandated MPLS-TE parameters.",
+             lp->ifp ? lp->ifp->name : "?");
+          continue;
+        }
+
+      /* Ok, let's try to originate an LSA for this AS and Link. */
+      if (IS_DEBUG_OSPF_TE)
+        zlog_debug ("MPLS-TE(ospf_mpls_te_lsa_originate_as) Let's finally re-originate the Inter-AS LSA %d through the %s for Link %s",
+                    lp->instance, IS_FLOOD_AS (lp->type) ? "AS" : "Area", lp->ifp ? lp->ifp->name : "Unknown");
+
+      if (IS_FLOOD_AS (lp->type))
+        {
+          top = (struct ospf *) arg;
+          rc = ospf_mpls_te_lsa_originate2 (top, lp);
+        }
+      else
+        {
+          area = (struct ospf_area *) arg;
+          rc = ospf_mpls_te_lsa_originate1 (area, lp);
+        }
+    }
+
+  rc = 0;
+out:return rc;
+}
+
 static struct ospf_lsa *
 ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa)
 {
   struct mpls_te_link *lp;
   struct ospf_area *area = lsa->area;
+  struct ospf *top;
   struct ospf_lsa *new = NULL;
 
   if (OspfMplsTE.status == disabled)
@@ -1033,11 +1520,18 @@ ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa)
       lsa->data->ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */
     }
 
+  /* Check if lp was not disable in the interval */
+  if (!CHECK_FLAG (lp->flags, LPFLG_LSA_ACTIVE))
+    {
+      zlog_warn ("ospf_mpls_te_lsa_refresh: lp was disabled: Flush it!");
+      lsa->data->ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */
+    }
+
   /* If the lsa's age reached to MaxAge, start flushing procedure. */
   if (IS_LSA_MAXAGE (lsa))
     {
       if (lp)
-        lp->flags &= ~LPFLG_LSA_ENGAGED;
+        UNSET_FLAG (lp->flags, LPFLG_LSA_ENGAGED);
       ospf_opaque_lsa_flush_schedule (lsa);
       goto out;
     }
@@ -1052,15 +1546,24 @@ ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa)
 
   /* Install this LSA into LSDB. */
   /* Given "lsa" will be freed in the next function. */
-  if (ospf_lsa_install (area->ospf, NULL/*oi*/, new) == NULL)
+  /* As area could be NULL i.e. when using OPAQUE_LSA_AS, we prefer to use ospf_lookup() to get ospf instance */
+  if (area)
+    top = area->ospf;
+  else
+    top = ospf_lookup ();
+
+  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)
     {
       zlog_warn ("ospf_mpls_te_lsa_refresh: ospf_lsa_install() ?");
       ospf_lsa_unlock (&new);
       goto out;
     }
 
-  /* Flood updated LSA through area. */
-  ospf_flood_through_area (area, NULL/*nbr*/, new);
+  /* Flood updated LSA through AS or Area depending of the RFC of the link */
+  if (IS_FLOOD_AS (lp->type))
+    ospf_flood_through_as (top, NULL, new);
+  else
+    ospf_flood_through_area (area, NULL/*nbr*/, new);
 
   /* Debug logging. */
   if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))
@@ -1074,34 +1577,80 @@ out:
   return new;
 }
 
-static void
-ospf_mpls_te_lsa_schedule (struct mpls_te_link *lp,
-                           enum sched_opcode opcode)
+void
+ospf_mpls_te_lsa_schedule (struct mpls_te_link *lp, opcode_t opcode)
 {
   struct ospf_lsa lsa;
   struct lsa_header lsah;
+  struct ospf *top;
   u_int32_t tmp;
 
   memset (&lsa, 0, sizeof (lsa));
   memset (&lsah, 0, sizeof (lsah));
+  top = ospf_lookup ();
+
+  /* Check if the pseudo link is ready to flood */
+  if (!(CHECK_FLAG (lp->flags, LPFLG_LSA_ACTIVE))
+      || !(IS_FLOOD_AREA (lp->type) || IS_FLOOD_AS (lp->type))) {
+    return;
+  }
 
   lsa.area = lp->area;
   lsa.data = &lsah;
-  lsah.type = OSPF_OPAQUE_AREA_LSA;
-  tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp->instance);
-  lsah.id.s_addr = htonl (tmp);
+  if (IS_FLOOD_AS (lp->type))
+    {
+      lsah.type = OSPF_OPAQUE_AS_LSA;
+      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp->instance);
+      lsah.id.s_addr = htonl (tmp);
+    }
+  else
+    {
+      lsah.type = OSPF_OPAQUE_AREA_LSA;
+      if (IS_INTER_AS (lp->type))
+        {
+          /* Set the area context if not know */
+          if (lp->area == NULL)
+            lp->area = ospf_area_lookup_by_area_id (top, OspfMplsTE.interas_areaid);
+          /* Unable to set the area context. Abort! */
+          if (lp->area == NULL)
+            {
+              zlog_warn ("MPLS-TE(ospf_mpls_te_lsa_schedule) Area context is null. Abort !");
+              return;
+            }
+          tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp->instance);
+        }
+      else
+        tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp->instance);
+      lsah.id.s_addr = htonl (tmp);
+    }
 
   switch (opcode)
     {
-    case REORIGINATE_PER_AREA:
-      ospf_opaque_lsa_reoriginate_schedule ((void *) lp->area,
-          OSPF_OPAQUE_AREA_LSA, OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA);
+    case REORIGINATE_THIS_LSA:
+      if (IS_FLOOD_AS (lp->type))
+        {
+          ospf_opaque_lsa_reoriginate_schedule ((void *) top, OSPF_OPAQUE_AS_LSA,
+              OPAQUE_TYPE_INTER_AS_LSA);
+          break;
+        }
+
+      if (IS_FLOOD_AREA (lp->type))
+        {
+          if (IS_INTER_AS (lp->type))
+            ospf_opaque_lsa_reoriginate_schedule ((void *) lp->area, OSPF_OPAQUE_AREA_LSA,
+                OPAQUE_TYPE_INTER_AS_LSA);
+          else
+            ospf_opaque_lsa_reoriginate_schedule ((void *) lp->area, OSPF_OPAQUE_AREA_LSA,
+                OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA);
+          break;
+        }
       break;
     case REFRESH_THIS_LSA:
       ospf_opaque_lsa_refresh_schedule (&lsa);
       break;
     case FLUSH_THIS_LSA:
-      lp->flags &= ~LPFLG_LSA_ENGAGED;
+      /* Reset Activity flag */
+      lp->flags = LPFLG_LSA_INACTIVE;
       ospf_opaque_lsa_flush_schedule (&lsa);
       break;
     default:
@@ -1112,6 +1661,7 @@ ospf_mpls_te_lsa_schedule (struct mpls_te_link *lp,
   return;
 }
 
+
 /*------------------------------------------------------------------------*
  * Followings are vty session control functions.
  *------------------------------------------------------------------------*/
@@ -1122,7 +1672,8 @@ show_vty_router_addr (struct vty *vty, struct te_tlv_header *tlvh)
   struct te_tlv_router_addr *top = (struct te_tlv_router_addr *) tlvh;
 
   if (vty != NULL)
-    vty_out (vty, "  Router-Address: %s%s", inet_ntoa (top->value), VTY_NEWLINE);
+    vty_out (vty, "  Router-Address: %s%s", inet_ntoa (top->value),
+             VTY_NEWLINE);
   else
     zlog_debug ("    Router-Address: %s", inet_ntoa (top->value));
 
@@ -1135,7 +1686,8 @@ show_vty_link_header (struct vty *vty, struct te_tlv_header *tlvh)
   struct te_tlv_link *top = (struct te_tlv_link *) tlvh;
 
   if (vty != NULL)
-    vty_out (vty, "  Link: %u octets of data%s", ntohs (top->header.length), VTY_NEWLINE);
+    vty_out (vty, "  Link: %u octets of data%s", ntohs (top->header.length),
+             VTY_NEWLINE);
   else
     zlog_debug ("    Link: %u octets of data", ntohs (top->header.length));
 
@@ -1162,7 +1714,8 @@ show_vty_link_subtlv_link_type (struct vty *vty, struct te_tlv_header *tlvh)
     }
 
   if (vty != NULL)
-    vty_out (vty, "  Link-Type: %s (%u)%s", cp, top->link_type.value, VTY_NEWLINE);
+    vty_out (vty, "  Link-Type: %s (%u)%s", cp, top->link_type.value,
+             VTY_NEWLINE);
   else
     zlog_debug ("    Link-Type: %s (%u)", cp, top->link_type.value);
 
@@ -1184,7 +1737,8 @@ show_vty_link_subtlv_link_id (struct vty *vty, struct te_tlv_header *tlvh)
 }
 
 static u_int16_t
-show_vty_link_subtlv_lclif_ipaddr (struct vty *vty, struct te_tlv_header *tlvh)
+show_vty_link_subtlv_lclif_ipaddr (struct vty *vty,
+                                   struct te_tlv_header *tlvh)
 {
   struct te_link_subtlv_lclif_ipaddr *top;
   int i, n;
@@ -1200,7 +1754,8 @@ show_vty_link_subtlv_lclif_ipaddr (struct vty *vty, struct te_tlv_header *tlvh)
   for (i = 0; i < n; i++)
     {
       if (vty != NULL)
-        vty_out (vty, "    #%d: %s%s", i, inet_ntoa (top->value[i]), VTY_NEWLINE);
+        vty_out (vty, "    #%d: %s%s", i, inet_ntoa (top->value[i]),
+                 VTY_NEWLINE);
       else
         zlog_debug ("      #%d: %s", i, inet_ntoa (top->value[i]));
     }
@@ -1208,7 +1763,8 @@ show_vty_link_subtlv_lclif_ipaddr (struct vty *vty, struct te_tlv_header *tlvh)
 }
 
 static u_int16_t
-show_vty_link_subtlv_rmtif_ipaddr (struct vty *vty, struct te_tlv_header *tlvh)
+show_vty_link_subtlv_rmtif_ipaddr (struct vty *vty,
+                                   struct te_tlv_header *tlvh)
 {
   struct te_link_subtlv_rmtif_ipaddr *top;
   int i, n;
@@ -1223,7 +1779,8 @@ show_vty_link_subtlv_rmtif_ipaddr (struct vty *vty, struct te_tlv_header *tlvh)
   for (i = 0; i < n; i++)
     {
       if (vty != NULL)
-        vty_out (vty, "    #%d: %s%s", i, inet_ntoa (top->value[i]), VTY_NEWLINE);
+        vty_out (vty, "    #%d: %s%s", i, inet_ntoa (top->value[i]),
+                 VTY_NEWLINE);
       else
         zlog_debug ("      #%d: %s", i, inet_ntoa (top->value[i]));
     }
@@ -1237,9 +1794,11 @@ show_vty_link_subtlv_te_metric (struct vty *vty, struct te_tlv_header *tlvh)
 
   top = (struct te_link_subtlv_te_metric *) tlvh;
   if (vty != NULL)
-    vty_out (vty, "  Traffic Engineering Metric: %u%s", (u_int32_t) ntohl (top->value), VTY_NEWLINE);
+    vty_out (vty, "  Traffic Engineering Metric: %u%s",
+             (u_int32_t) ntohl (top->value), VTY_NEWLINE);
   else
-    zlog_debug ("    Traffic Engineering Metric: %u", (u_int32_t) ntohl (top->value));
+    zlog_debug ("    Traffic Engineering Metric: %u",
+                (u_int32_t) ntohl (top->value));
 
   return TLV_SIZE (tlvh);
 }
@@ -1271,7 +1830,8 @@ show_vty_link_subtlv_max_rsv_bw (struct vty *vty, struct te_tlv_header *tlvh)
   ntohf (&top->value, &fval);
 
   if (vty != NULL)
-    vty_out (vty, "  Maximum Reservable Bandwidth: %g (Bytes/sec)%s", fval, VTY_NEWLINE);
+    vty_out (vty, "  Maximum Reservable Bandwidth: %g (Bytes/sec)%s", fval,
+             VTY_NEWLINE);
   else
     zlog_debug ("    Maximum Reservable Bandwidth: %g (Bytes/sec)", fval);
 
@@ -1282,17 +1842,25 @@ static u_int16_t
 show_vty_link_subtlv_unrsv_bw (struct vty *vty, struct te_tlv_header *tlvh)
 {
   struct te_link_subtlv_unrsv_bw *top;
-  float fval;
+  float fval1, fval2;
   int i;
 
   top = (struct te_link_subtlv_unrsv_bw *) tlvh;
-  for (i = 0; i < 8; i++)
+  if (vty != NULL)
+    vty_out (vty, "  Unreserved Bandwidth per Class Type in Byte/s:%s", VTY_NEWLINE);
+  else
+    zlog_debug ("    Unreserved Bandwidth per Class Type in Byte/s:");
+  for (i = 0; i < MAX_CLASS_TYPE; i+=2)
     {
-      ntohf (&top->value[i], &fval);
+      ntohf (&top->value[i], &fval1);
+      ntohf (&top->value[i+1], &fval2);
+
       if (vty != NULL)
-        vty_out (vty, "  Unreserved Bandwidth (pri %d): %g (Bytes/sec)%s", i, fval, VTY_NEWLINE);
+        vty_out(vty, "    [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)%s",
+                i, fval1, i+1, fval2, VTY_NEWLINE);
       else
-        zlog_debug ("    Unreserved Bandwidth (pri %d): %g (Bytes/sec)", i, fval);
+        zlog_debug ("      [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)",
+                    i, fval1, i+1, fval2);
     }
 
   return TLV_SIZE (tlvh);
@@ -1305,9 +1873,230 @@ show_vty_link_subtlv_rsc_clsclr (struct vty *vty, struct te_tlv_header *tlvh)
 
   top = (struct te_link_subtlv_rsc_clsclr *) tlvh;
   if (vty != NULL)
-    vty_out (vty, "  Resource class/color: 0x%x%s", (u_int32_t) ntohl (top->value), VTY_NEWLINE);
+    vty_out (vty, "  Resource class/color: 0x%x%s",
+             (u_int32_t) ntohl (top->value), VTY_NEWLINE);
+  else
+    zlog_debug ("    Resource Class/Color: 0x%x",
+                (u_int32_t) ntohl (top->value));
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_lrrid (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_lrrid *top;
+
+  top = (struct te_link_subtlv_lrrid *) tlvh;
+
+  if (vty != NULL)
+    {
+      vty_out (vty, "  Local  TE Router ID: %s%s", inet_ntoa (top->local),
+               VTY_NEWLINE);
+      vty_out (vty, "  Remote TE Router ID: %s%s", inet_ntoa (top->remote),
+               VTY_NEWLINE);
+    }
+  else
+    {
+      zlog_debug ("    Local  TE Router ID: %s", inet_ntoa (top->local));
+      zlog_debug ("    Remote TE Router ID: %s", inet_ntoa (top->remote));
+    }
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_llri (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_llri *top;
+
+  top = (struct te_link_subtlv_llri *) tlvh;
+
+  if (vty != NULL)
+    {
+      vty_out (vty, "  Link Local  ID: %d%s", (u_int32_t) ntohl (top->local),
+               VTY_NEWLINE);
+      vty_out (vty, "  Link Remote ID: %d%s", (u_int32_t) ntohl (top->remote),
+               VTY_NEWLINE);
+    }
+  else
+    {
+      zlog_debug ("    Link Local  ID: %d", (u_int32_t) ntohl (top->local));
+      zlog_debug ("    Link Remote ID: %d", (u_int32_t) ntohl (top->remote));
+    }
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_rip (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_rip *top;
+
+  top = (struct te_link_subtlv_rip *) tlvh;
+
+  if (vty != NULL)
+    vty_out (vty, "  Inter-AS TE Remote ASBR IP address: %s%s",
+             inet_ntoa (top->value), VTY_NEWLINE);
+  else
+    zlog_debug ("    Inter-AS TE Remote ASBR IP address: %s",
+                inet_ntoa (top->value));
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_ras (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_ras *top;
+
+  top = (struct te_link_subtlv_ras *) tlvh;
+
+  if (vty != NULL)
+    vty_out (vty, "  Inter-AS TE Remote AS number: %u%s", ntohl (top->value),
+             VTY_NEWLINE);
   else
-    zlog_debug ("    Resource Class/Color: 0x%x", (u_int32_t) ntohl (top->value));
+    zlog_debug ("    Inter-AS TE Remote AS number: %u", ntohl (top->value));
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_av_delay (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_av_delay *top;
+  u_int32_t delay;
+  u_int32_t anomalous;
+
+  top = (struct te_link_subtlv_av_delay *) tlvh;
+  delay = (u_int32_t) ntohl (top->value) & TE_EXT_MASK;
+  anomalous = (u_int32_t) ntohl (top->value) & TE_EXT_ANORMAL;
+
+  if (vty != NULL)
+    vty_out (vty, "  %s Average Link Delay: %d (micro-sec)%s",
+             anomalous ? "Anomalous" : "Normal", delay, VTY_NEWLINE);
+  else
+    zlog_debug ("    %s Average Link Delay: %d (micro-sec)",
+                anomalous ? "Anomalous" : "Normal", delay);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_mm_delay (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_mm_delay *top;
+  u_int32_t low, high;
+  u_int32_t anomalous;
+
+  top = (struct te_link_subtlv_mm_delay *) tlvh;
+  low = (u_int32_t) ntohl (top->low) & TE_EXT_MASK;
+  anomalous = (u_int32_t) ntohl (top->low) & TE_EXT_ANORMAL;
+  high = (u_int32_t) ntohl (top->high);
+
+  if (vty != NULL)
+    vty_out (vty, "  %s Min/Max Link Delay: %d/%d (micro-sec)%s",
+             anomalous ? "Anomalous" : "Normal", low, high, VTY_NEWLINE);
+  else
+    zlog_debug ("    %s Min/Max Link Delay: %d/%d (micro-sec)",
+                anomalous ? "Anomalous" : "Normal", low, high);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_delay_var (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_delay_var *top;
+  u_int32_t jitter;
+
+  top = (struct te_link_subtlv_delay_var *) tlvh;
+  jitter = (u_int32_t) ntohl (top->value) & TE_EXT_MASK;
+
+  if (vty != NULL)
+    vty_out (vty, "  Delay Variation: %d (micro-sec)%s", jitter, VTY_NEWLINE);
+  else
+    zlog_debug ("    Delay Variation: %d (micro-sec)", jitter);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_pkt_loss (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_pkt_loss *top;
+  u_int32_t loss;
+  u_int32_t anomalous;
+  float fval;
+
+  top = (struct te_link_subtlv_pkt_loss *) tlvh;
+  loss = (u_int32_t) ntohl (top->value) & TE_EXT_MASK;
+  fval = (float) (loss * LOSS_PRECISION);
+  anomalous = (u_int32_t) ntohl (top->value) & TE_EXT_ANORMAL;
+
+  if (vty != NULL)
+    vty_out (vty, "  %s Link Loss: %g (%%)%s", anomalous ? "Anomalous" : "Normal",
+             fval, VTY_NEWLINE);
+  else
+    zlog_debug ("    %s Link Loss: %g (%%)", anomalous ? "Anomalous" : "Normal",
+                fval);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_res_bw (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_res_bw *top;
+  float fval;
+
+  top = (struct te_link_subtlv_res_bw *) tlvh;
+  ntohf (&top->value, &fval);
+
+  if (vty != NULL)
+    vty_out (vty, "  Unidirectional Residual Bandwidth: %g (Bytes/sec)%s",
+             fval, VTY_NEWLINE);
+  else
+    zlog_debug ("    Unidirectional Residual Bandwidth: %g (Bytes/sec)",
+                fval);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_ava_bw (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_ava_bw *top;
+  float fval;
+
+  top = (struct te_link_subtlv_ava_bw *) tlvh;
+  ntohf (&top->value, &fval);
+
+  if (vty != NULL)
+    vty_out (vty, "  Unidirectional Available Bandwidth: %g (Bytes/sec)%s",
+             fval, VTY_NEWLINE);
+  else
+    zlog_debug ("    Unidirectional Available Bandwidth: %g (Bytes/sec)",
+                fval);
+
+  return TLV_SIZE (tlvh);
+}
+
+static u_int16_t
+show_vty_link_subtlv_use_bw (struct vty *vty, struct te_tlv_header *tlvh)
+{
+  struct te_link_subtlv_use_bw *top;
+  float fval;
+
+  top = (struct te_link_subtlv_use_bw *) tlvh;
+  ntohf (&top->value, &fval);
+
+  if (vty != NULL)
+    vty_out (vty, "  Unidirectional Utilized Bandwidth: %g (Bytes/sec)%s",
+             fval, VTY_NEWLINE);
+  else
+    zlog_debug ("    Unidirectional Utilized Bandwidth: %g (Bytes/sec)",
+                fval);
 
   return TLV_SIZE (tlvh);
 }
@@ -1316,9 +2105,11 @@ static u_int16_t
 show_vty_unknown_tlv (struct vty *vty, struct te_tlv_header *tlvh)
 {
   if (vty != NULL)
-    vty_out (vty, "  Unknown TLV: [type(0x%x), length(0x%x)]%s", ntohs (tlvh->type), ntohs (tlvh->length), VTY_NEWLINE);
+    vty_out (vty, "  Unknown TLV: [type(0x%x), length(0x%x)]%s",
+             ntohs (tlvh->type), ntohs (tlvh->length), VTY_NEWLINE);
   else
-    zlog_debug ("    Unknown TLV: [type(0x%x), length(0x%x)]", ntohs (tlvh->type), ntohs (tlvh->length));
+    zlog_debug ("    Unknown TLV: [type(0x%x), length(0x%x)]",
+                ntohs (tlvh->type), ntohs (tlvh->length));
 
   return TLV_SIZE (tlvh);
 }
@@ -1362,6 +2153,39 @@ ospf_mpls_te_show_link_subtlv (struct vty *vty, struct te_tlv_header *tlvh0,
         case TE_LINK_SUBTLV_RSC_CLSCLR:
           sum += show_vty_link_subtlv_rsc_clsclr (vty, tlvh);
           break;
+        case TE_LINK_SUBTLV_LRRID:
+          sum += show_vty_link_subtlv_lrrid (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_LLRI:
+          sum += show_vty_link_subtlv_llri (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_RIP:
+          sum += show_vty_link_subtlv_rip (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_RAS:
+          sum += show_vty_link_subtlv_ras (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_AV_DELAY:
+          sum += show_vty_link_subtlv_av_delay (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_MM_DELAY:
+          sum += show_vty_link_subtlv_mm_delay (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_DELAY_VAR:
+          sum += show_vty_link_subtlv_delay_var (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_PKT_LOSS:
+          sum += show_vty_link_subtlv_pkt_loss (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_RES_BW:
+          sum += show_vty_link_subtlv_res_bw (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_AVA_BW:
+          sum += show_vty_link_subtlv_ava_bw (vty, tlvh);
+          break;
+        case TE_LINK_SUBTLV_USE_BW:
+          sum += show_vty_link_subtlv_use_bw (vty, tlvh);
+          break;
         default:
           sum += show_vty_unknown_tlv (vty, tlvh);
           break;
@@ -1415,49 +2239,20 @@ ospf_mpls_te_show_info (struct vty *vty, struct ospf_lsa *lsa)
 static void
 ospf_mpls_te_config_write_router (struct vty *vty)
 {
+
   if (OspfMplsTE.status == enabled)
     {
-      vty_out (vty, "  mpls-te%s", VTY_NEWLINE);
+      vty_out (vty, "  mpls-te on%s", VTY_NEWLINE);
       vty_out (vty, "  mpls-te router-address %s%s",
                inet_ntoa (OspfMplsTE.router_addr.value), VTY_NEWLINE);
     }
-  return;
-}
 
-static void
-ospf_mpls_te_config_write_if (struct vty *vty, struct interface *ifp)
-{
-  struct mpls_te_link *lp;
-
-  if ((OspfMplsTE.status == enabled)
-  &&  (! if_is_loopback (ifp) && if_is_up (ifp) && ospf_oi_count (ifp) > 0)
-  &&  ((lp = lookup_linkparams_by_ifp (ifp)) != NULL))
-    {
-      float fval;
-      int i;
-
-      vty_out (vty, " mpls-te link metric %u%s",
-               (u_int32_t) ntohl (lp->te_metric.value), VTY_NEWLINE);
+  if (OspfMplsTE.inter_as == AS)
+    vty_out (vty, "  mpls-te inter-as as%s", VTY_NEWLINE);
+  if (OspfMplsTE.inter_as == Area)
+    vty_out (vty, "  mpls-te inter-as area %s %s",
+             inet_ntoa (OspfMplsTE.interas_areaid), VTY_NEWLINE);
 
-      ntohf (&lp->max_bw.value, &fval);
-      if (fval >= MPLS_TE_MINIMUM_BANDWIDTH)
-        vty_out (vty, " mpls-te link max-bw %g%s", fval, VTY_NEWLINE);
-
-      ntohf (&lp->max_rsv_bw.value, &fval);
-      if (fval >= MPLS_TE_MINIMUM_BANDWIDTH)
-        vty_out (vty, " mpls-te link max-rsv-bw %g%s", fval, VTY_NEWLINE);
-
-      for (i = 0; i < 8; i++)
-        {
-          ntohf (&lp->unrsv_bw.value[i], &fval);
-          if (fval >= MPLS_TE_MINIMUM_BANDWIDTH)
-            vty_out (vty, " mpls-te link unrsv-bw %d %g%s",
-                     i, fval, VTY_NEWLINE);
-        }
-
-      vty_out (vty, " mpls-te link rsc-clsclr 0x%x%s",
-               (u_int32_t) ntohl (lp->rsc_clsclr.value), VTY_NEWLINE);
-    }
   return;
 }
 
@@ -1465,13 +2260,13 @@ ospf_mpls_te_config_write_if (struct vty *vty, struct interface *ifp)
  * Followings are vty command functions.
  *------------------------------------------------------------------------*/
 
-DEFUN (mpls_te,
-       mpls_te_cmd,
-       "mpls-te",
-       "Configure MPLS-TE parameters\n"
+DEFUN (ospf_mpls_te_on,
+       ospf_mpls_te_on_cmd,
+       "mpls-te on",
+       MPLS_TE_STR
        "Enable the MPLS-TE functionality\n")
 {
-  struct listnode *node, *nnode;
+  struct listnode *node;
   struct mpls_te_link *lp;
 
   if (OspfMplsTE.status == enabled)
@@ -1482,31 +2277,28 @@ DEFUN (mpls_te,
 
   OspfMplsTE.status = enabled;
 
-  /*
-   * Following code is intended to handle two cases;
-   *
-   * 1) MPLS-TE was disabled at startup time, but now become enabled.
-   * 2) MPLS-TE was once enabled then disabled, and now enabled again.
-   */
-  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
-    initialize_linkparams (lp);
+  /* Reoriginate RFC3630 & RFC6827 Links */
+  ospf_mpls_te_foreach_area (ospf_mpls_te_lsa_schedule, REORIGINATE_THIS_LSA);
 
-  ospf_mpls_te_foreach_area (ospf_mpls_te_lsa_schedule, REORIGINATE_PER_AREA);
+  /* Reoriginate LSA if INTER-AS is always on */
+  if (OspfMplsTE.inter_as != Disable)
+    {
+      for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))
+        {
+          if (IS_INTER_AS (lp->type))
+            {
+              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);
+            }
+        }
+    }
 
   return CMD_SUCCESS;
 }
 
-ALIAS (mpls_te,
-       mpls_te_on_cmd,
-       "mpls-te on",
-       "Configure MPLS-TE parameters\n"
-       "Enable the MPLS-TE functionality\n")
-
-DEFUN (no_mpls_te,
-       no_mpls_te_cmd,
+DEFUN (no_ospf_mpls_te,
+       no_ospf_mpls_te_cmd,
        "no mpls-te",
        NO_STR
-       "Configure MPLS-TE parameters\n"
        "Disable the MPLS-TE functionality\n")
 {
   struct listnode *node, *nnode;
@@ -1521,17 +2313,16 @@ DEFUN (no_mpls_te,
   OspfMplsTE.status = disabled;
 
   for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
-    if (lp->area != NULL)
-      if (lp->flags & LPFLG_LSA_ENGAGED)
+    if CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED)
         ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
 
   return CMD_SUCCESS;
 }
 
-DEFUN (mpls_te_router_addr,
-       mpls_te_router_addr_cmd,
+DEFUN (ospf_mpls_te_router_addr,
+       ospf_mpls_te_router_addr_cmd,
        "mpls-te router-address A.B.C.D",
-       "MPLS-TE specific commands\n"
+       MPLS_TE_STR
        "Stable IP address of the advertising router\n"
        "MPLS-TE router address in IPv4 address format\n")
 {
@@ -1558,10 +2349,10 @@ DEFUN (mpls_te_router_addr,
 
       for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
         {
-          if (lp->area == NULL)
+          if ((lp->area == NULL) || IS_FLOOD_AS (lp->type))
             continue;
 
-          if ((lp->flags & LPFLG_LSA_ENGAGED) == 0)
+          if (!CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED))
             {
               need_to_reoriginate = 1;
               break;
@@ -1570,247 +2361,152 @@ DEFUN (mpls_te_router_addr,
       
       for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
         {
-          if (lp->area == NULL)
+          if ((lp->area == NULL) || IS_FLOOD_AS (lp->type))
             continue;
 
           if (need_to_reoriginate)
-            lp->flags |= LPFLG_LSA_FORCED_REFRESH;
+            SET_FLAG (lp->flags, LPFLG_LSA_FORCED_REFRESH);
           else
             ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
         }
 
       if (need_to_reoriginate)
-        ospf_mpls_te_foreach_area (
-            ospf_mpls_te_lsa_schedule, REORIGINATE_PER_AREA);
+        ospf_mpls_te_foreach_area (ospf_mpls_te_lsa_schedule, REORIGINATE_THIS_LSA);
     }
 out:
   return CMD_SUCCESS;
 }
 
-DEFUN (mpls_te_link_metric,
-       mpls_te_link_metric_cmd,
-       "mpls-te link metric <0-4294967295>",
-       "MPLS-TE specific commands\n"
-       "Configure MPLS-TE link parameters\n"
-       "Link metric for MPLS-TE purpose\n"
-       "Metric\n")
+static int
+set_inter_as_mode (struct vty *vty, const char *mode_name,
+                   const char *area_id)
 {
-  struct interface *ifp = (struct interface *) vty->index;
+  enum inter_as_mode mode;
+  struct listnode *node;
   struct mpls_te_link *lp;
-  u_int32_t value;
+  int format;
 
-  if ((lp = lookup_linkparams_by_ifp (ifp)) == NULL)
-    {
-      vty_out (vty, "mpls_te_link_metric: Something wrong!%s", VTY_NEWLINE);
-      return CMD_WARNING;
-    }
-
-  value = strtoul (argv[0], NULL, 10);
-
-  if (ntohs (lp->te_metric.header.type) == 0
-  ||  ntohl (lp->te_metric.value) != value)
+  if (OspfMplsTE.status == enabled)
     {
-      set_linkparams_te_metric (lp, value);
-
-      if (OspfMplsTE.status == enabled)
-        if (lp->area != NULL)
-          {
-            if (lp->flags & LPFLG_LSA_ENGAGED)
-              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
-            else
-              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
-          }
-    }
-  return CMD_SUCCESS;
-}
 
-DEFUN (mpls_te_link_maxbw,
-       mpls_te_link_maxbw_cmd,
-       "mpls-te link max-bw BANDWIDTH",
-       "MPLS-TE specific commands\n"
-       "Configure MPLS-TE link parameters\n"
-       "Maximum bandwidth that can be used\n"
-       "Bytes/second (IEEE floating point format)\n")
-{
-  struct interface *ifp = (struct interface *) vty->index;
-  struct mpls_te_link *lp;
-  float f1, f2;
-
-  if ((lp = lookup_linkparams_by_ifp (ifp)) == NULL)
-    {
-      vty_out (vty, "mpls_te_link_maxbw: Something wrong!%s", VTY_NEWLINE);
-      return CMD_WARNING;
-    }
+      /* Read and Check inter_as mode */
+      if (strcmp (mode_name, "as") == 0)
+        mode = AS;
+      else if (strcmp (mode_name, "area") == 0)
+        {
+          mode = Area;
+          VTY_GET_OSPF_AREA_ID (OspfMplsTE.interas_areaid, format, area_id);
+        }
+      else
+        {
+          vty_out (vty, "Unknown mode. Please choose between as or area%s",
+                   VTY_NEWLINE);
+          return CMD_WARNING;
+        }
 
-  ntohf (&lp->max_bw.value, &f1);
-  if (sscanf (argv[0], "%g", &f2) != 1)
-    {
-      vty_out (vty, "mpls_te_link_maxbw: fscanf: %s%s", safe_strerror (errno), VTY_NEWLINE);
-      return CMD_WARNING;
-    }
+      if (IS_DEBUG_OSPF_EVENT)
+        zlog_debug ("MPLS-TE: Inter-AS enable with %s flooding support",
+                    mode2text[mode]);
 
-  if (ntohs (lp->max_bw.header.type) == 0
-  ||  f1 != f2)
-    {
-      set_linkparams_max_bw (lp, &f2);
+      /* Register new callbacks regarding the flooding scope (AS or Area) */
+      if (ospf_mpls_te_register (mode) < 0)
+        {
+          vty_out (vty, "Internal error: Unable to register Inter-AS functions%s",
+                   VTY_NEWLINE);
+          return CMD_WARNING;
+        }
 
-      if (OspfMplsTE.status == enabled)
-        if (lp->area != NULL)
-          {
-            if (lp->flags & LPFLG_LSA_ENGAGED)
-              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
-            else
-              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
-          }
+      /* Enable mode and re-originate LSA if needed */
+      if ((OspfMplsTE.inter_as == Disable) && (mode != OspfMplsTE.inter_as))
+        {
+          OspfMplsTE.inter_as = mode;
+          /* Re-originate all InterAS-TEv2 LSA */
+          for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))
+            {
+              if (IS_INTER_AS (lp->type))
+                {
+                  if (mode == AS)
+                    lp->type |= FLOOD_AS;
+                  else
+                    lp->type |= FLOOD_AREA;
+                  ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);
+                }
+            }
+        }
+      else
+        {
+          vty_out (vty, "Please change Inter-AS support to disable first before going to mode %s%s",
+                   mode2text[mode], VTY_NEWLINE);
+          return CMD_WARNING;
+        }
     }
   return CMD_SUCCESS;
 }
 
-DEFUN (mpls_te_link_max_rsv_bw,
-       mpls_te_link_max_rsv_bw_cmd,
-       "mpls-te link max-rsv-bw BANDWIDTH",
-       "MPLS-TE specific commands\n"
-       "Configure MPLS-TE link parameters\n"
-       "Maximum bandwidth that may be reserved\n"
-       "Bytes/second (IEEE floating point format)\n")
-{
-  struct interface *ifp = (struct interface *) vty->index;
-  struct mpls_te_link *lp;
-  float f1, f2;
-
-  if ((lp = lookup_linkparams_by_ifp (ifp)) == NULL)
-    {
-      vty_out (vty, "mpls_te_link_max_rsv_bw: Something wrong!%s", VTY_NEWLINE);
-      return CMD_WARNING;
-    }
 
-  ntohf (&lp->max_rsv_bw.value, &f1);
-  if (sscanf (argv[0], "%g", &f2) != 1)
-    {
-      vty_out (vty, "mpls_te_link_max_rsv_bw: fscanf: %s%s", safe_strerror (errno), VTY_NEWLINE);
-      return CMD_WARNING;
-    }
-
-  if (ntohs (lp->max_rsv_bw.header.type) == 0
-  ||  f1 != f2)
-    {
-      set_linkparams_max_rsv_bw (lp, &f2);
-
-      if (OspfMplsTE.status == enabled)
-        if (lp->area != NULL)
-          {
-            if (lp->flags & LPFLG_LSA_ENGAGED)
-              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
-            else
-              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
-          }
-    }
-  return CMD_SUCCESS;
+DEFUN (ospf_mpls_te_inter_as_as,
+       ospf_mpls_te_inter_as_cmd,
+       "mpls-te inter-as as",
+       MPLS_TE_STR
+       "Configure MPLS-TE Inter-AS support\n"
+       "AS native mode self originate INTER_AS LSA with Type 11 (as flooding scope)\n")
+{
+  return set_inter_as_mode (vty, "as", "");
 }
 
-DEFUN (mpls_te_link_unrsv_bw,
-       mpls_te_link_unrsv_bw_cmd,
-       "mpls-te link unrsv-bw <0-7> BANDWIDTH",
-       "MPLS-TE specific commands\n"
-       "Configure MPLS-TE link parameters\n"
-       "Unreserved bandwidth at each priority level\n"
-       "Priority\n"
-       "Bytes/second (IEEE floating point format)\n")
+DEFUN (ospf_mpls_te_inter_as_area,
+       ospf_mpls_te_inter_as_area_cmd,
+       "mpls-te inter-as area (A.B.C.D|<0-4294967295>)",
+       MPLS_TE_STR
+       "Configure MPLS-TE Inter-AS support\n"
+       "AREA native mode self originate INTER_AS LSA with Type 10 (area flooding scope)\n"
+       "OSPF area ID in IP format\n"
+       "OSPF area ID as decimal value\n")
 {
-  struct interface *ifp = (struct interface *) vty->index;
-  struct mpls_te_link *lp;
-  int priority;
-  float f1, f2;
-
-  if ((lp = lookup_linkparams_by_ifp (ifp)) == NULL)
-    {
-      vty_out (vty, "mpls_te_link_unrsv_bw: Something wrong!%s", VTY_NEWLINE);
-      return CMD_WARNING;
-    }
-
-  /* We don't have to consider about range check here. */
-  if (sscanf (argv[0], "%d", &priority) != 1)
-    {
-      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno), VTY_NEWLINE);
-      return CMD_WARNING;
-    }
-
-  ntohf (&lp->unrsv_bw.value [priority], &f1);
-  if (sscanf (argv[1], "%g", &f2) != 1)
-    {
-      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno), VTY_NEWLINE);
-      return CMD_WARNING;
-    }
-
-  if (ntohs (lp->unrsv_bw.header.type) == 0
-  ||  f1 != f2)
-    {
-      set_linkparams_unrsv_bw (lp, priority, &f2);
-
-      if (OspfMplsTE.status == enabled)
-        if (lp->area != NULL)
-          {
-            if (lp->flags & LPFLG_LSA_ENGAGED)
-              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
-            else
-              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
-          }
-    }
-  return CMD_SUCCESS;
+  return set_inter_as_mode (vty, "area", argv[0]);
 }
 
-DEFUN (mpls_te_link_rsc_clsclr,
-       mpls_te_link_rsc_clsclr_cmd,
-       "mpls-te link rsc-clsclr BITPATTERN",
-       "MPLS-TE specific commands\n"
-       "Configure MPLS-TE link parameters\n"
-       "Administrative group membership\n"
-       "32-bit Hexadecimal value (ex. 0xa1)\n")
+DEFUN (no_ospf_mpls_te_inter_as,
+       no_ospf_mpls_te_inter_as_cmd,
+       "no mpls-te inter-as",
+       NO_STR
+       MPLS_TE_STR
+       "Disable MPLS-TE Inter-AS support\n")
 {
-  struct interface *ifp = (struct interface *) vty->index;
+
+  struct listnode *node, *nnode;
   struct mpls_te_link *lp;
-  unsigned long value;
 
-  if ((lp = lookup_linkparams_by_ifp (ifp)) == NULL)
-    {
-      vty_out (vty, "mpls_te_link_rsc_clsclr: Something wrong!%s", VTY_NEWLINE);
-      return CMD_WARNING;
-    }
+  if (IS_DEBUG_OSPF_EVENT)
+    zlog_debug ("MPLS-TE: Inter-AS support OFF");
 
-  if (sscanf (argv[0], "0x%lx", &value) != 1)
+  if ((OspfMplsTE.status == enabled) && (OspfMplsTE.inter_as != Disable))
     {
-      vty_out (vty, "mpls_te_link_rsc_clsclr: fscanf: %s%s", safe_strerror (errno), VTY_NEWLINE);
-      return CMD_WARNING;
+      OspfMplsTE.inter_as = Disable;
+      /* Flush all Inter-AS LSA */
+      for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))
+        if (IS_INTER_AS (lp->type) && CHECK_FLAG (lp->flags, LPFLG_LSA_ENGAGED))
+          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);
     }
 
-  if (ntohs (lp->rsc_clsclr.header.type) == 0
-  ||  ntohl (lp->rsc_clsclr.value) != value)
-    {
-      set_linkparams_rsc_clsclr (lp, value);
+  /* Deregister the Callbacks for Inter-AS suport */
+  ospf_mpls_te_unregister ();
 
-      if (OspfMplsTE.status == enabled)
-        if (lp->area != NULL)
-          {
-            if (lp->flags & LPFLG_LSA_ENGAGED)
-              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);
-            else
-              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_PER_AREA);
-          }
-    }
   return CMD_SUCCESS;
 }
 
-DEFUN (show_mpls_te_router,
-       show_mpls_te_router_cmd,
-       "show mpls-te router",
+DEFUN (show_ip_ospf_mpls_te_router,
+       show_ip_ospf_mpls_te_router_cmd,
+       "show ip ospf mpls-te router",
        SHOW_STR
+       IP_STR
+       OSPF_STR
        "MPLS-TE information\n"
-       "Router information\n")
+       "MPLS-TE Router parameters\n")
 {
   if (OspfMplsTE.status == enabled)
     {
-      vty_out (vty, "--- MPLS-TE router parameters ---%s",
-               VTY_NEWLINE);
+      vty_out (vty, "--- MPLS-TE router parameters ---%s", VTY_NEWLINE);
 
       if (ntohs (OspfMplsTE.router_addr.header.type) != 0)
         show_vty_router_addr (vty, &OspfMplsTE.router_addr.header);
@@ -1824,29 +2520,70 @@ static void
 show_mpls_te_link_sub (struct vty *vty, struct interface *ifp)
 {
   struct mpls_te_link *lp;
-  struct te_tlv_header *tlvh;
 
-  if ((OspfMplsTE.status == enabled)
-  &&  (! if_is_loopback (ifp) && if_is_up (ifp) && ospf_oi_count (ifp) > 0)
-  &&  ((lp = lookup_linkparams_by_ifp (ifp)) != NULL))
+  if ((OspfMplsTE.status == enabled) && IS_LINK_TE(ifp) && (!if_is_loopback (ifp) && if_is_up (ifp))
+      && ((lp = lookup_linkparams_by_ifp (ifp)) != NULL))
     {
+      /* Continue only if interface is not passive or support Inter-AS TEv2 */
+      if (!(ospf_oi_count (ifp) > 0))
+        {
+          if (IS_INTER_AS (lp->type))
+            {
+              vty_out (vty, "-- Inter-AS TEv2 link parameters for %s --%s",
+                       ifp->name, VTY_NEWLINE);
+            }
+          else
+            {
+              /* MPLS-TE is not activate on this interface */
+              /* or this interface is passive and Inter-AS TEv2 is not activate */
+              vty_out (vty, "  %s: MPLS-TE is disabled on this interface%s",
+                       ifp->name, VTY_NEWLINE);
+              return;
+            }
+        }
+      else
+        {
       vty_out (vty, "-- MPLS-TE link parameters for %s --%s",
                ifp->name, VTY_NEWLINE);
+        }
 
-      show_vty_link_subtlv_link_type (vty, &lp->link_type.header);
-      show_vty_link_subtlv_link_id (vty, &lp->link_id.header);
-
-      if ((tlvh = (struct te_tlv_header *) lp->lclif_ipaddr) != NULL)
-        show_vty_link_subtlv_lclif_ipaddr (vty, tlvh);
-      if ((tlvh = (struct te_tlv_header *) lp->rmtif_ipaddr) != NULL)
-        show_vty_link_subtlv_rmtif_ipaddr (vty, tlvh);
-
-      show_vty_link_subtlv_te_metric (vty, &lp->te_metric.header);
-
-      show_vty_link_subtlv_max_bw (vty, &lp->max_bw.header);
-      show_vty_link_subtlv_max_rsv_bw (vty, &lp->max_rsv_bw.header);
-      show_vty_link_subtlv_unrsv_bw (vty, &lp->unrsv_bw.header);
-      show_vty_link_subtlv_rsc_clsclr (vty, &lp->rsc_clsclr.header);
+      if (TLV_TYPE(lp->link_type) != 0)
+        show_vty_link_subtlv_link_type (vty, &lp->link_type.header);
+      if (TLV_TYPE(lp->link_id) != 0)
+        show_vty_link_subtlv_link_id (vty, &lp->link_id.header);
+      if (TLV_TYPE(lp->lclif_ipaddr) != 0)
+        show_vty_link_subtlv_lclif_ipaddr (vty, &lp->lclif_ipaddr.header);
+      if (TLV_TYPE(lp->rmtif_ipaddr) != 0)
+        show_vty_link_subtlv_rmtif_ipaddr (vty, &lp->rmtif_ipaddr.header);
+      if (TLV_TYPE(lp->rip) != 0)
+        show_vty_link_subtlv_rip (vty, &lp->rip.header);
+      if (TLV_TYPE(lp->ras) != 0)
+        show_vty_link_subtlv_ras (vty, &lp->ras.header);
+      if (TLV_TYPE(lp->te_metric) != 0)
+        show_vty_link_subtlv_te_metric (vty, &lp->te_metric.header);
+      if (TLV_TYPE(lp->max_bw) != 0)
+        show_vty_link_subtlv_max_bw (vty, &lp->max_bw.header);
+      if (TLV_TYPE(lp->max_rsv_bw) != 0)
+        show_vty_link_subtlv_max_rsv_bw (vty, &lp->max_rsv_bw.header);
+      if (TLV_TYPE(lp->unrsv_bw) != 0)
+        show_vty_link_subtlv_unrsv_bw (vty, &lp->unrsv_bw.header);
+      if (TLV_TYPE(lp->rsc_clsclr) != 0)
+        show_vty_link_subtlv_rsc_clsclr (vty, &lp->rsc_clsclr.header);
+      if (TLV_TYPE(lp->av_delay) != 0)
+        show_vty_link_subtlv_av_delay (vty, &lp->av_delay.header);
+      if (TLV_TYPE(lp->mm_delay) != 0)
+        show_vty_link_subtlv_mm_delay (vty, &lp->mm_delay.header);
+      if (TLV_TYPE(lp->delay_var) != 0)
+        show_vty_link_subtlv_delay_var (vty, &lp->delay_var.header);
+      if (TLV_TYPE(lp->pkt_loss) != 0)
+        show_vty_link_subtlv_pkt_loss (vty, &lp->pkt_loss.header);
+      if (TLV_TYPE(lp->res_bw) != 0)
+        show_vty_link_subtlv_res_bw (vty, &lp->res_bw.header);
+      if (TLV_TYPE(lp->ava_bw) != 0)
+        show_vty_link_subtlv_ava_bw (vty, &lp->ava_bw.header);
+      if (TLV_TYPE(lp->use_bw) != 0)
+        show_vty_link_subtlv_use_bw (vty, &lp->use_bw.header);
+      vty_out (vty, "---------------%s%s", VTY_NEWLINE, VTY_NEWLINE);
     }
   else
     {
@@ -1857,10 +2594,12 @@ show_mpls_te_link_sub (struct vty *vty, struct interface *ifp)
   return;
 }
 
-DEFUN (show_mpls_te_link,
-       show_mpls_te_link_cmd,
-       "show mpls-te interface [INTERFACE]",
+DEFUN (show_ip_ospf_mpls_te_link,
+       show_ip_ospf_mpls_te_link_cmd,
+       "show ip ospf mpls-te interface [INTERFACE]",
        SHOW_STR
+       IP_STR
+       OSPF_STR
        "MPLS-TE information\n"
        "Interface information\n"
        "Interface name\n")
@@ -1889,21 +2628,17 @@ DEFUN (show_mpls_te_link,
 static void
 ospf_mpls_te_register_vty (void)
 {
-  install_element (VIEW_NODE, &show_mpls_te_router_cmd);
-  install_element (VIEW_NODE, &show_mpls_te_link_cmd);
-  install_element (ENABLE_NODE, &show_mpls_te_router_cmd);
-  install_element (ENABLE_NODE, &show_mpls_te_link_cmd);
-
-  install_element (OSPF_NODE, &mpls_te_cmd);
-  install_element (OSPF_NODE, &no_mpls_te_cmd);
-  install_element (OSPF_NODE, &mpls_te_on_cmd);
-  install_element (OSPF_NODE, &mpls_te_router_addr_cmd);
-
-  install_element (INTERFACE_NODE, &mpls_te_link_metric_cmd);
-  install_element (INTERFACE_NODE, &mpls_te_link_maxbw_cmd);
-  install_element (INTERFACE_NODE, &mpls_te_link_max_rsv_bw_cmd);
-  install_element (INTERFACE_NODE, &mpls_te_link_unrsv_bw_cmd);
-  install_element (INTERFACE_NODE, &mpls_te_link_rsc_clsclr_cmd);
+  install_element (VIEW_NODE, &show_ip_ospf_mpls_te_router_cmd);
+  install_element (VIEW_NODE, &show_ip_ospf_mpls_te_link_cmd);
+  install_element (ENABLE_NODE, &show_ip_ospf_mpls_te_router_cmd);
+  install_element (ENABLE_NODE, &show_ip_ospf_mpls_te_link_cmd);
+
+  install_element (OSPF_NODE, &ospf_mpls_te_on_cmd);
+  install_element (OSPF_NODE, &no_ospf_mpls_te_cmd);
+  install_element (OSPF_NODE, &ospf_mpls_te_router_addr_cmd);
+  install_element (OSPF_NODE, &ospf_mpls_te_inter_as_cmd);
+  install_element (OSPF_NODE, &ospf_mpls_te_inter_as_area_cmd);
+  install_element (OSPF_NODE, &no_ospf_mpls_te_inter_as_cmd);
 
   return;
 }
diff --git a/ospfd/ospf_te.h b/ospfd/ospf_te.h
index 863d8ba..bb01e64 100644
--- a/ospfd/ospf_te.h
+++ b/ospfd/ospf_te.h
@@ -1,8 +1,11 @@
 /*
- * This is an implementation of draft-katz-yeung-ospf-traffic-06.txt
+ * This is an implementation of RFC3630, RFC5392 & RFC6827
  * Copyright (C) 2001 KDD R&D Laboratories, Inc.
  * http://www.kddlabs.co.jp/
  *
+ * Copyright (C) 2012 Orange Labs
+ * http://www.orange.com
+ *
  * This file is part of GNU Zebra.
  *
  * GNU Zebra is free software; you can redistribute it and/or modify it
@@ -21,6 +24,10 @@
  * 02111-1307, USA.
  */
 
+/* Add support to draft-ietf-ospf-te-metric-extensions-05 */
+/* Add support of RFC5392 */
+/* Add support of RFC6827 (partial) */
+
 #ifndef _ZEBRA_OSPF_MPLS_TE_H
 #define _ZEBRA_OSPF_MPLS_TE_H
 
@@ -42,6 +49,7 @@
  */
 
 #define	MAX_LEGAL_TE_INSTANCE_NUM (0xffff)
+#define LEGAL_TE_INSTANCE_RANGE(i)  (0 <= (i) && (i) <= 0xffff)
 
 /*
  *        24       16        8        0
@@ -62,6 +70,31 @@
  * +--------+--------+--------+--------+ ---
  */
 
+/* Following define the type of TE link regarding the various RFC */
+#define STD_TE  	0x01
+#define GMPLS   	0x02
+#define INTER_AS	0x04
+#define PSEUDO_TE	0x08
+#define FLOOD_AREA	0x10
+#define FLOOD_AS	0x20
+#define EMULATED	0x80
+
+#define IS_STD_TE(x)	        (x & STD_TE)
+#define IS_PSEUDO_TE(x)		(x & PSEUDO_TE)
+#define IS_INTER_AS(x) 		(x & INTER_AS)
+#define IS_EMULATED(x)		(x & EMULATED)
+#define IS_FLOOD_AREA(x)	(x & FLOOD_AREA)
+#define IS_FLOOD_AS(x)		(x & FLOOD_AS)
+#define IS_INTER_AS_EMU(x) 	(x & INTER_AS & EMULATED)
+#define IS_INTER_AS_AS(x)	(x & INTER_AS & FLOOD_AS)
+
+/* Flags to manage TE Link LSA */
+#define LPFLG_LSA_INACTIVE		0x0
+#define LPFLG_LSA_ACTIVE		0x1
+#define LPFLG_LSA_ENGAGED		0x2
+#define LPFLG_LOOKUP_DONE		0x4
+#define LPFLG_LSA_FORCED_REFRESH	0x8
+
 /*
  * Following section defines TLV (tag, length, value) structures,
  * used for Traffic Engineering.
@@ -87,10 +120,18 @@ struct te_tlv_header
 #define TLV_HDR_NEXT(tlvh) \
 	(struct te_tlv_header *)((char *)(tlvh) + TLV_SIZE(tlvh))
 
+#define TLV_HDR_SUBTLV(tlvh) \
+	(struct te_tlv_header *)((char *)(tlvh) + TLV_HDR_SIZE)
+
+#define TLV_TYPE(tlvh)     tlvh.header.type
+#define TLV_LEN(tlvh)      tlvh.header.length
+#define TLV_HDR(tlvh)      tlvh.header
+
+
 /*
  * Following section defines TLV body parts.
  */
-/* Router Address TLV *//* Mandatory */
+/* Router Address TLV */ /* Mandatory */
 #define	TE_TLV_ROUTER_ADDR		1
 struct te_tlv_router_addr
 {
@@ -106,12 +147,16 @@ struct te_tlv_link
   /* A set of link-sub-TLVs will follow. */
 };
 
-/* Link Type Sub-TLV *//* Mandatory */
-#define	TE_LINK_SUBTLV_LINK_TYPE		1
+#define TE_LINK_SUBTLV_DEF_SIZE		4
+
+/* Link Type Sub-TLV */ /* Mandatory */
+#define	TE_LINK_SUBTLV_LINK_TYPE	1
+#define TE_LINK_SUBTLV_TYPE_SIZE	1
 struct te_link_subtlv_link_type
 {
   struct te_tlv_header	header;		/* Value length is 1 octet. */
-  struct {
+  struct
+  {
 #define	LINK_TYPE_SUBTLV_VALUE_PTP	1
 #define	LINK_TYPE_SUBTLV_VALUE_MA	2
       u_char	value;
@@ -119,75 +164,301 @@ struct te_link_subtlv_link_type
   } link_type;
 };
 
-/* Link Sub-TLV: Link ID *//* Mandatory */
-#define	TE_LINK_SUBTLV_LINK_ID			2
+/* Link Sub-TLV: Link ID */ /* Mandatory */
+#define	TE_LINK_SUBTLV_LINK_ID		2
 struct te_link_subtlv_link_id
 {
   struct te_tlv_header	header;		/* Value length is 4 octets. */
   struct in_addr	value;		/* Same as router-lsa's link-id. */
 };
 
-/* Link Sub-TLV: Local Interface IP Address *//* Optional */
-#define	TE_LINK_SUBTLV_LCLIF_IPADDR		3
+/* Link Sub-TLV: Local Interface IP Address */ /* Optional */
+#define	TE_LINK_SUBTLV_LCLIF_IPADDR	3
 struct te_link_subtlv_lclif_ipaddr
 {
   struct te_tlv_header	header;		/* Value length is 4 x N octets. */
   struct in_addr	value[1];	/* Local IP address(es). */
 };
 
-/* Link Sub-TLV: Remote Interface IP Address *//* Optional */
-#define	TE_LINK_SUBTLV_RMTIF_IPADDR		4
+/* Link Sub-TLV: Remote Interface IP Address */ /* Optional */
+#define	TE_LINK_SUBTLV_RMTIF_IPADDR	4
 struct te_link_subtlv_rmtif_ipaddr
 {
   struct te_tlv_header	header;		/* Value length is 4 x N octets. */
   struct in_addr	value[1];	/* Neighbor's IP address(es). */
 };
 
-/* Link Sub-TLV: Traffic Engineering Metric *//* Optional */
-#define	TE_LINK_SUBTLV_TE_METRIC		5
+/* Link Sub-TLV: Traffic Engineering Metric */ /* Optional */
+#define	TE_LINK_SUBTLV_TE_METRIC	5
 struct te_link_subtlv_te_metric
 {
   struct te_tlv_header	header;		/* Value length is 4 octets. */
   u_int32_t		value;		/* Link metric for TE purpose. */
 };
 
-/* Link Sub-TLV: Maximum Bandwidth *//* Optional */
-#define	TE_LINK_SUBTLV_MAX_BW			6
+/* Link Sub-TLV: Maximum Bandwidth */ /* Optional */
+#define	TE_LINK_SUBTLV_MAX_BW		6
 struct te_link_subtlv_max_bw
 {
   struct te_tlv_header	header;		/* Value length is 4 octets. */
   float			value;		/* bytes/sec */
 };
 
-/* Link Sub-TLV: Maximum Reservable Bandwidth *//* Optional */
-#define	TE_LINK_SUBTLV_MAX_RSV_BW		7
+/* Link Sub-TLV: Maximum Reservable Bandwidth */ /* Optional */
+#define	TE_LINK_SUBTLV_MAX_RSV_BW	7
 struct te_link_subtlv_max_rsv_bw
 {
   struct te_tlv_header	header;		/* Value length is 4 octets. */
   float			value;		/* bytes/sec */
 };
 
-/* Link Sub-TLV: Unreserved Bandwidth *//* Optional */
-#define	TE_LINK_SUBTLV_UNRSV_BW			8
+/* Link Sub-TLV: Unreserved Bandwidth */ /* Optional */
+#define	TE_LINK_SUBTLV_UNRSV_BW		8
+#define TE_LINK_SUBTLV_UNRSV_SIZE	32
 struct te_link_subtlv_unrsv_bw
 {
   struct te_tlv_header	header;		/* Value length is 32 octets. */
-  float			value[8];	/* One for each priority level. */
+  float			value[MAX_CLASS_TYPE];	/* One for each priority level. */
 };
 
-/* Link Sub-TLV: Resource Class/Color *//* Optional */
-#define	TE_LINK_SUBTLV_RSC_CLSCLR		9
+/* Link Sub-TLV: Resource Class/Color */ /* Optional */
+#define	TE_LINK_SUBTLV_RSC_CLSCLR	9
 struct te_link_subtlv_rsc_clsclr
 {
   struct te_tlv_header	header;		/* Value length is 4 octets. */
   u_int32_t		value;		/* Admin. group membership. */
 };
 
-/* Here are "non-official" architechtual constants. */
+/* For RFC6827 */
+/* Local and Remote TE Router ID */
+#define TE_LINK_SUBTLV_LRRID		10
+#define TE_LINK_SUBTLV_LRRID_SIZE	8
+struct te_link_subtlv_lrrid
+{
+  struct te_tlv_header header;  /* Value length is 8 octets. */
+  struct in_addr local;         /* Local TE Router Identifier */
+  struct in_addr remote;        /* Remote TE Router Identifier */
+};
+
+/* RFC4203: Link Local/Remote Identifiers */
+#define TE_LINK_SUBTLV_LLRI		11
+#define TE_LINK_SUBTLV_LLRI_SIZE	8
+struct te_link_subtlv_llri
+{
+  struct te_tlv_header header;  /* Value length is 8 octets. */
+  u_int32_t local;              /* Link Local Identifier */
+  u_int32_t remote;             /* Link Remote Identifier */
+};
+
+/* Inter-RA Export Upward sub-TLV (12) and Inter-RA Export Downward sub-TLV (13) (RFC6827bis) are not yet supported */
+/* SUBTLV 14-16 (RFC4203) are not yet supported */
+/* Bandwidth Constraints sub-TLV (17) (RFC4124) is not yet supported */
+/* SUBLV 18-20 are for OSPFv6 TE (RFC5329). see ospf6d */
+
+/* For RFC 5392 */
+/* Remote AS Number sub-TLV */
+#define TE_LINK_SUBTLV_RAS		21
+struct te_link_subtlv_ras
+{
+  struct te_tlv_header header;  /* Value length is 4 octets. */
+  u_int32_t value;              /* Remote AS number */
+};
+
+/* IPv4 Remote ASBR ID Sub-TLV */
+#define TE_LINK_SUBTLV_RIP		22
+struct te_link_subtlv_rip
+{
+  struct te_tlv_header header;  /* Value length is 4 octets. */
+  struct in_addr value;         /* Remote ASBR IP address */
+};
+
+/* SUBTLV 24 is IPv6 Remote ASBR ID (RFC5392). see ospf6d */
+
+/* SUBTLV 23 (RFC5330) and 25 (RFC6001) are not yet supported */
+
+/* draft-ietf-ospf-te-metric-extensions-05.txt */
+/* Link Sub-TLV: Average Link Delay */ /* Optional */
+#define TE_LINK_SUBTLV_AV_DELAY		26
+struct te_link_subtlv_av_delay
+{
+  struct te_tlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* delay in micro-seconds only 24 bits => 0 ... 16777215
+                                   with Anomalous Bit as Upper most bit */
+};
+
+/* Link Sub-TLV: Low/High Link Delay */
+#define TE_LINK_SUBTLV_MM_DELAY         27
+#define TE_LINK_SUBTLV_MM_DELAY_SIZE    8
+struct te_link_subtlv_mm_delay
+{
+  struct te_tlv_header header;  /* Value length is 8 bytes. */
+  u_int32_t            low;     /* low delay in micro-seconds only 24 bits => 0 ... 16777215
+                                   with Anomalous Bit (A) as Upper most bit */
+  u_int32_t            high;    /* high delay in micro-seconds only 24 bits => 0 ... 16777215 */
+};
+
+/* Link Sub-TLV: Link Delay Variation i.e. Jitter */
+#define TE_LINK_SUBTLV_DELAY_VAR	28
+struct te_link_subtlv_delay_var
+{
+  struct te_tlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* interval in micro-seconds only 24 bits => 0 ... 16777215 */
+};
+
+/* Link Sub-TLV: Routine Unidirectional Link Packet Loss */
+#define TE_LINK_SUBTLV_PKT_LOSS		29
+struct te_link_subtlv_pkt_loss
+{
+  struct te_tlv_header header;  /* Value length is 4 bytes. */
+  u_int32_t            value;   /* in percentage of total traffic only 24 bits (2^24 - 2)
+                                   with Anomalous Bit as Upper most bit */
+};
+
+/* Link Sub-TLV: Unidirectional Residual Bandwidth */ /* Optional */
+#define TE_LINK_SUBTLV_RES_BW		30
+struct te_link_subtlv_res_bw
+{
+  struct te_tlv_header header;  /* Value length is 4 bytes. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+};
+
+/* Link Sub-TLV: Unidirectional Available Bandwidth */ /* Optional */
+#define TE_LINK_SUBTLV_AVA_BW		31
+struct te_link_subtlv_ava_bw
+{
+  struct te_tlv_header header;  /* Value length is 4 octets. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+};
+
+/* Link Sub-TLV: Unidirectional Utilized Bandwidth */ /* Optional */
+#define TE_LINK_SUBTLV_USE_BW           32
+struct te_link_subtlv_use_bw
+{
+  struct te_tlv_header header;  /* Value length is 4 octets. */
+  float                value;   /* bandwidth in IEEE floating point format with units in bytes per second */
+};
+
+#define TE_LINK_SUBTLV_MAX			33      /* Last SUBTLV + 1 */
+
+/* Here are "non-official" architectural constants. */
 #define MPLS_TE_MINIMUM_BANDWIDTH	1.0	/* Reasonable? *//* XXX */
 
+/* Following declaration concerns the MPLS-TE and LINk-TE management */
+typedef enum _opcode_t
+{ REORIGINATE_THIS_LSA, REFRESH_THIS_LSA, FLUSH_THIS_LSA } opcode_t;
+
+typedef enum _status_t
+{ disabled, enabled } status_t;
+
+/* Mode for Inter-AS Opaque-LSA */
+enum inter_as_mode { Disable, AS, Area };
+
+struct te_link_subtlv
+{
+  struct te_tlv_header header;
+  union
+  {
+    u_int32_t link_type;
+    struct in_addr link_id;
+    struct in_addr lclif;
+    struct in_addr rmtif;
+    u_int32_t te_metric;
+    float max_bw;
+    float max_rsv_bw;
+    float unrsv[8];
+    u_int32_t rsc_clsclr;
+    u_int32_t llri[2];
+    u_int32_t ras;
+    struct in_addr rip;
+    struct in_addr lrrid[2];
+    u_int32_t av_delay;
+    u_int32_t mm_delay;
+    u_int32_t delay_var;
+    u_int32_t pkt_loss;
+    float res_bw;
+    float ava_bw;
+    float use_bw;
+  } value;
+};
+
+/* Following structure are internal use only. */
+struct ospf_mpls_te
+{
+  /* Status of MPLS-TE: enable or disbale */
+  status_t status;
+
+  /* RFC5392 */
+  enum inter_as_mode inter_as;
+  struct in_addr interas_areaid;
+
+  /* List elements are zebra-interfaces (ifp), not ospf-interfaces (oi). */
+  struct list *iflist;
+
+  /* Store Router-TLV in network byte order. */
+  struct te_tlv_router_addr router_addr;
+};
+
+struct mpls_te_link
+{
+  /*
+   * According to MPLS-TE (draft) specification, 24-bit Opaque-ID field
+   * is subdivided into 8-bit "unused" field and 16-bit "instance" field.
+   * In this implementation, each Link-TLV has its own instance.
+   */
+  u_int32_t instance;
+
+  /* Reference pointer to a Zebra-interface. */
+  struct interface *ifp;
+
+  /* Area info in which this MPLS-TE link belongs to. */
+  struct ospf_area *area;
+
+  /* Flags to manage this link parameters. */
+  u_int32_t flags;
+
+  /* Type of MPLS-TE link: RFC3630, RFC5392, RFC5392 emulated, RFC6827 */
+  u_int8_t type;
+
+  /* Store Link-TLV in network byte order. */
+  /* RFC3630 & RFC6827 / RFC 6827 */
+  struct te_tlv_link link_header;
+  struct te_link_subtlv_link_type link_type;
+  struct te_link_subtlv_link_id link_id;
+  struct te_link_subtlv_lclif_ipaddr lclif_ipaddr;
+  struct te_link_subtlv_rmtif_ipaddr rmtif_ipaddr;
+  struct te_link_subtlv_te_metric te_metric;
+  struct te_link_subtlv_max_bw max_bw;
+  struct te_link_subtlv_max_rsv_bw max_rsv_bw;
+  struct te_link_subtlv_unrsv_bw unrsv_bw;
+  struct te_link_subtlv_rsc_clsclr rsc_clsclr;
+  /* RFC4203 */
+  struct te_link_subtlv_llri llri;
+  /* RFC5392 */
+  struct te_link_subtlv_ras ras;
+  struct te_link_subtlv_rip rip;
+  /* RFC6827 */
+  struct te_link_subtlv_lrrid lrrid;
+  /* draft-ietf-ospf-te-metric-extension */
+  struct te_link_subtlv_av_delay av_delay;
+  struct te_link_subtlv_mm_delay mm_delay;
+  struct te_link_subtlv_delay_var delay_var;
+  struct te_link_subtlv_pkt_loss pkt_loss;
+  struct te_link_subtlv_res_bw res_bw;
+  struct te_link_subtlv_ava_bw ava_bw;
+  struct te_link_subtlv_use_bw use_bw;
+
+  struct in_addr adv_router;
+  struct in_addr id;
+};
+
 /* Prototypes. */
 extern int ospf_mpls_te_init (void);
 extern void ospf_mpls_te_term (void);
+extern struct ospf_mpls_te *get_ospf_mpls_te (void);
+extern void ospf_mpls_te_update_if (struct interface *);
+extern void ospf_mpls_te_lsa_schedule (struct mpls_te_link *, opcode_t);
+extern u_int32_t get_mpls_te_instance_value (void);
+extern void set_linkparams_llri (struct mpls_te_link *, u_int32_t, u_int32_t);
+extern void set_linkparams_lrrid (struct mpls_te_link *, struct in_addr, struct in_addr);
 
 #endif /* _ZEBRA_OSPF_MPLS_TE_H */
diff --git a/ospfd/ospf_vty.c b/ospfd/ospf_vty.c
index 8bfcaa8..73aacb3 100644
--- a/ospfd/ospf_vty.c
+++ b/ospfd/ospf_vty.c
@@ -63,7 +63,7 @@ static const char *ospf_network_type_str[] =
 
 
 /* Utility functions. */
-static int
+int
 ospf_str2area_id (const char *str, struct in_addr *area_id, int *format)
 {
   char *endptr = NULL;
diff --git a/ospfd/ospf_vty.h b/ospfd/ospf_vty.h
index da0ed1c..0602fec 100644
--- a/ospfd/ospf_vty.h
+++ b/ospfd/ospf_vty.h
@@ -53,5 +53,6 @@
 /* Prototypes. */
 extern void ospf_vty_init (void);
 extern void ospf_vty_show_init (void);
+extern int ospf_str2area_id (const char *, struct in_addr *, int *);
 
 #endif /* _QUAGGA_OSPF_VTY_H */
diff --git a/ospfd/ospf_zebra.c b/ospfd/ospf_zebra.c
index b6d3260..26cff41 100644
--- a/ospfd/ospf_zebra.c
+++ b/ospfd/ospf_zebra.c
@@ -48,6 +48,9 @@
 #ifdef HAVE_SNMP
 #include "ospfd/ospf_snmp.h"
 #endif /* HAVE_SNMP */
+#ifdef HAVE_OSPF_TE
+#include "ospfd/ospf_te.h"
+#endif /* HAVE_OSPF_TE */
 
 /* Zebra structure to hold current status. */
 struct zclient *zclient = NULL;
@@ -324,6 +327,26 @@ ospf_interface_address_delete (int command, struct zclient *zclient,
   return 0;
 }
 
+#ifdef HAVE_OSPF_TE
+static int
+ospf_interface_update (int command, struct zclient *zclient,
+                        zebra_size_t length)
+{
+  struct interface *ifp;
+
+  ifp = zebra_interface_state_read (zclient->ibuf);
+
+  if (ifp == NULL)
+    return 0;
+
+  /* Update TE TLV */
+  ospf_mpls_te_update_if (ifp);
+
+  return 0;
+}
+#endif /* HAVE_OSPF_TE*/
+
+
 void
 ospf_zebra_add (struct prefix_ipv4 *p, struct ospf_route *or)
 {
@@ -1305,6 +1328,10 @@ ospf_zebra_init ()
   zclient->interface_down = ospf_interface_state_down;
   zclient->interface_address_add = ospf_interface_address_add;
   zclient->interface_address_delete = ospf_interface_address_delete;
+#ifdef HAVE_OSPF_TE
+  zclient->interface_update = ospf_interface_update;
+#endif /* HAVE_OSPF_TE */
+
   zclient->ipv4_route_add = ospf_zebra_read_ipv4;
   zclient->ipv4_route_delete = ospf_zebra_read_ipv4;
 
diff --git a/ospfd/ospfd.c b/ospfd/ospfd.c
index dd57f64..73d8c8e 100644
--- a/ospfd/ospfd.c
+++ b/ospfd/ospfd.c
@@ -243,7 +243,7 @@ ospf_lookup ()
   if (listcount (om->ospf) == 0)
     return NULL;
 
-  return listgetdata (listhead (om->ospf));
+  return listgetdata ((struct listnode *)listhead (om->ospf));
 }
 
 static void
diff --git a/ospfd/ospfd.h b/ospfd/ospfd.h
index 4242aa0..4c29daa 100644
--- a/ospfd/ospfd.h
+++ b/ospfd/ospfd.h
@@ -59,13 +59,14 @@
 #define OSPF_AUTH_CMD_NOTSEEN              -2
 
 /* OSPF options. */
-#define OSPF_OPTION_T                    0x01  /* TOS. */
+#define OSPF_OPTION_MT                   0x01  /* M/T */
 #define OSPF_OPTION_E                    0x02
 #define OSPF_OPTION_MC                   0x04
 #define OSPF_OPTION_NP                   0x08
 #define OSPF_OPTION_EA                   0x10
 #define OSPF_OPTION_DC                   0x20
 #define OSPF_OPTION_O                    0x40
+#define OSPF_OPTION_DN                   0x80
 
 /* OSPF Database Description flags. */
 #define OSPF_DD_FLAG_MS                  0x01
diff --git a/zebra/interface.c b/zebra/interface.c
index 7e1d3dd..55caed3 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -190,7 +190,7 @@ if_subnet_delete (struct interface *ifp, struct connected *ifc)
       /* If deleted address is primary, mark subsequent one as such and distribute. */
       if (! CHECK_FLAG (ifc->flags, ZEBRA_IFA_SECONDARY))
 	{
-	  ifc = listgetdata (listhead (addr_list));
+	  ifc = listgetdata ((struct listnode *)listhead (addr_list));
 	  zebra_interface_address_delete_update (ifp, ifc);
 	  UNSET_FLAG (ifc->flags, ZEBRA_IFA_SECONDARY);
 	  /* XXX: Linux kernel removes all the secondary addresses when the primary
@@ -787,7 +787,7 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
     {
       if (! rn->info)
 	continue;
-      
+
       for (ALL_LIST_ELEMENTS_RO ((struct list *)rn->info, node, connected))
         connected_dump_vty (vty, connected);
     }
@@ -799,6 +799,49 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
 	connected_dump_vty (vty, connected);
     }
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  if (IS_LINK_TE(ifp))
+    {
+      int i;
+      vty_out(vty, "  Traffic Engineering Link Parameters:%s", VTY_NEWLINE);
+      if (ifp->link_te.te_metric != 0)
+        vty_out(vty, "    TE metric %u%s",ifp->link_te.te_metric, VTY_NEWLINE);
+      if (ifp->link_te.max_bw > 0.0)
+        vty_out(vty, "    Maximum Bandwidth %g (Byte/s)%s", ifp->link_te.max_bw, VTY_NEWLINE);
+      if (ifp->link_te.max_rsv_bw > 0.0)
+        vty_out(vty, "    Maximum Reservable Bandwidth %g (Byte/s)%s", ifp->link_te.max_rsv_bw, VTY_NEWLINE);
+
+      vty_out(vty, "    Unreserved Bandwidth per Class Type in Byte/s:%s", VTY_NEWLINE);
+      for (i = 0; i < MAX_CLASS_TYPE; i+=2)
+        vty_out(vty, "      [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)%s",
+                i, ifp->link_te.unrsv_bw[i], i+1, ifp->link_te.unrsv_bw[i+1], VTY_NEWLINE);
+
+      if (ifp->link_te.admin_grp != 0)
+        vty_out(vty, "    Administrative Group:%u%s", ifp->link_te.admin_grp, VTY_NEWLINE);
+      if (ifp->link_te.av_delay != 0)
+        {
+          vty_out(vty, "    Link Delay Average: %u (micro-sec.)", ifp->link_te.av_delay);
+          if (ifp->link_te.min_delay != 0)
+            vty_out(vty, " Min:  %u (micro-sec.)", ifp->link_te.min_delay);
+          if (ifp->link_te.max_delay != 0)
+            vty_out(vty, " Max:  %u (micro-sec.)", ifp->link_te.max_delay);
+          vty_out(vty, "%s", VTY_NEWLINE);
+        }
+      if (ifp->link_te.delay_var != 0)
+        vty_out(vty, "    Link Delay Variation %u (micro-sec.)%s", ifp->link_te.delay_var, VTY_NEWLINE);
+      if (ifp->link_te.pkt_loss >= 0.0)
+        vty_out(vty, "    Link Packet Loss %g (in %%)%s", ifp->link_te.pkt_loss, VTY_NEWLINE);
+      if (ifp->link_te.ava_bw > 0.0)
+        vty_out(vty, "    Available Bandwidth %g (Byte/s)%s", ifp->link_te.ava_bw, VTY_NEWLINE);
+      if (ifp->link_te.res_bw > 0.0)
+        vty_out(vty, "    Residual Bandwidth %g (Byte/s)%s", ifp->link_te.res_bw, VTY_NEWLINE);
+      if (ifp->link_te.use_bw > 0.0)
+        vty_out(vty, "    Utilized Bandwidth %g (Byte/s)%s", ifp->link_te.use_bw, VTY_NEWLINE);
+      if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+        vty_out(vty, "    Neighbor ASBR IP: %s AS: %u %s", inet_ntoa(ifp->link_te.rmt_ip), ifp->link_te.rmt_as, VTY_NEWLINE);
+    }
+#endif /* Traffic Engineering */
+
 #ifdef RTADV
   nd_dump_vty (vty, ifp);
 #endif /* RTADV */
@@ -1207,6 +1250,480 @@ ALIAS (no_bandwidth_if,
        "Set bandwidth informational parameter\n"
        "Bandwidth in kilobits\n")
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Specific Traffic Engineering parameters commands */
+DEFUN (mpls_te_enable,
+       mpls_te_enable_cmd,
+       "mpls-te on",
+       MPLS_TE_STR
+       "Activate MPLS-TE link parameters on this interface\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+  int i;
+
+  /* This command could be issue at startup, when activate MPLS TE */
+  /* on a new interface or after a ON / OFF / ON toggle */
+  /* In all case, TE parameters are reset to their default factory */
+  if (IS_ZEBRA_DEBUG_EVENT)
+    zlog_debug ("MPLS-TE: enable MPLS TE on interface %s", ifp->name);
+
+  ifp->mpls_te = MPLS_TE_ON;
+
+  /* Initial setup of TE parameters */
+  /* Compute initial bandwidth */
+  bw = (float)((ifp->bandwidth ? ifp->bandwidth : DEFAULT_BANDWIDTH) * TE_KILO_BIT / TE_BYTE);
+  ifp->link_te.max_bw = bw;
+  ifp->link_te.max_rsv_bw = bw;
+  for (i = 0; i < MAX_CLASS_TYPE; i++)
+    ifp->link_te.unrsv_bw[i] = bw;
+  ifp->link_te.ava_bw = bw;
+
+  /* Set TE metric == standard metric */
+  ifp->link_te.te_metric = ifp->metric;
+
+  /* All others TE parameters are set to 0 */
+  ifp->link_te.admin_grp = 0;
+  ifp->link_te.rmt_as = 0;
+  ifp->link_te.rmt_ip.s_addr = 0;
+  ifp->link_te.av_delay = 0;
+  ifp->link_te.min_delay = 0;
+  ifp->link_te.max_delay = 0;
+  ifp->link_te.delay_var = 0;
+  ifp->link_te.pkt_loss = 0.0;
+  ifp->link_te.res_bw = 0.0;
+  ifp->link_te.use_bw = 0.0;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_mpls_te_enable,
+       no_mpls_te_enable_cmd,
+       "no mpls-te",
+       NO_STR
+       "Disable MPLS-TE link parameters on this interface\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+
+  zlog_debug ("MPLS-TE: disable MPLS TE on interface %s", ifp->name);
+
+  ifp->mpls_te = MPLS_TE_OFF;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+/* STANDARD TE metrics */
+DEFUN (mpls_te_link_metric,
+       mpls_te_link_metric_cmd,
+       "mpls-te link metric <0-4294967295>",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Link metric for MPLS-TE purpose\n"
+       "Metric value in decimal\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t value;
+
+  value = strtoul (argv[0], NULL, 10);
+
+  /* Update TE metric if needed */
+  if (ifp->link_te.te_metric == 0 ||  ifp->link_te.te_metric != value)
+    {
+      ifp->link_te.te_metric = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_maxbw,
+       mpls_te_link_maxbw_cmd,
+       "mpls-te link max-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Maximum bandwidth that can be used\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_maxbw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Maximum Bandwidth if needed */
+  if (ifp->link_te.max_bw == 0.0 || ifp->link_te.max_bw != bw)
+    {
+      ifp->link_te.max_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_max_rsv_bw,
+       mpls_te_link_max_rsv_bw_cmd,
+       "mpls-te link max-rsv-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Maximum bandwidth that may be reserved\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_max_rsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Maximum Reservable Bandwidth if needed */
+  if (ifp->link_te.max_rsv_bw == 0.0 || ifp->link_te.max_rsv_bw != bw)
+    {
+      ifp->link_te.max_rsv_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_unrsv_bw,
+       mpls_te_link_unrsv_bw_cmd,
+       "mpls-te link unrsv-bw <0-7> BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unreserved bandwidth at each priority level\n"
+       "Priority\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  int priority;
+  float bw;
+
+  /* We don't have to consider about range check here. */
+  if (sscanf (argv[0], "%d", &priority) != 1)
+    {
+      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (sscanf (argv[1], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Unreserved Bandwidth if needed */
+  if (ifp->link_te.unrsv_bw[priority] == 0.0 || ifp->link_te.unrsv_bw[priority] != bw)
+    {
+      ifp->link_te.unrsv_bw[priority] = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_admin_grp,
+       mpls_te_link_admin_grp_cmd,
+       "mpls-te link admin-grp BITPATTERN",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Administrative group membership\n"
+       "32-bit Hexadecimal value (e.g. 0xa1)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  unsigned long value;
+
+  if (sscanf (argv[0], "0x%lx", &value) != 1)
+    {
+      vty_out (vty, "mpls_te_link_admin_grp: fscanf: %s%s",
+               safe_strerror (errno), VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Administrative Group if needed */
+  if (ifp->link_te.admin_grp == 0 ||  ifp->link_te.admin_grp != value)
+    {
+      ifp->link_te.admin_grp = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+/* INTER-AS */
+DEFUN (mpls_te_link_inter_as,
+       mpls_te_link_inter_as_cmd,
+       "mpls-te neighbor A.B.C.D as <0-65535>",
+       MPLS_TE_STR
+       "Configure remote ASBR information (Neighbor IP address and AS number)\n"
+       "Remote IP address in dot decimal A.B.C.D\n"
+       "Remote AS number\n"
+       "AS number in the range <0-65535>\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+  struct in_addr addr;
+  u_int32_t as;
+
+  if (!inet_aton (argv[0], &addr))
+    {
+      vty_out (vty, "Please specify Router-Addr by A.B.C.D%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  as = strtoul (argv[1], NULL, 10);
+
+  /* Update Remote IP and Remote AS fields if needed */
+  if ((ifp->link_te.rmt_as == 0 || ifp->link_te.rmt_as != as) ||
+      (ifp->link_te.rmt_ip.s_addr == 0 || ifp->link_te.rmt_ip.s_addr != addr.s_addr))
+    {
+
+      ifp->link_te.rmt_as = as;
+      ifp->link_te.rmt_ip.s_addr = addr.s_addr;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_mpls_te_link_inter_as,
+       no_mpls_te_link_inter_as_cmd,
+       "no mpls-te neighbor",
+       NO_STR
+       MPLS_TE_STR
+       "Remove Neighbor IP address and AS number for Inter-AS TE\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+
+  /* Reset Remote IP and AS neighbor */
+  ifp->link_te.rmt_as = 0;
+  ifp->link_te.rmt_ip.s_addr = 0;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+/* draft-ietf-ospf-metric-extensions-05.txt & draft-ietf-isis-metric-extensions-03.txt */
+DEFUN (mpls_te_link_delay,
+       mpls_te_link_delay_cmd,
+       "mpls-te link delay <0-16777215> {min <0-16777215>|max <0-16777215>}",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Average Link Delay (optionally Minimum and Maximum delays)\n"
+       "Average delay in micro-second as decimal (0...16777215)\n"
+       "Minimum delay\n"
+       "delay in micro-second as decimal (0...16777215)\n"
+       "Maximum delay\n"
+       "delay in micro-second as decimal (0...16777215)\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t delay = 0, low = 0, high = 0;
+
+  delay = strtoul (argv[0], NULL, 10);
+  if (argv[1] != NULL)
+      low = strtoul(argv[1], NULL, 10);
+  if (argv[2] != NULL)
+      high = strtoul(argv[2], NULL, 10);
+
+  /* Update Delays if needed */
+  if ((ifp->link_te.av_delay == 0 ||  ifp->link_te.av_delay != delay) ||
+      (ifp->link_te.min_delay == 0 || ifp->link_te.min_delay != low) ||
+      (ifp->link_te.max_delay == 0 || ifp->link_te.max_delay != high))
+    {
+      ifp->link_te.av_delay = delay;
+      ifp->link_te.min_delay = low;
+      ifp->link_te.max_delay = high;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_delay_var,
+       mpls_te_link_delay_var_cmd,
+       "mpls-te link delay-variation <0-16777215>",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Link Delay Variation\n"
+       "delay variation in micro-second as decimal (0...16777215)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t value;
+
+  value = strtoul (argv[0], NULL, 10);
+
+  /* Update Delay Variation if needed */
+  if (ifp->link_te.delay_var == 0 ||  ifp->link_te.delay_var != value)
+    {
+      ifp->link_te.delay_var = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_pkt_loss,
+       mpls_te_link_pkt_loss_cmd,
+       "mpls-te link packet-loss PERCENTAGE",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Link Packet Loss\n"
+       "percentage of total traffic by 0.000003% step and less than 50.331642%\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float fval;
+
+  if (sscanf (argv[0], "%g", &fval) != 1)
+    {
+      vty_out (vty, "mpls_te_link_pkt_loss: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (fval > MAX_PKT_LOSS)
+    fval = MAX_PKT_LOSS;
+
+  /* Update Packet Loss if needed */
+  if (ifp->link_te.pkt_loss >= 0.0 ||  ifp->link_te.pkt_loss != fval)
+    {
+      ifp->link_te.pkt_loss = fval;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_res_bw,
+       mpls_te_link_res_bw_cmd,
+       "mpls-te link res-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Residual Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_res_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Residual Bandwidth if needed */
+  if (ifp->link_te.res_bw == 0.0 || ifp->link_te.res_bw != bw)
+    {
+      ifp->link_te.res_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_ava_bw,
+       mpls_te_link_ava_bw_cmd,
+       "mpls-te link ava-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Available Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_ava_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Residual Bandwidth if needed */
+  if (ifp->link_te.ava_bw == 0.0 || ifp->link_te.ava_bw != bw)
+    {
+      ifp->link_te.ava_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_use_bw,
+       mpls_te_link_use_bw_cmd,
+       "mpls-te link use-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Available Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_use_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Utilized Bandwidth if needed */
+  if (ifp->link_te.use_bw == 0.0 || ifp->link_te.use_bw != bw)
+    {
+      ifp->link_te.use_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+#endif /* Traffic Engineering */
+
 static int
 ip_address_install (struct vty *vty, struct interface *ifp,
 		    const char *addr_str, const char *peer_str,
@@ -1549,6 +2066,7 @@ if_config_write (struct vty *vty)
 {
   struct listnode *node;
   struct interface *ifp;
+  int i;
 
   for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
     {
@@ -1577,6 +2095,50 @@ if_config_write (struct vty *vty)
       if (ifp->bandwidth != 0)
 	vty_out(vty, " bandwidth %u%s", ifp->bandwidth, VTY_NEWLINE); 
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+      if (IS_LINK_TE(ifp))
+        {
+          vty_out(vty, " mpls-te on%s", VTY_NEWLINE);
+          if (ifp->link_te.te_metric != 0)
+            vty_out(vty, " mpls-te link metric %u%s",ifp->link_te.te_metric, VTY_NEWLINE);
+          if (ifp->link_te.max_bw > 0.0)
+            vty_out(vty, " mpls-te link max-bw %g (Byte/s)%s", ifp->link_te.max_bw, VTY_NEWLINE);
+          if (ifp->link_te.max_rsv_bw > 0.0)
+            vty_out(vty, " mpls-te link max-rsv-bw %g (Byte/s)%s", ifp->link_te.max_rsv_bw, VTY_NEWLINE);
+          for (i = 0; i < 8; i++)
+            {
+              if (ifp->link_te.unrsv_bw[i] > 0.0)
+                vty_out(vty, " mpls-te link unrsv-bw %d %g%s",
+                    i, ifp->link_te.unrsv_bw[i], VTY_NEWLINE);
+            }
+          if (ifp->link_te.admin_grp != 0)
+            vty_out(vty, " mpls-te link admin-grp %u%s", ifp->link_te.admin_grp, VTY_NEWLINE);
+          if (ifp->link_te.av_delay != 0)
+            {
+              vty_out(vty, " mpls-te link delay %u", ifp->link_te.av_delay);
+              if (ifp->link_te.min_delay != 0)
+                vty_out(vty, " min %u", ifp->link_te.min_delay);
+              if (ifp->link_te.max_delay != 0)
+                vty_out(vty, " max %u", ifp->link_te.max_delay);
+              vty_out(vty, "%s", VTY_NEWLINE);
+            }
+          if (ifp->link_te.delay_var != 0)
+            vty_out(vty, " mpls-te link delay-variation %u%s", ifp->link_te.delay_var, VTY_NEWLINE);
+          if (ifp->link_te.pkt_loss >= 0.0)
+            vty_out(vty, " mpls-te link packet-loss %g%s", ifp->link_te.pkt_loss, VTY_NEWLINE);
+          if (ifp->link_te.ava_bw > 0.0)
+            vty_out(vty, " mpls-te link ava-bw %g%s", ifp->link_te.ava_bw, VTY_NEWLINE);
+          if (ifp->link_te.res_bw > 0.0)
+            vty_out(vty, " mpls-te link res-bw %g%s", ifp->link_te.res_bw, VTY_NEWLINE);
+          if (ifp->link_te.use_bw > 0.0)
+            vty_out(vty, " mpls-te link use-bw %g%s", ifp->link_te.use_bw, VTY_NEWLINE);
+          if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+            vty_out(vty, " mpls-te neighbor %s as %u%s", inet_ntoa(ifp->link_te.rmt_ip),
+                ifp->link_te.rmt_as, VTY_NEWLINE);
+    }
+
+#endif /* Traffic Engineering */
+
       if (CHECK_FLAG(ifp->status, ZEBRA_INTERFACE_LINKDETECTION))
 	vty_out(vty, " link-detect%s", VTY_NEWLINE);
 
@@ -1658,4 +2220,21 @@ zebra_if_init (void)
   install_element (INTERFACE_NODE, &ip_address_label_cmd);
   install_element (INTERFACE_NODE, &no_ip_address_label_cmd);
 #endif /* HAVE_NETLINK */
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  install_element(INTERFACE_NODE, &mpls_te_enable_cmd);
+  install_element(INTERFACE_NODE, &no_mpls_te_enable_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_metric_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_maxbw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_max_rsv_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_unrsv_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_admin_grp_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_inter_as_cmd);
+  install_element(INTERFACE_NODE, &no_mpls_te_link_inter_as_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_delay_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_delay_var_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_pkt_loss_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_ava_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_res_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_use_bw_cmd);
+#endif /* Traffic Engineering */
 }
diff --git a/zebra/redistribute.c b/zebra/redistribute.c
index 078c2ad..41ca2a6 100644
--- a/zebra/redistribute.c
+++ b/zebra/redistribute.c
@@ -280,7 +280,7 @@ zebra_redistribute_default_delete (int command, struct zserv *client,
 				   int length)
 {
   client->redist_default = 0;;
-}     
+}
 
 /* Interface up information. */
 void
@@ -393,3 +393,20 @@ zebra_interface_address_delete_update (struct interface *ifp,
     if (client->ifinfo && CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
       zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_DELETE, client, ifp, ifc);
 }
+
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Interface parameters update */
+void
+zebra_interface_parameters_update (struct interface *ifp)
+{
+  struct listnode *node, *nnode;
+  struct zserv *client;
+
+  if (IS_ZEBRA_DEBUG_EVENT)
+    zlog_debug ("MESSAGE: ZEBRA_INTERFACE_UPDATE %s", ifp->name);
+
+  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
+    zsend_interface_update (ZEBRA_INTERFACE_UPDATE, client, ifp);
+
+}
+#endif /* Traffic Engineering */
diff --git a/zebra/redistribute.h b/zebra/redistribute.h
index 9ed99bc..c4669cb 100644
--- a/zebra/redistribute.h
+++ b/zebra/redistribute.h
@@ -46,6 +46,10 @@ extern void zebra_interface_address_add_update (struct interface *,
 extern void zebra_interface_address_delete_update (struct interface *,
 						   struct connected *c);
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+extern void zebra_interface_parameters_update (struct interface *);
+#endif /* Traffic Engineering */
+
 extern int zebra_check_addr (struct prefix *);
 
 #endif /* _ZEBRA_REDISTRIBUTE_H */
diff --git a/zebra/redistribute_null.c b/zebra/redistribute_null.c
index 54198c8..11904db 100644
--- a/zebra/redistribute_null.c
+++ b/zebra/redistribute_null.c
@@ -53,3 +53,9 @@ void zebra_interface_address_delete_update (struct interface *a,
                                                 struct connected *b)
 { return; }
 #endif
+
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Interface parameters update */
+void zebra_interface_parameters_update (struct interface *ifp)
+{ return; };
+#endif /* Traffic Engineering */
diff --git a/zebra/zserv.c b/zebra/zserv.c
index ca17c2c..fbfd05e 100644
--- a/zebra/zserv.c
+++ b/zebra/zserv.c
@@ -152,6 +152,7 @@ zserv_encode_interface (struct stream *s, struct interface *ifp)
   stream_putl (s, ifp->mtu);
   stream_putl (s, ifp->mtu6);
   stream_putl (s, ifp->bandwidth);
+
 #ifdef HAVE_STRUCT_SOCKADDR_DL
   stream_put (s, &ifp->sdl, sizeof (ifp->sdl_storage));
 #else
@@ -160,6 +161,14 @@ zserv_encode_interface (struct stream *s, struct interface *ifp)
     stream_put (s, ifp->hw_addr, ifp->hw_addr_len);
 #endif /* HAVE_STRUCT_SOCKADDR_DL */
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  /* Put Traffic Engineering status */
+  stream_putc (s, ifp->mpls_te);
+  /* Then, TE parameters if MPLS-TE is activate on this interface */
+  if (IS_LINK_TE(ifp))
+    stream_write (s, &ifp->link_te, INTERFACE_LINK_TE_SIZE);
+#endif /* Traffic Engineering */
+
   /* Write packet size. */
   stream_putw_at (s, 0, stream_get_endp (s));
 }
