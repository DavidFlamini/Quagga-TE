diff --git a/lib/command.h b/lib/command.h
index e47c425..52d770a 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -482,6 +482,14 @@ struct cmd_token
 "(neighbor|interface|area|lsa|zebra|config|dbex|spf|route|lsdb|redistribute|hook|asbr|prefix|abr)"
 #define ISIS_STR "IS-IS information\n"
 #define AREA_TAG_STR "[area tag]\n"
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+#define MPLS_TE_STR "MPLS-TE specific commands\n"
+#define MPLS_TE_LINK_STR "Configure MPLS-TE link parameters\n"
+#endif /* HAVE_OSPF_TE or HAVE_ISIS_TE */
+#ifdef HAVE_OSPF_RI
+#define OSPF_RI_STR "OSPF Router Information specific commands\n"
+#define PCE_STR "PCE Router Information specific commands\n"
+#endif /* HAVE_OSPF_RI */
 
 #define CONF_BACKUP_EXT ".sav"
 
diff --git a/lib/if.h b/lib/if.h
index 8081be8..5c62c05 100644
--- a/lib/if.h
+++ b/lib/if.h
@@ -68,6 +68,42 @@ struct if_stats
 };
 #endif /* HAVE_PROC_NET_DEV */
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+
+/* Here are "non-official" architectural constants. */
+#define TE_EXT_MASK             0x0FFFFFFF
+#define TE_EXT_ANORMAL          0x80000000
+#define LOSS_PRECISION          0.000003
+#define TE_KILO_BIT             1000
+#define TE_BYTE                 8
+#define DEFAULT_BANDWIDTH       10000
+#define MAX_CLASS_TYPE          8
+#define MAX_PKT_LOSS            50.331642
+
+/* Traffic Engineering Link Parameters */
+struct if_link_te {
+  u_int32_t te_metric;   /* Traffic Engineering metric */
+  float max_bw;          /* Maximum Bandwidth */
+  float max_rsv_bw;      /* Maximum Reservable Bandwidth */
+  float unrsv_bw[MAX_CLASS_TYPE];     /* Unreserved Bandwidth per Class Type (8) */
+  u_int32_t admin_grp;   /* Administrative group */
+  u_int32_t rmt_as;      /* Remote AS number */
+  struct in_addr rmt_ip; /* Remote IP address */
+  u_int32_t av_delay;    /* Link Average Delay */
+  u_int32_t min_delay;   /* Link Min Delay */
+  u_int32_t max_delay;   /* Link Max Delay */
+  u_int32_t delay_var;   /* Link Delay Variation */
+  float pkt_loss;        /* Link Packet Loss */
+  float res_bw;          /* Residual Bandwidth */
+  float ava_bw;          /* Available Bandwidth */
+  float use_bw;          /* Utilized Bandwidth */
+};
+
+#define INTERFACE_LINK_TE_SIZE   sizeof(struct if_link_te)
+#define IS_LINK_TE(ifp)  (ifp->mpls_te == MPLS_TE_ON)
+
+#endif /* Traffic Engineering */
+
 /* Interface structure */
 struct interface 
 {
@@ -119,6 +155,15 @@ struct interface
   /* interface bandwidth, kbits */
   unsigned int bandwidth;
   
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  /* Traffic Engineering Link status */
+  u_char mpls_te;        /* MPLS TE status */
+#define MPLS_TE_OFF  0
+#define MPLS_TE_ON   1
+  /* Traffic Engineering Link parameters */
+  struct if_link_te link_te;
+#endif /* Traffic Engineering */
+
   /* description of the interface. */
   char *desc;			
 
@@ -139,6 +184,7 @@ struct interface
 #ifdef HAVE_NET_RT_IFLIST
   struct if_data stats;
 #endif /* HAVE_NET_RT_IFLIST */
+
 };
 
 /* Connected address structure. */
diff --git a/lib/memtypes.c b/lib/memtypes.c
index 47a3438..25e70af 100644
--- a/lib/memtypes.c
+++ b/lib/memtypes.c
@@ -211,6 +211,8 @@ struct memory_list memory_list_ospf[] =
   { MTYPE_OSPF_IF_INFO,       "OSPF if info"			},
   { MTYPE_OSPF_IF_PARAMS,     "OSPF if params"			},
   { MTYPE_OSPF_MESSAGE,		"OSPF message"			},
+  { MTYPE_OSPF_MPLS_TE,       "OSPF MPLS parameters"            },
+  { MTYPE_OSPF_PCE_PARAMS,    "OSPF PCE parameters"             },
   { -1, NULL },
 };
 
@@ -252,6 +254,7 @@ struct memory_list memory_list_isis[] =
   { MTYPE_ISIS_NEXTHOP6,      "ISIS nexthop6"			},
   { MTYPE_ISIS_DICT,          "ISIS dictionary"			},
   { MTYPE_ISIS_DICT_NODE,     "ISIS dictionary node"		},
+  { MTYPE_ISIS_MPLS_TE,       "ISIS MPLS_TE parameters"         },
   { -1, NULL },
 };
 
diff --git a/lib/zclient.c b/lib/zclient.c
index 3b5477e..2277b2e 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -740,6 +740,15 @@ zebra_interface_if_set_value (struct stream *s, struct interface *ifp)
   if (ifp->hw_addr_len)
     stream_get (ifp->hw_addr, s, ifp->hw_addr_len);
 #endif /* HAVE_STRUCT_SOCKADDR_DL */
+
+#if defined(HAVE_OSPF_TE) || defined (HAVE_ISIS_TE)
+  /* Read Traffic Engineering status */
+  ifp->mpls_te = stream_getc (s);
+  /* Then, Traffic Engineering parameters if any */
+  if (IS_LINK_TE(ifp))
+    stream_get (&ifp->link_te, s, INTERFACE_LINK_TE_SIZE);
+#endif /* Traffic Engineering */
+
 }
 
 static int
@@ -951,6 +960,12 @@ zclient_read (struct thread *thread)
       if (zclient->interface_down)
 	(*zclient->interface_down) (command, zclient, length);
       break;
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+    case ZEBRA_INTERFACE_UPDATE:
+      if (zclient->interface_update)
+        (*zclient->interface_update) (command, zclient, length);
+      break;
+#endif /* Traffic Engineering */
     case ZEBRA_IPV4_ROUTE_ADD:
       if (zclient->ipv4_route_add)
 	(*zclient->ipv4_route_add) (command, zclient, length);
diff --git a/lib/zclient.h b/lib/zclient.h
index a660bbf..f49205b 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -78,6 +78,9 @@ struct zclient
   int (*interface_down) (int, struct zclient *, uint16_t);
   int (*interface_address_add) (int, struct zclient *, uint16_t);
   int (*interface_address_delete) (int, struct zclient *, uint16_t);
+#if defined(HAVE_OSPF_TE) || defined (HAVE_ISIS_TE)
+  int (*interface_update) (int, struct zclient *, uint16_t);
+#endif /* Traffic Engineering */
   int (*ipv4_route_add) (int, struct zclient *, uint16_t);
   int (*ipv4_route_delete) (int, struct zclient *, uint16_t);
   int (*ipv6_route_add) (int, struct zclient *, uint16_t);
diff --git a/lib/zebra.h b/lib/zebra.h
index 3715b34..95cfec9 100644
--- a/lib/zebra.h
+++ b/lib/zebra.h
@@ -424,7 +424,8 @@ struct in_pktinfo
 #define ZEBRA_ROUTER_ID_DELETE            21
 #define ZEBRA_ROUTER_ID_UPDATE            22
 #define ZEBRA_HELLO                       23
-#define ZEBRA_MESSAGE_MAX                 24
+#define ZEBRA_INTERFACE_UPDATE            24
+#define ZEBRA_MESSAGE_MAX                 25
 
 /* Marker value used in new Zserv, in the byte location corresponding
  * the command value in the old zserv header. To allow old and new
diff --git a/zebra/interface.c b/zebra/interface.c
index 7e1d3dd..55caed3 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -190,7 +190,7 @@ if_subnet_delete (struct interface *ifp, struct connected *ifc)
       /* If deleted address is primary, mark subsequent one as such and distribute. */
       if (! CHECK_FLAG (ifc->flags, ZEBRA_IFA_SECONDARY))
 	{
-	  ifc = listgetdata (listhead (addr_list));
+	  ifc = listgetdata ((struct listnode *)listhead (addr_list));
 	  zebra_interface_address_delete_update (ifp, ifc);
 	  UNSET_FLAG (ifc->flags, ZEBRA_IFA_SECONDARY);
 	  /* XXX: Linux kernel removes all the secondary addresses when the primary
@@ -787,7 +787,7 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
     {
       if (! rn->info)
 	continue;
-      
+
       for (ALL_LIST_ELEMENTS_RO ((struct list *)rn->info, node, connected))
         connected_dump_vty (vty, connected);
     }
@@ -799,6 +799,49 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
 	connected_dump_vty (vty, connected);
     }
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  if (IS_LINK_TE(ifp))
+    {
+      int i;
+      vty_out(vty, "  Traffic Engineering Link Parameters:%s", VTY_NEWLINE);
+      if (ifp->link_te.te_metric != 0)
+        vty_out(vty, "    TE metric %u%s",ifp->link_te.te_metric, VTY_NEWLINE);
+      if (ifp->link_te.max_bw > 0.0)
+        vty_out(vty, "    Maximum Bandwidth %g (Byte/s)%s", ifp->link_te.max_bw, VTY_NEWLINE);
+      if (ifp->link_te.max_rsv_bw > 0.0)
+        vty_out(vty, "    Maximum Reservable Bandwidth %g (Byte/s)%s", ifp->link_te.max_rsv_bw, VTY_NEWLINE);
+
+      vty_out(vty, "    Unreserved Bandwidth per Class Type in Byte/s:%s", VTY_NEWLINE);
+      for (i = 0; i < MAX_CLASS_TYPE; i+=2)
+        vty_out(vty, "      [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)%s",
+                i, ifp->link_te.unrsv_bw[i], i+1, ifp->link_te.unrsv_bw[i+1], VTY_NEWLINE);
+
+      if (ifp->link_te.admin_grp != 0)
+        vty_out(vty, "    Administrative Group:%u%s", ifp->link_te.admin_grp, VTY_NEWLINE);
+      if (ifp->link_te.av_delay != 0)
+        {
+          vty_out(vty, "    Link Delay Average: %u (micro-sec.)", ifp->link_te.av_delay);
+          if (ifp->link_te.min_delay != 0)
+            vty_out(vty, " Min:  %u (micro-sec.)", ifp->link_te.min_delay);
+          if (ifp->link_te.max_delay != 0)
+            vty_out(vty, " Max:  %u (micro-sec.)", ifp->link_te.max_delay);
+          vty_out(vty, "%s", VTY_NEWLINE);
+        }
+      if (ifp->link_te.delay_var != 0)
+        vty_out(vty, "    Link Delay Variation %u (micro-sec.)%s", ifp->link_te.delay_var, VTY_NEWLINE);
+      if (ifp->link_te.pkt_loss >= 0.0)
+        vty_out(vty, "    Link Packet Loss %g (in %%)%s", ifp->link_te.pkt_loss, VTY_NEWLINE);
+      if (ifp->link_te.ava_bw > 0.0)
+        vty_out(vty, "    Available Bandwidth %g (Byte/s)%s", ifp->link_te.ava_bw, VTY_NEWLINE);
+      if (ifp->link_te.res_bw > 0.0)
+        vty_out(vty, "    Residual Bandwidth %g (Byte/s)%s", ifp->link_te.res_bw, VTY_NEWLINE);
+      if (ifp->link_te.use_bw > 0.0)
+        vty_out(vty, "    Utilized Bandwidth %g (Byte/s)%s", ifp->link_te.use_bw, VTY_NEWLINE);
+      if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+        vty_out(vty, "    Neighbor ASBR IP: %s AS: %u %s", inet_ntoa(ifp->link_te.rmt_ip), ifp->link_te.rmt_as, VTY_NEWLINE);
+    }
+#endif /* Traffic Engineering */
+
 #ifdef RTADV
   nd_dump_vty (vty, ifp);
 #endif /* RTADV */
@@ -1207,6 +1250,480 @@ ALIAS (no_bandwidth_if,
        "Set bandwidth informational parameter\n"
        "Bandwidth in kilobits\n")
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Specific Traffic Engineering parameters commands */
+DEFUN (mpls_te_enable,
+       mpls_te_enable_cmd,
+       "mpls-te on",
+       MPLS_TE_STR
+       "Activate MPLS-TE link parameters on this interface\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+  int i;
+
+  /* This command could be issue at startup, when activate MPLS TE */
+  /* on a new interface or after a ON / OFF / ON toggle */
+  /* In all case, TE parameters are reset to their default factory */
+  if (IS_ZEBRA_DEBUG_EVENT)
+    zlog_debug ("MPLS-TE: enable MPLS TE on interface %s", ifp->name);
+
+  ifp->mpls_te = MPLS_TE_ON;
+
+  /* Initial setup of TE parameters */
+  /* Compute initial bandwidth */
+  bw = (float)((ifp->bandwidth ? ifp->bandwidth : DEFAULT_BANDWIDTH) * TE_KILO_BIT / TE_BYTE);
+  ifp->link_te.max_bw = bw;
+  ifp->link_te.max_rsv_bw = bw;
+  for (i = 0; i < MAX_CLASS_TYPE; i++)
+    ifp->link_te.unrsv_bw[i] = bw;
+  ifp->link_te.ava_bw = bw;
+
+  /* Set TE metric == standard metric */
+  ifp->link_te.te_metric = ifp->metric;
+
+  /* All others TE parameters are set to 0 */
+  ifp->link_te.admin_grp = 0;
+  ifp->link_te.rmt_as = 0;
+  ifp->link_te.rmt_ip.s_addr = 0;
+  ifp->link_te.av_delay = 0;
+  ifp->link_te.min_delay = 0;
+  ifp->link_te.max_delay = 0;
+  ifp->link_te.delay_var = 0;
+  ifp->link_te.pkt_loss = 0.0;
+  ifp->link_te.res_bw = 0.0;
+  ifp->link_te.use_bw = 0.0;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_mpls_te_enable,
+       no_mpls_te_enable_cmd,
+       "no mpls-te",
+       NO_STR
+       "Disable MPLS-TE link parameters on this interface\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+
+  zlog_debug ("MPLS-TE: disable MPLS TE on interface %s", ifp->name);
+
+  ifp->mpls_te = MPLS_TE_OFF;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+/* STANDARD TE metrics */
+DEFUN (mpls_te_link_metric,
+       mpls_te_link_metric_cmd,
+       "mpls-te link metric <0-4294967295>",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Link metric for MPLS-TE purpose\n"
+       "Metric value in decimal\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t value;
+
+  value = strtoul (argv[0], NULL, 10);
+
+  /* Update TE metric if needed */
+  if (ifp->link_te.te_metric == 0 ||  ifp->link_te.te_metric != value)
+    {
+      ifp->link_te.te_metric = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_maxbw,
+       mpls_te_link_maxbw_cmd,
+       "mpls-te link max-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Maximum bandwidth that can be used\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_maxbw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Maximum Bandwidth if needed */
+  if (ifp->link_te.max_bw == 0.0 || ifp->link_te.max_bw != bw)
+    {
+      ifp->link_te.max_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_max_rsv_bw,
+       mpls_te_link_max_rsv_bw_cmd,
+       "mpls-te link max-rsv-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Maximum bandwidth that may be reserved\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_max_rsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Maximum Reservable Bandwidth if needed */
+  if (ifp->link_te.max_rsv_bw == 0.0 || ifp->link_te.max_rsv_bw != bw)
+    {
+      ifp->link_te.max_rsv_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_unrsv_bw,
+       mpls_te_link_unrsv_bw_cmd,
+       "mpls-te link unrsv-bw <0-7> BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unreserved bandwidth at each priority level\n"
+       "Priority\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  int priority;
+  float bw;
+
+  /* We don't have to consider about range check here. */
+  if (sscanf (argv[0], "%d", &priority) != 1)
+    {
+      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (sscanf (argv[1], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_unrsv_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Unreserved Bandwidth if needed */
+  if (ifp->link_te.unrsv_bw[priority] == 0.0 || ifp->link_te.unrsv_bw[priority] != bw)
+    {
+      ifp->link_te.unrsv_bw[priority] = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_admin_grp,
+       mpls_te_link_admin_grp_cmd,
+       "mpls-te link admin-grp BITPATTERN",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Administrative group membership\n"
+       "32-bit Hexadecimal value (e.g. 0xa1)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  unsigned long value;
+
+  if (sscanf (argv[0], "0x%lx", &value) != 1)
+    {
+      vty_out (vty, "mpls_te_link_admin_grp: fscanf: %s%s",
+               safe_strerror (errno), VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Administrative Group if needed */
+  if (ifp->link_te.admin_grp == 0 ||  ifp->link_te.admin_grp != value)
+    {
+      ifp->link_te.admin_grp = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+/* INTER-AS */
+DEFUN (mpls_te_link_inter_as,
+       mpls_te_link_inter_as_cmd,
+       "mpls-te neighbor A.B.C.D as <0-65535>",
+       MPLS_TE_STR
+       "Configure remote ASBR information (Neighbor IP address and AS number)\n"
+       "Remote IP address in dot decimal A.B.C.D\n"
+       "Remote AS number\n"
+       "AS number in the range <0-65535>\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+  struct in_addr addr;
+  u_int32_t as;
+
+  if (!inet_aton (argv[0], &addr))
+    {
+      vty_out (vty, "Please specify Router-Addr by A.B.C.D%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  as = strtoul (argv[1], NULL, 10);
+
+  /* Update Remote IP and Remote AS fields if needed */
+  if ((ifp->link_te.rmt_as == 0 || ifp->link_te.rmt_as != as) ||
+      (ifp->link_te.rmt_ip.s_addr == 0 || ifp->link_te.rmt_ip.s_addr != addr.s_addr))
+    {
+
+      ifp->link_te.rmt_as = as;
+      ifp->link_te.rmt_ip.s_addr = addr.s_addr;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_mpls_te_link_inter_as,
+       no_mpls_te_link_inter_as_cmd,
+       "no mpls-te neighbor",
+       NO_STR
+       MPLS_TE_STR
+       "Remove Neighbor IP address and AS number for Inter-AS TE\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+
+  /* Reset Remote IP and AS neighbor */
+  ifp->link_te.rmt_as = 0;
+  ifp->link_te.rmt_ip.s_addr = 0;
+
+  /* force protocols to recalculate routes due to cost change */
+  if (if_is_operative (ifp))
+    zebra_interface_parameters_update (ifp);
+
+  return CMD_SUCCESS;
+}
+
+/* draft-ietf-ospf-metric-extensions-05.txt & draft-ietf-isis-metric-extensions-03.txt */
+DEFUN (mpls_te_link_delay,
+       mpls_te_link_delay_cmd,
+       "mpls-te link delay <0-16777215> {min <0-16777215>|max <0-16777215>}",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Average Link Delay (optionally Minimum and Maximum delays)\n"
+       "Average delay in micro-second as decimal (0...16777215)\n"
+       "Minimum delay\n"
+       "delay in micro-second as decimal (0...16777215)\n"
+       "Maximum delay\n"
+       "delay in micro-second as decimal (0...16777215)\n")
+{
+
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t delay = 0, low = 0, high = 0;
+
+  delay = strtoul (argv[0], NULL, 10);
+  if (argv[1] != NULL)
+      low = strtoul(argv[1], NULL, 10);
+  if (argv[2] != NULL)
+      high = strtoul(argv[2], NULL, 10);
+
+  /* Update Delays if needed */
+  if ((ifp->link_te.av_delay == 0 ||  ifp->link_te.av_delay != delay) ||
+      (ifp->link_te.min_delay == 0 || ifp->link_te.min_delay != low) ||
+      (ifp->link_te.max_delay == 0 || ifp->link_te.max_delay != high))
+    {
+      ifp->link_te.av_delay = delay;
+      ifp->link_te.min_delay = low;
+      ifp->link_te.max_delay = high;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_delay_var,
+       mpls_te_link_delay_var_cmd,
+       "mpls-te link delay-variation <0-16777215>",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Link Delay Variation\n"
+       "delay variation in micro-second as decimal (0...16777215)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  u_int32_t value;
+
+  value = strtoul (argv[0], NULL, 10);
+
+  /* Update Delay Variation if needed */
+  if (ifp->link_te.delay_var == 0 ||  ifp->link_te.delay_var != value)
+    {
+      ifp->link_te.delay_var = value;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_pkt_loss,
+       mpls_te_link_pkt_loss_cmd,
+       "mpls-te link packet-loss PERCENTAGE",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Link Packet Loss\n"
+       "percentage of total traffic by 0.000003% step and less than 50.331642%\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float fval;
+
+  if (sscanf (argv[0], "%g", &fval) != 1)
+    {
+      vty_out (vty, "mpls_te_link_pkt_loss: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (fval > MAX_PKT_LOSS)
+    fval = MAX_PKT_LOSS;
+
+  /* Update Packet Loss if needed */
+  if (ifp->link_te.pkt_loss >= 0.0 ||  ifp->link_te.pkt_loss != fval)
+    {
+      ifp->link_te.pkt_loss = fval;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_res_bw,
+       mpls_te_link_res_bw_cmd,
+       "mpls-te link res-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Residual Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_res_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Residual Bandwidth if needed */
+  if (ifp->link_te.res_bw == 0.0 || ifp->link_te.res_bw != bw)
+    {
+      ifp->link_te.res_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_ava_bw,
+       mpls_te_link_ava_bw_cmd,
+       "mpls-te link ava-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Available Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_ava_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Residual Bandwidth if needed */
+  if (ifp->link_te.ava_bw == 0.0 || ifp->link_te.ava_bw != bw)
+    {
+      ifp->link_te.ava_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_te_link_use_bw,
+       mpls_te_link_use_bw_cmd,
+       "mpls-te link use-bw BANDWIDTH",
+       MPLS_TE_STR
+       MPLS_TE_LINK_STR
+       "Unidirectional Available Bandwidth\n"
+       "Bytes/second (IEEE floating point format)\n")
+{
+  struct interface *ifp = (struct interface *) vty->index;
+  float bw;
+
+  if (sscanf (argv[0], "%g", &bw) != 1)
+    {
+      vty_out (vty, "mpls_te_link_use_bw: fscanf: %s%s", safe_strerror (errno),
+               VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Update Utilized Bandwidth if needed */
+  if (ifp->link_te.use_bw == 0.0 || ifp->link_te.use_bw != bw)
+    {
+      ifp->link_te.use_bw = bw;
+
+      /* force protocols to recalculate routes due to cost change */
+      if (if_is_operative (ifp))
+        zebra_interface_parameters_update (ifp);
+    }
+  return CMD_SUCCESS;
+}
+
+#endif /* Traffic Engineering */
+
 static int
 ip_address_install (struct vty *vty, struct interface *ifp,
 		    const char *addr_str, const char *peer_str,
@@ -1549,6 +2066,7 @@ if_config_write (struct vty *vty)
 {
   struct listnode *node;
   struct interface *ifp;
+  int i;
 
   for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
     {
@@ -1577,6 +2095,50 @@ if_config_write (struct vty *vty)
       if (ifp->bandwidth != 0)
 	vty_out(vty, " bandwidth %u%s", ifp->bandwidth, VTY_NEWLINE); 
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+      if (IS_LINK_TE(ifp))
+        {
+          vty_out(vty, " mpls-te on%s", VTY_NEWLINE);
+          if (ifp->link_te.te_metric != 0)
+            vty_out(vty, " mpls-te link metric %u%s",ifp->link_te.te_metric, VTY_NEWLINE);
+          if (ifp->link_te.max_bw > 0.0)
+            vty_out(vty, " mpls-te link max-bw %g (Byte/s)%s", ifp->link_te.max_bw, VTY_NEWLINE);
+          if (ifp->link_te.max_rsv_bw > 0.0)
+            vty_out(vty, " mpls-te link max-rsv-bw %g (Byte/s)%s", ifp->link_te.max_rsv_bw, VTY_NEWLINE);
+          for (i = 0; i < 8; i++)
+            {
+              if (ifp->link_te.unrsv_bw[i] > 0.0)
+                vty_out(vty, " mpls-te link unrsv-bw %d %g%s",
+                    i, ifp->link_te.unrsv_bw[i], VTY_NEWLINE);
+            }
+          if (ifp->link_te.admin_grp != 0)
+            vty_out(vty, " mpls-te link admin-grp %u%s", ifp->link_te.admin_grp, VTY_NEWLINE);
+          if (ifp->link_te.av_delay != 0)
+            {
+              vty_out(vty, " mpls-te link delay %u", ifp->link_te.av_delay);
+              if (ifp->link_te.min_delay != 0)
+                vty_out(vty, " min %u", ifp->link_te.min_delay);
+              if (ifp->link_te.max_delay != 0)
+                vty_out(vty, " max %u", ifp->link_te.max_delay);
+              vty_out(vty, "%s", VTY_NEWLINE);
+            }
+          if (ifp->link_te.delay_var != 0)
+            vty_out(vty, " mpls-te link delay-variation %u%s", ifp->link_te.delay_var, VTY_NEWLINE);
+          if (ifp->link_te.pkt_loss >= 0.0)
+            vty_out(vty, " mpls-te link packet-loss %g%s", ifp->link_te.pkt_loss, VTY_NEWLINE);
+          if (ifp->link_te.ava_bw > 0.0)
+            vty_out(vty, " mpls-te link ava-bw %g%s", ifp->link_te.ava_bw, VTY_NEWLINE);
+          if (ifp->link_te.res_bw > 0.0)
+            vty_out(vty, " mpls-te link res-bw %g%s", ifp->link_te.res_bw, VTY_NEWLINE);
+          if (ifp->link_te.use_bw > 0.0)
+            vty_out(vty, " mpls-te link use-bw %g%s", ifp->link_te.use_bw, VTY_NEWLINE);
+          if ((ifp->link_te.rmt_as != 0) && (ifp->link_te.rmt_ip.s_addr != 0))
+            vty_out(vty, " mpls-te neighbor %s as %u%s", inet_ntoa(ifp->link_te.rmt_ip),
+                ifp->link_te.rmt_as, VTY_NEWLINE);
+    }
+
+#endif /* Traffic Engineering */
+
       if (CHECK_FLAG(ifp->status, ZEBRA_INTERFACE_LINKDETECTION))
 	vty_out(vty, " link-detect%s", VTY_NEWLINE);
 
@@ -1658,4 +2220,21 @@ zebra_if_init (void)
   install_element (INTERFACE_NODE, &ip_address_label_cmd);
   install_element (INTERFACE_NODE, &no_ip_address_label_cmd);
 #endif /* HAVE_NETLINK */
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  install_element(INTERFACE_NODE, &mpls_te_enable_cmd);
+  install_element(INTERFACE_NODE, &no_mpls_te_enable_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_metric_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_maxbw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_max_rsv_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_unrsv_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_admin_grp_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_inter_as_cmd);
+  install_element(INTERFACE_NODE, &no_mpls_te_link_inter_as_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_delay_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_delay_var_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_pkt_loss_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_ava_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_res_bw_cmd);
+  install_element(INTERFACE_NODE, &mpls_te_link_use_bw_cmd);
+#endif /* Traffic Engineering */
 }
diff --git a/zebra/redistribute.c b/zebra/redistribute.c
index 078c2ad..41ca2a6 100644
--- a/zebra/redistribute.c
+++ b/zebra/redistribute.c
@@ -280,7 +280,7 @@ zebra_redistribute_default_delete (int command, struct zserv *client,
 				   int length)
 {
   client->redist_default = 0;;
-}     
+}
 
 /* Interface up information. */
 void
@@ -393,3 +393,20 @@ zebra_interface_address_delete_update (struct interface *ifp,
     if (client->ifinfo && CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
       zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_DELETE, client, ifp, ifc);
 }
+
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Interface parameters update */
+void
+zebra_interface_parameters_update (struct interface *ifp)
+{
+  struct listnode *node, *nnode;
+  struct zserv *client;
+
+  if (IS_ZEBRA_DEBUG_EVENT)
+    zlog_debug ("MESSAGE: ZEBRA_INTERFACE_UPDATE %s", ifp->name);
+
+  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
+    zsend_interface_update (ZEBRA_INTERFACE_UPDATE, client, ifp);
+
+}
+#endif /* Traffic Engineering */
diff --git a/zebra/redistribute.h b/zebra/redistribute.h
index 9ed99bc..c4669cb 100644
--- a/zebra/redistribute.h
+++ b/zebra/redistribute.h
@@ -46,6 +46,10 @@ extern void zebra_interface_address_add_update (struct interface *,
 extern void zebra_interface_address_delete_update (struct interface *,
 						   struct connected *c);
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+extern void zebra_interface_parameters_update (struct interface *);
+#endif /* Traffic Engineering */
+
 extern int zebra_check_addr (struct prefix *);
 
 #endif /* _ZEBRA_REDISTRIBUTE_H */
diff --git a/zebra/redistribute_null.c b/zebra/redistribute_null.c
index 54198c8..11904db 100644
--- a/zebra/redistribute_null.c
+++ b/zebra/redistribute_null.c
@@ -53,3 +53,9 @@ void zebra_interface_address_delete_update (struct interface *a,
                                                 struct connected *b)
 { return; }
 #endif
+
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+/* Interface parameters update */
+void zebra_interface_parameters_update (struct interface *ifp)
+{ return; };
+#endif /* Traffic Engineering */
diff --git a/zebra/zserv.c b/zebra/zserv.c
index ca17c2c..fbfd05e 100644
--- a/zebra/zserv.c
+++ b/zebra/zserv.c
@@ -152,6 +152,7 @@ zserv_encode_interface (struct stream *s, struct interface *ifp)
   stream_putl (s, ifp->mtu);
   stream_putl (s, ifp->mtu6);
   stream_putl (s, ifp->bandwidth);
+
 #ifdef HAVE_STRUCT_SOCKADDR_DL
   stream_put (s, &ifp->sdl, sizeof (ifp->sdl_storage));
 #else
@@ -160,6 +161,14 @@ zserv_encode_interface (struct stream *s, struct interface *ifp)
     stream_put (s, ifp->hw_addr, ifp->hw_addr_len);
 #endif /* HAVE_STRUCT_SOCKADDR_DL */
 
+#if defined(HAVE_OSPF_TE) || defined(HAVE_ISIS_TE)
+  /* Put Traffic Engineering status */
+  stream_putc (s, ifp->mpls_te);
+  /* Then, TE parameters if MPLS-TE is activate on this interface */
+  if (IS_LINK_TE(ifp))
+    stream_write (s, &ifp->link_te, INTERFACE_LINK_TE_SIZE);
+#endif /* Traffic Engineering */
+
   /* Write packet size. */
   stream_putw_at (s, 0, stream_get_endp (s));
 }
